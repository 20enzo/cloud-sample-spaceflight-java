//
//  Type system root classes 
//

class any { 
	own (key) {
		return this.hasOwnProperty(key) && this[key]
	}
	set (key, value) {
		Object.defineProperty (this, key, { value, writable:1, configurable:1 })
        return value
	}
	static mixin (methods) { 
		for (let each of Reflect.ownKeys (methods)) {
			Object.defineProperty (this.prototype, each, 
				Object.getOwnPropertyDescriptor (methods, each)
			)
		}
		return this
	}
}
any.prototype.isLinked = true
any._cds = true

class context extends any {}
class service extends context {}

class type extends any {}
class scalar extends type {}
class string extends scalar {}
class number extends scalar {}
class boolean extends scalar {}
class date extends scalar {}
class struct extends type {}
class array extends type {}

class entity extends struct {
	get keys(){ 
		if (this === entity.prototype)  return undefined
		let ee=this.elements, keys, dict={}
		for (let e in ee)  if (ee[e].key)  (keys=dict)[e] = ee[e]
        return this.set ('keys',keys)
	}
}

class Association extends type {
    get foreignkeys(){ return this.set ('foreignkeys', (
        this.keys ? this.keys.reduce ((fks,x) => {
            let {ref,as} = x.ref  ?  x  :  { ref:x, as:x.match(/[^.]+$/)[0] }
            try { var fk = ref.reduce ((p,n) => p.elements[n], this._target) } 
			catch(e){ fk = {__proto__:any.prototype, isUnresolved:1} }
            fks[as] = {__proto__:fk, name:as, ref }
            return fks
        },{}) 
        // :  this.target.kind == 'any' ? Object.assign ({ $target: {__proto__:string.prototype, name:'$target'} }, this._target.elements) 
        :  !this.on && this.is2one  ?  this._target.keys 
        :  null
     ))}
	get is2one(){ return !this.cardinality || this.cardinality.max === 1 || this.cardinality.targetMax === 1 }
    get is2many(){ return !this.is2one }
}

class Composition extends Association {}


//
//  Built-in types
//

const classes = {
    any, type, scalar, boolean, number, string, date, array, struct, 
    entity, view:entity, Association, Composition, context, service, 
}

const builtin = {
	UUID: { type:'string', length:36 },
	Boolean: {type:'boolean'},
	Integer: {type:'number'},
	Integer16: {type:'Integer'},
	Integer32: {type:'Integer'},
	Integer64: {type:'Integer'},
	Decimal: {type:'number'},
	DecFloat: { type:'number' },
	Float: {type:'number'},
	Double: {type:'number'},
	DateTime: {type:'date'},
	Date: {type:'date'},
	Time: {type:'date'},
	Timestamp: {type:'date'},
	String: {type:'string'},
	Binary: {type:'string'},
	LargeString: {type:'string'},
	LargeBinary: {type:'string'},
}

const types = {__proto__:builtin}
for (let n in builtin) {
	const b = types['cds.'+n] = builtin[n],  t = b.type
	b.__proto__ = types[t] || classes[t].prototype
}
for (let n in classes)  builtin[n] = classes[n].prototype
types['cds.Association'] = Association.prototype
types['cds.Composition'] = Composition.prototype

Object.defineProperty (classes, 'mixin', {value: (aspects) => {
	for (let each in aspects) {
		for (let kind of Reflect.ownKeys (aspects[each])) {
			Object.defineProperty (types[kind], each, 
				Object.getOwnPropertyDescriptor (aspects[each], kind)
			)
		}
	}
}})

module.exports = { types, classes }