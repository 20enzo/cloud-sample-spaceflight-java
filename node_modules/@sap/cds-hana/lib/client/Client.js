const hdb = require('hdb')
const {
  BaseClient,
  builder: {sqlFactory},
  errors: {
    IllegalFunctionArgumentError,
    InconsistentClientError,
    SqlError
  },
  expand: {
    createJoinCQNFromExpanded,
    hasExpand,
    rawToExpanded
  },
  postProcessing: {
    getPostProcessMapper,
    getPropertyMapper,
    postProcess
  }
} = require('@sap/cds-sql')

const HdbStatement = require('../statement/HdbStatement')
const {convertToISO, convertToISONoMillis, convertErrorCodeToString, convertToString} = require('../util')
const {
  CustomCreateBuilder,
  CustomDeleteBuilder,
  CustomDropBuilder,
  CustomSelectBuilder,
  CustomUpdateBuilder
} = require('../customBuilder/')

class Client extends BaseClient {
  /**
   * Create a Client object.
   *
   * @param {Object} connect
   * @param {string} connect.host - database host
   * @param {number} connect.port - database port
   * @param {string} connect.user - username for authentication
   * @param {string} connect.password - password for authentication
   * @param {string} [connect.schema] - default schema to be used
   *
   */
  constructor (connect) {
    super([
      ['cds.Boolean', Boolean],
      ['cds.Integer64', String],
      ['cds.DateTime', convertToISONoMillis],
      ['cds.Timestamp', convertToISO],
      // ['cds.Binary', convertToBuffer],
      // ['cds.LargeBinary', convertToBuffer],
      ['cds.LargeString', convertToString]
    ])

    this._dbc = hdb.createClient(connect)
    this._connect = connect
    this._user = 'ANONYMOUS' // Use anonymous HANA user as default
    // auto-commit is true by default
    this._dbc.setAutoCommit(true)
    this._transCount = 0

    this._dbc.on('close', () => {
      // try to re-connect
      if (this._isInUse) {
        this.connect()
          .catch(() => {
            this._isInUse = false
          })
      }
    })
  }

  /**
   * Open database connection.
   *
   * @returns {Promise} Promise that resolves with Client if successful and rejects if not.
   */
  connect () {
    return new Promise((resolve, reject) => {
      this._dbc.connect((err) => {
        if (err) {
          return reject(convertErrorCodeToString(err))
        }

        if (this._connect.schema) {
          this.execute(`SET SCHEMA ${this._connect.schema}`)
            .then(() => {
              this._isInUse = true
              resolve(this)
            })
            .catch((err) => {
              this._dbc.end()
              reject(convertErrorCodeToString(err))
            })
        } else {
          this._isInUse = true
          return resolve(this)
        }
      })
    })
  }

  /**
   * Close database connection.
   *
   * @returns {Promise} Promise that resolves if successful and rejects if not.
   */
  end () {
    this._isInUse = false
    return Promise.resolve(this._dbc.end())
  }

  /**
   * Execute SQL statement.
   *
   * If execution of SQL statement requires additional values,
   * then the values to be provided as an array.
   * In order to provide multiple value sets with a single execute (example: batch insert)
   * values have to be provided as arrays of values composed in an outer array.
   *
   * Method returns a result object.
   * For example, in case of SELECT the result object contains a result-set.
   * In case of INSERT/DELETE the result object contains a number of affected rows.
   *
   *  The query can be provided as SQL string or as CQN object.
   *
   * @example <caption>Simple Select as SQL string<caption>
   * .execute("SELECT * FROM T")
   * @example <caption>Select with filter as SQL string<caption>
   * .execute("SELECT * FROM T WHERE X = ?", [1])
   * @example <caption>Single Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [1, 'a'])
   * @example <caption>Multiple Insert as SQL string<caption>
   * .execute("INSERT INTO T (A, B) VALUES (?,?)", [[1, 'a'], [2, 'b']])
   * @example <caption>Simple Select as CQN object<caption>
   * .execute(SELECT.from('T'))
   * @example <caption>Select with filter as CQN object<caption>
   * .execute(SELECT.from('T').where(['x', '=', 1])
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @returns {Promise} Promise, that resolves with result object (array) if successful or rejects with error if not.
   * Result object can be undefined.
   */
  execute (query, values = []) {
    if (this._toBeDestroyed) {
      return Promise.reject(new InconsistentClientError())
    }

    if (!Array.isArray(values)) {
      return Promise.reject(new IllegalFunctionArgumentError('values'))
    }

    if (typeof query === 'string') {
      return this._executeSQL(query, values, new Map())
    }

    if (typeof query === 'function') {
      return this._runBlock(query)
    }

    try {
      if (hasExpand(query)) {
        return this._processExpand(query)
      }

      const {sql, values = []} = sqlFactory(query, {
        typeConversion: this._typeConversionMap,
        customBuilder: {
          DropBuilder: CustomDropBuilder,
          CreateBuilder: CustomCreateBuilder,
          SelectBuilder: CustomSelectBuilder,
          UpdateBuilder: CustomUpdateBuilder,
          DeleteBuilder: CustomDeleteBuilder
        },
        user: this._user
      }, this._csn)

      return this._executeSQL(sql, values, getPostProcessMapper(this._toService, this._csn, query), getPropertyMapper(this._csn, query, true))
    } catch (err) {
      // in case an object is passed and sql builder throws an error
      return Promise.reject(convertErrorCodeToString(err))
    }
  }

  _processExpand (cqn) {
    const sqls = []
    const expandQueries = createJoinCQNFromExpanded(cqn, this._csn)

    for (const cqn of expandQueries.queries) {
      cqn._conversionMapper = getPostProcessMapper(this._toService, this._csn, cqn)

      const {sql, values} = sqlFactory(cqn)
      sqls.push(this._executeExpand(sql, values))
    }

    return Promise.all(sqls)
      .then((results) => {
        return rawToExpanded(expandQueries, results)
      })
  }

  _executeExpand (sql, values) {
    if (Array.isArray(values) && values.length !== 0) {
      return this.prepareStatement(sql)
        .then((statement) => {
          return statement.execute(values)
        })
    }

    return new Promise((resolve, reject) => {
      this._dbc.exec(sql, (err, result) => {
        if (err) {
          return reject(new SqlError(convertErrorCodeToString(err), sql, values))
        }

        resolve(result)
      })
    })
  }

  _executeSQL (sql, values, postMapper, propertyMapper) {
    if (values.length !== 0) {
      return this.prepareStatement(sql)
        .then((statement) => {
          return statement.execute(values)
        })
        .then((result) => {
          return Promise.resolve(postProcess(result, postMapper, propertyMapper))
        })
        .catch((err) => {
          return Promise.reject(err)
        })
    }

    return new Promise((resolve, reject) => {
      this._dbc.exec(sql, (err, result) => {
        if (err) {
          return reject(new SqlError(convertErrorCodeToString(err), sql, values))
        }

        resolve(postProcess(result, postMapper, propertyMapper))
      })
    })
  }

  /**
   * Prepare SQL statement.
   *
   * @param {string} sql - SQL string to be prepared.
   * @returns {Promise} Promise, that resolves with HdbStatement if successful and rejects if not.
   */
  prepareStatement (sql) {
    return new Promise((resolve, reject) => {
      this._dbc.prepare(sql, (err, statement) => {
        if (err) {
          return reject(new SqlError(convertErrorCodeToString(err), sql))
        }

        resolve(new HdbStatement(statement, sql))
      })
    })
  }

  /**
   * Returns connection state.
   *
   * @returns {boolean} Returns if client is connected to the database or not.
   */
  isConnected () {
    return this._dbc.readyState === 'connected'
  }

  /**
   * Set database locale.
   *
   * @param {string} locale - String representation of locale.
   * @example
   * "en_US" "de_DE"
   */
  setLocale (locale) {
    this._locale = locale || 'en_US'
    // Works, but bad practise to access an internal scope
    this._dbc._connection.getClientInfo().setProperty('LOCALE', this._locale)
  }

  /**
   * Set database user.
   *
   * @param {string} user - User name.
   *
   * Default is an ANONYMOUS user.
   */
  setUser (user) {
    this._user = user || 'ANONYMOUS' // Use anonymous HANA user as fallback
    // Works, but bad practise to access an internal scope
    this._dbc._connection.getClientInfo().setProperty('XS_APPLICATIONUSER', this._user)
  }

  /**
   * Execute begin transaction.
   *
   * @returns {Promise} - Resolves if begin is successful, rejects if not.
   *
   * Note: In the current implementation the auto-commit is always set to false.
   * The begin method is needed for compliance with the Sqlite client.
   * The current implementation always resolves.
   */
  begin () {
    this._transCount++
    if (this._transCount === 1) {
      this._dbc.setAutoCommit(false)
    }

    return Promise.resolve()
  }

  /**
   * Execute commit transaction.
   *
   * @returns {Promise} - Resolves if commit is successful, rejects if not.
   */
  commit () {
    if (this._transCount === 0) {
      return Promise.resolve()
    }
    this._transCount--
    if (this._transCount === 0) {
      this._dbc.setAutoCommit(true)
      return new Promise((resolve, reject) => {
        this._dbc.commit((err) => {
          if (err) {
            return reject(convertErrorCodeToString(err))
          }
          resolve()
        })
      })
    }

    return Promise.resolve()
  }

  /**
   * Execute rollback transaction.
   *
   * @returns {Promise} - Resolves if rollback is successful, rejects if not.
   */
  rollback () {
    if (this._transCount === 0) {
      return Promise.resolve()
    }
    this._transCount--
    if (this._transCount === 0) {
      this._dbc.setAutoCommit(true)
      return new Promise((resolve, reject) => {
        this._dbc.rollback((err) => {
          if (err) {
            return reject(convertErrorCodeToString(err))
          }
          resolve()
        })
      })
    }

    return Promise.resolve()
  }

  /**
   * As hana does not support 'drop if exists' we need to handle this separately here.
   * Drop should not throw an error in case it was not successful because a table did not exist.
   * So we need to catch all errors related to not existing tables.
   * @private
   */
  _addDropsToChain (chain, drop) {
    return chain.then(() => this.run(drop).catch((err) => {
      if (!this._ignoreError(err)) {
        throw err
      }
    }))
  }

  _ignoreError (err) {
    // hana error code for table/view does not exist
    return err instanceof SqlError && (err.rootCause.code === '259' || err.rootCause.code === '321')
  }
}

module.exports = Client
