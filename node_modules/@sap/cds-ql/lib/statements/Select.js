const cds = require('../cds')

const Where = require('./Where')
const {
  IllegalFunctionArgumentError,
  JoinCalledError,
  UnexpectedFunctionCallError,
  HasBeenCalledError
} = require('../errors')
const {getOnCond} = require('@sap/cds-sql').onCond

/**
 * SELECT statement selects values or rows from a specific table.
 * @extends {Where}
 */
class Select extends Where {
  constructor () {
    super('SELECT')
  }

  /**
   * Wrapper that allows usages like:
   * SELECT(['column']).from('Table')
   * SELECT('column').from('Table')
   * SELECT.from('Table', ['column'])
   * @returns {function(*): Select}
   */
  static get select () {
    const fn = (...args) => {
      if (Array.isArray(args[0])) {
        args = args[0]
      }

      return {
        from: (entity, columns, model) => {
          return Select.from(entity, (columns && columns.length !== 0) ? args.concat(columns) : args, model)
        }
      }
    }

    fn.from = Select.from
    fn.one = Select.one

    return fn
  }

  /**
   * Select entries of an entity.
   * @param {string|object} entity - entity name or an entity from reflection API or CQN
   * @param {array} columns Can be either an array or an array in string notation that specifies a list of column names or a function
   * @param {object} model the reflected CSN model
   * @returns {Select} this object instance for chaining.
   */
  static from (entity, columns, model) {
    if (!entity) {
      throw new IllegalFunctionArgumentError('entity')
    }

    const cqn = new Select()
    if (model) {
      cqn._model = model
    }
    cqn._parseColumns(columns, entity)
    cqn._parseEntity(entity)

    return cqn
  }

  /**
   * Select one entry of the entity. Can be used in combination with where() or byId().
   * @param {string|object} entity - entity name or an entity from reflection API or CQN
   * @param  {array} columns Can be either an array that specifies a list of column names or a function
   * @returns {Select} this object instance for chaining.
   */
  static one (entity, columns) {
    return Select.from(entity, columns).limit(1)
  }

  _parseColumns (columns, entity) {
    if (columns) {
      if (Array.isArray(columns)) {
        this._parseArray(columns, entity)
      } else if (columns instanceof Object && !this._model) {
        this._model = columns
      } else if (typeof columns === 'string' && columns.includes('{') && columns.includes('}')) {
        this._parseArray(columns.match(/(\w[\w.{}]+)/g), entity)
      } else {
        throw new IllegalFunctionArgumentError('columns')
      }
    }
  }

  _parseEntity (entity) {
    if (typeof entity === 'string') {
      this._parseString(entity)
    } else if (typeof entity === 'object' && entity.hasOwnProperty('name')) {
      this._from(entity.name)
    } else if (typeof entity === 'object' && entity.hasOwnProperty('SELECT')) {
      this._fromCQN(entity)
    } else if (typeof entity === 'object') {
      this._fromObject(entity)
    } else {
      throw new IllegalFunctionArgumentError('entity')
    }
  }

  _fromObject (entity) {
    const key = this._getKey(entity, 'entity')
    if (key === 'ref') { // TODO: support further types of partial cqns like join.
      this.SELECT.from = entity
    } else {
      this._from(entity[key], key)
    }
  }

  /**
   * Group result by column names
   *
   * @param {...string} columns - String representing a column name.
   * @throws IllegalFunctionArgumentError
   * @returns {Select} this object instance for chaining.
   */
  groupBy (...columns) {
    if (columns.length === 0) {
      throw new IllegalFunctionArgumentError('columns')
    }

    columns.forEach(column => {
      this._addColumnToGroupBy(column)
    })

    return this
  }

  /**
   * Orders result by column names
   * @param {string|object} columnName - Column name or object describing the order
   * @param {string} [order] - sorting order, defaults to asc
   * @example
   * orderBy('Author', 'asc')
   * orderBy({Author: 'asc'})
   * @returns {Select} this object instance for chaining.
   */
  orderBy (columnName, order) {
    if (typeof columnName === 'string') {
      this._addColumnToOrderBy(columnName, order)
    } else if (typeof columnName === 'object') {
      this._addColumnToOrderByAsObject(columnName)
    } else {
      throw new IllegalFunctionArgumentError('columnName')
    }

    return this
  }

  /**
   * Add inner join.
   *
   * @param tableName - Table name to be used for join.
   * @returns {Select} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If where or having was already called.
   */
  join (tableName) {
    return this._join(tableName, 'inner')
  }

  /**
   * Add left join.
   *
   * @param tableName - Table name to be used for join.
   * @returns {Select} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If where or having was already called.
   */
  leftJoin (tableName) {
    return this._join(tableName, 'left')
  }

  /**
   * Add right join.
   *
   * @param tableName - Table name to be used for join.
   * @returns {Select} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If where or having was already called.
   */
  rightJoin (tableName) {
    return this._join(tableName, 'right')
  }

  /**
   * .on can only be used after .join has been called.
   * @param {string|Object} arg1 Can be object if argument is passed as an object or can be a string when an identifier is directly passed.
   * @param {*} [arg2] Can be a value or an operator if the 3rd argument is the value.
   * @param [arg3] Value or CQN if second argument is operator.
   * @param [arg4] Value in case the second argument is the 'between' operator; Otherwise ignored.
   * @returns {Select} this object instance for chaining.
   * @throws UnexpectedFunctionCallError - If called without calling join before.
   */
  on (arg1, arg2, arg3, arg4) {
    if (!this._getCQN().from.hasOwnProperty('join')) {
      throw new JoinCalledError(true)
    }
    this._getCQN().from.on = this._parseArguments(arg1, arg2, arg3, arg4)
    return this
  }

  /**
   * Add having. Can not be called before .where.
   * @example
   *  * Fluid usage:
   * having(`name like`, 'foo', `and ( ratio between`, 0.1, `and`, 0.3, `or ratio >`, 0.9, `)`)
   * @param {string|Object} arg1 Can be object if argument is passed as an object or can be a string when an identifier is directly passed. Can be an aggregation function.
   * @param {*} [arg2] Can be a value or an operator if the 3rd argument is the value.
   * @param [arg3] Value or CQN if second argument is operator.
   * @param [arg4] Value in case the second argument is the 'between' operator; Otherwise ignored.
   * @returns {Select} this object instance for chaining.
   * @throws IllegalFunctionArgumentError - If no arguments are passed
   * @throws HasBeenCalledError - If called more than once
   * @throws UnexpectedFunctionCallError - If called in wrong context
   *
   */
  having (arg1, arg2, arg3, arg4) {
    if (!arg1) {
      throw new IllegalFunctionArgumentError('arg1')
    }

    const cqn = this._getCQN()
    if (cqn.having) {
      return this._andHaving(...arguments)
    }

    cqn.having = []
    return this._having(...arguments)
  }

  _having (...args) {
    if (args.length === 0) {
      throw new IllegalFunctionArgumentError('arg1')
    }

    // currently we only support fluid usage with 4+ args
    if (arguments.length > 4) {
      this._getCQN().having.push(...this._fluidUsage(...args))
      return this
    }

    this._getCQN().having.push(...this._parseArguments(...args))
    return this
  }

  _andHaving (arg1, arg2, arg3, arg4) {
    const needBrackets = arg1 instanceof Object && arg1.or
    this._getCQN().having.push('and')

    if (needBrackets) {
      // in case of function 'and' was called and an object input param containing an 'or' we need to add brackets
      this._getCQN().having.push('(')
      this._having(...arguments)
      this._getCQN().having.push(')')
      return this
    }

    return this._having(...arguments)
  }

  /**
   * Add distinct.
   * @returns {Select} this object instance for chaining.
   * @throws HasBeenCalledError - If called more than once
   *
   */
  distinct () {
    const cqn = this._getCQN()
    if (cqn.distinct) {
      throw new HasBeenCalledError('distinct')
    }
    cqn.distinct = true

    return this
  }

  /**
   * Add limit.
   * @param {Number} rows - the number of records to return
   * @param {Number} [offset] - skip that many rows before beginning to return rows
   * @returns {Select} this object instance for chaining.
   * @throws IllegalFunctionArgumentError - if rows parameter not specified
   * @throws HasBeenCalledError - If called more than once
   *
   */
  limit (rows, offset) {
    if (!rows) {
      throw new IllegalFunctionArgumentError('rows')
    }

    const cqn = this._getCQN()

    if (cqn.limit) {
      throw new HasBeenCalledError('limit')
    }

    cqn.limit = {rows: {val: rows}}
    if (offset) {
      cqn.limit.offset = {val: offset}
    }

    return this
  }

  _join (tableName, kind) {
    if (!tableName) {
      throw new IllegalFunctionArgumentError('tableName')
    }

    if (this._getCQN().where) {
      throw new UnexpectedFunctionCallError('join')
    }

    if (this._getCQN().having) {
      throw new UnexpectedFunctionCallError('join')
    }

    if (this._getCQN().from.hasOwnProperty('join')) {
      this._getCQN().from = {join: kind, args: [this._getCQN().from, {ref: [tableName]}]}
      return this
    }

    const from = this._getCQN().from
    this._getCQN().from = {join: kind, args: [from, {ref: [tableName]}]}

    return this
  }

  _parseNameAndKeys (associationString) {
    const elements = associationString.match(/[^,[\]]+/g)// [Books, ID=10] or [books, ID=10] or [books]
    const result = {name: elements[0]}

    if (elements.length > 1) {
      result.keys = {}

      for (const e of elements.slice(1)) {
        const parts = e.split('=')
        result.keys[parts[0]] = parts[1]
      }
    }

    return result
  }

  _getReflectedAssociation (entityName, associationName) {
    const reflectedEntity = cds.reflect(this._model.definitions[entityName])
    const assocProperty = reflectedEntity.def.elements[associationName]
    const reflectedAssoc = cds.reflect(assocProperty)
    if (assocProperty && reflectedAssoc.is('Association')) {
      return reflectedAssoc
    }
  }

  _getEntityNameFromServiceName (serviceName) {
    return this._model.definitions[serviceName].source || this._model.definitions[serviceName].name
  }

  _entityName (name, previousEntityName) {
    return !previousEntityName ? this._getEntityNameFromServiceName(name) : this._getReflectedAssociation(previousEntityName, name).def.target
  }

  _addKeysToWhere (cqn, keys, tableAlias) {
    if (keys) {
      for (const key of Object.keys(keys)) {
        cqn.where(`${tableAlias}.${key}`, keys[key])
      }
    }
  }

  _addExistsToWhere (cqn, previousCqn) {
    cqn.where('exists', previousCqn)
  }

  _addOnCondToWhere (cqn, entity, tableAlias, identifier) {
    const onCond = getOnCond(this._model.definitions[entity.previous].elements[entity.current], entity.current, this._model, tableAlias, identifier)

    const previousRef = {
      identifier: onCond[0].ref[0],
      refname: onCond[0].ref[1]
    }
    const currentRef = {
      refname: onCond[2].ref[1],
      identifier: onCond[2].ref[0]
    }

    const params = [previousRef, onCond[1], currentRef]
    cqn.where(...params)
  }

  _parseAssociation (parts) {
    let previousCqn, previousEntityName

    for (let i = 0; i < parts.length; i++) {
      const lastElement = (i === parts.length - 1)
      const tableAlias = `T${i}`
      const {name, keys} = this._parseNameAndKeys(parts[i])
      const entityName = this._entityName(name, previousEntityName)
      let currentCqn

      // last element is 'this'
      if (lastElement) {
        this._from(entityName, tableAlias)
        this._addKeysToWhere(this, keys, tableAlias)
      } else {
        currentCqn = Select.from(entityName, [1])
        currentCqn._from(entityName, tableAlias)
        this._addKeysToWhere(currentCqn, keys, tableAlias)
      }

      if (previousCqn) {
        this._addOnCondToWhere(previousCqn, {current: name, previous: previousEntityName}, tableAlias, `T${i - 1}`)

        if (lastElement) {
          this._addExistsToWhere(this, previousCqn)
        } else {
          this._addExistsToWhere(currentCqn, previousCqn)
        }
      }

      previousCqn = currentCqn
      previousEntityName = entityName
    }
  }

  _parseString (entity) {
    if (entity === '') {
      throw new IllegalFunctionArgumentError('entity')
    }
    // associations look like Authors[10]:books
    const parts = entity.split(':')

    if (parts.length === 1) {
      const parsed = this._parseStringElement(entity)
      this._from(parsed.ref[0], parsed.as)
    } else {
      this._parseAssociation(parts)
    }
  }

  _from (entityName, asName) {
    const projection = Where._processProjections(entityName, this._model)
    if (projection.entityName !== entityName) {
      if (projection.columnMap) {
        this._mergeColumns(projection.columnMap)
      }
      this.SELECT.from = {ref: [projection.entityName]}
    } else {
      this.SELECT.from = {ref: [entityName]}
    }
    if (asName) {
      this.SELECT.from.as = asName
    }
  }

  _fromCQN (cqn) {
    this.SELECT.from = cqn
  }

  _mergeColumns (columns) {
    if (!this.SELECT.columns || this.SELECT.columns.length === 0) {
      this.SELECT.columns = this._composeCQNColumns(columns)
    } else {
      for (const column of this.SELECT.columns) {
        if (columns.has(column.ref[0]) && columns.get(column.ref[0]) !== column.ref[0]) {
          column.as = column.ref[0]
          column.ref[0] = columns.get(column.ref[0])
        }
      }
    }
  }

  _composeCQNColumns (columns) {
    const res = []
    for (const key of columns.keys()) {
      if (columns.get(key) === key) {
        res.push({ref: [key]})
      } else {
        res.push({ref: [columns.get(key)], as: key})
      }
    }

    return res
  }

  _addColumnToOrderByAsObject (columnObject) {
    this._extractKeysAndValuesFromObject(columnObject).forEach(item => {
      this._addColumnToOrderBy(item.key, item.value)
    })
  }

  _extractKeysAndValuesFromObject (object) {
    const array = []

    for (const key of Object.keys(object)) {
      array.push({key: key, value: object[key]})
    }

    return array
  }

  _addColumnToOrderBy (column, order = 'asc') {
    if (this.SELECT.hasOwnProperty('orderBy')) {
      this.SELECT.orderBy.push({ref: [column]})
    } else {
      this.SELECT.orderBy = [{ref: [column]}]
    }

    if (order === 'desc') {
      this.SELECT.orderBy[this.SELECT.orderBy.length - 1].sort = 'desc'
    } else if (order === 'asc') {
      this.SELECT.orderBy[this.SELECT.orderBy.length - 1].sort = 'asc'
    } else {
      throw new IllegalFunctionArgumentError('order')
    }
  }

  _addColumnToGroupBy (column) {
    if (this.SELECT.hasOwnProperty('groupBy')) {
      this.SELECT.groupBy.push({ref: [column]})
    } else {
      this.SELECT.groupBy = [{ref: [column]}]
    }
  }

  _parseArray (columns, entityName) {
    this.SELECT.columns = []
    const length = columns.length
    for (let i = 0; i < length; i++) {
      if (typeof columns[i] === 'string' && columns[i + 1] instanceof Array) {
        this.SELECT.columns.push(this._parseElement({[`expand(${columns[i]})`]: columns[i + 1]}))
        i++
      } else {
        if (typeof columns[i] === 'string' && columns[i].includes('.')) {
          this._parseElementWithDot(columns[i], entityName)
        } else {
          this.SELECT.columns.push(this._parseElement(columns[i]))
        }
      }
    }
  }

  _parseElement (element) {
    if (typeof element === 'string') {
      return this._parseStringElement(element)
    }

    if (typeof element === 'object') {
      return this._parseObjectElement(element)
    }

    if (this._isNumber(element)) {
      return this._parseNonCastedElement(element)
    }

    throw new IllegalFunctionArgumentError('columns')
  }

  /**
   * @examples
   * COUNT(1) AS count
   * SUM(number) AS number
   * COUNT(1)
   * @private
   */
  _parseStringElement (element) {
    const parts = element.split(' ')
    if (parts.length === 1) { // cannot be zero
      return this._parseNonCastedElement(element)
    }

    if (parts.length === 3 && parts[1].toUpperCase() === 'AS') {
      return this._parseCastedElement(parts[0], parts[2])
    }
    throw new IllegalFunctionArgumentError('element')
  }

  /**
   * @examples
   * {amount: 'COUNT(1)'}
   * {amount: 'SUM(number)'}
   * @private
   */
  _parseObjectElement (object) {
    // partial CQN: function calls and binding parameters are refs
    if (object.hasOwnProperty('val') || object.hasOwnProperty('ref') || object.hasOwnProperty('xpr') || object.hasOwnProperty('SELECT')) {
      return object
    }

    const key = this._getKey(object, 'columns')

    if ((key.startsWith('expand(') || key.startsWith('inline(')) && Array.isArray(object[key])) {
      return this._parseExpandInline(key, object[key])
    }

    return this._parseCastedElement(key, object[key])
  }

  _getKey (object, argumentName) {
    const key = Object.keys(object)[0]

    if (!key) {
      throw new IllegalFunctionArgumentError(argumentName)
    }

    return key
  }

  _parseExpandInline (expr, elements) {
    let ref, type
    if (expr.startsWith('expand(')) {
      type = 'expand'
      ref = {
        ref: [expr.replace(/(^expand\(|\)$)/g, '')]
      }
    } else {
      type = 'inline'
      ref = {
        ref: [expr.replace(/(^inline\(|\)$)/g, '')]
      }
    }
    ref[type] = []
    for (const element of elements) {
      ref[type].push(this._parseElement(element))
    }
    return ref
  }

  _parseElementWithDot (column, entityName) {
    if (column.includes('.{')) { // <-- inline, no isAssociation check
      this.SELECT.columns.push(this._buildInline(this._matchInline(column)))
    } else {
      // inline or column name with dot
      const parts = column.split(/\./)
      if (this._isAssociation(entityName, parts[0])) {
        this.SELECT.columns.push(this._parseElement({[`inline(${parts[0]})`]: [parts[1]]}))
      } else {
        this.SELECT.columns.push(this._parseStringElement(column))
      }
    }
  }

  _parseCastedElement (element, castedName) {
    const castedElement = this._parseNonCastedElement(element)
    castedElement.as = castedName
    return castedElement
  }

  /**
   * @examples
   * COUNT(1) => {ref: ['COUNT', {args: '1'}]}
   * SUM(number) => {ref: ['SUM', {args: [{ref: ['number']}]}]}
   * @private
   */
  _parseNonCastedElement (column) {
    if (this._isNumber(column)) {
      return {val: column}
    }

    if (this._isFunction(column)) {
      return this._parseFunction(column)
    }

    return {ref: [column]}
  }
}

module.exports = Select
