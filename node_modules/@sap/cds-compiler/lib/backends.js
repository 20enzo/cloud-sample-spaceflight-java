'use strict';

// New-style API functions for backends (i.e. functions that take a compiled
// augmented CSN and generate something from it)

// FIXME: Adapt and unify all API docus.

const exportAnnos = require('./i18n/export-annotations'); //export localized annotations values from a given CSN model
const exportUi5Style = require('./i18n/export-annotations-ui5-style');
const csnToSwagger = require('./render/toSwagger');
const { transformForHana } = require('./transform/forHana');
const { compact, compactSorted } = require('./json/compactor')
const { compactModel } = require('./json/to-csn')
const { toCdsSourceNew } = require('./render/toCdlNew');
const { toSqlDdl } = require('./render/toSql');
const { toRenameDdl } = require('./render/toRename');
const { transform4odata, getServiceNames, postProcessForBackwardCompatibility } = require('./transform/forOdata');
const csn2edm = require('./edm/csn2edm');
const { mergeOptions }  = require('./model/modelUtils');
const { transformTntExtensions } = require('./transform/tntSpecific');
const alerts = require('./base/alerts');
const propagator = require('./compiler/propagator');

// Transform an augmented CSN 'model' into HANA-compatible CDS source.
// The following options control what is actually generated:
//   options : {
//     toHana.names        : either 'flat' or 'deep' (default)
//                           'flat': Produce HANA entity and element names in uppercase and
//                                   flattened with underscores. Do not generate structured
//                                   types.
//                           'deep': Produce HANA entity and element names in original case
//                                   as in CDL. Keep nested contexts (resulting in entity names
//                                   with dots), but flatten element names with underscores.
//                                   Generate structured types, too.
//     toHana.associations : either 'assocs' (default, keep associations as they are if possible)
//                           or 'joins' (replace associations by joins)
//     toHana.src          : if true, generate HANA CDS source files (default)
//     toHana.csn          : if true, generate the transformed CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If 'toHana.names' is not provided, 'deep' is used.
// If 'toHana.associations' is not provided, 'assocs' is used.
// If neither 'toHana.src' nor 'toHana.csn' are provided, the default is to generate only HANA CDS
// source files.
// If all provided options are part of 'toHana', the 'toHana' wrapper can be omitted.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model
//     _augmentedCsn     : (subject to change): the augmented CSN model
//     hdbcds            : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : the HANA CDS source string of the artifact 'X'. Please note that the
//                         name of 'X' may contain characters that are not legal for filenames on
//                         all operating systems (e.g. ':', '\' or '/').
//                         X reflects the naming policy set by toHana.names
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toHana(model, options) {
  // Must perform propagation now if it was disabled for the original CSN output
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  // Optional wrapper?
  if (options && !options.toHana) {
    options = { toHana : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toHana : getDefaultBackendOptions().toHana }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toHana.src && !options.toHana.csn) {
    options.toHana.src = true;
  }

  // Special case: For naming variant 'hdbcds' in combination with 'toHana' (and only there!), 'forHana'
  // must leave namespaces, structs and associations alone.
  if (options.toHana.names == 'hdbcds') {
    options = mergeOptions(options, { forHana : { keepNamespaces: true, keepStructsAssocs: true } });
  }

  // Prepare model for HANA (transferring the options to forHana)
  let forHanaAugmented = transformForHana(model, mergeOptions(options, { forHana : options.toHana } ));

  // Assemble result
  let result = {};
  if (options.toHana.src) {
    result.hdbcds = toCdsSourceNew(forHanaAugmented);
  }
  if (options.toHana.csn) {
    result._augmentedCsn = forHanaAugmented;
    result.csn = options.newCsn ? compactModel(forHanaAugmented) : compactSorted(forHanaAugmented);
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forHanaAugmented.messages && forHanaAugmented.messages.length > 0) {
    result.messages = forHanaAugmented.messages;
  }
  return result;
}

// Generate ODATA for augmented CSN `model` using `options`.
// Before anything is generated, the following transformations are applied to 'model':
// FIXME: Verify that this is still correct
// - Flatten structured elements (and foreign keys of managed associations pointing to
//   keys that are themselves managed associations).
// - Generate foreign key fields for entities with managed associations (annotated with
//   '@odata.foreignKey4'). Propagate along projections accordingly. Names are built using
//   <assoc>_<key>, conflicts are checked.
// - Complete the 'foreignKeys' property for all managed associations, so that there
//   is always a 'generatedFieldName' for the corresponding generated foreign key field.
// - Implicitly redirect associations based on exposure
// - Check that exposed associations do not point to non-exposed targets
// - Unravel derived type chains, propagating annotations upwards.
// - Rename annotations according to a fixed list of short-hands
// The following options control what is actually generated:
//   options : {
//     toOdata.version     : either 'v2' or 'v4' (default)
//     toOdata.xml         : if true, generate XML output (default)
//     toOdata.json        : if true, generate JSON output (not available for ODATA V2)
//     toOdata.separate    : if true, generate XML 'metadata' and XML 'annotations' separately
//     toOdata.combined    : if true, generate XML metadata and XML annotations together as
//                           'combined' (default)
//     toOdata.csn         : if true, generate the transformed CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If 'toOdata.version' is not provided, 'v4' is used.
// If neither 'toOdata.xml' nor 'toOdata.json' nor 'toOdata.csn' are provided, the default is
// to generate only XML output. If neither 'toOdata.separate' nor 'toOdata.combined' are provided,
// the default is to generate only combined XML output.
// If all provided options are part of 'toOdata', the 'toOdata' wrapper can be omitted.
//
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model including all services
//     _augmentedCsn     : (subject to change): the augmented CSN model including all services
//     services          : a dictionary of service names, containing for each name:
//       <servicename> : {
//         annotations   : an XML string with EDMX annotations for service 'svc'
//         metadata      : an XML string with EDMX metadata for service 'svc'
//         combined      : an XML string with both EDMX metadata and annotations for service 'svc'
//         metadata_json : a JSON object (not a string!) with EDM metadata for service 'svc'
//       }
//     messages          : an array of strings with warnings (if any)
//   }
// If 'model' does not contain any services, 'csn' will still contain the transformed model, but
// 'services' will be an empty dictionary.
//
// Throws a CompilationError on errors.
function toOdata(model, options) {
  // Must perform propagation now if it was disabled for the original CSN output
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  const { error, signal } = alerts(model);
  // Optional wrapper?
  if (options && !options.toOdata) {
    options = { toOdata : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toOdata : getDefaultBackendOptions().toOdata }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toOdata.xml && !options.toOdata.json && !options.toOdata.csn) {
    options.toOdata.xml = true;
  }
  if (!options.toOdata.separate && !options.toOdata.combined) {
    options.toOdata.combined = true;
  }

  // Perform extra-magic for TNT if requested
  if (model.options.tntFlavor) {
    model = transformTntExtensions(model);
  }

  // Prepare model for ODATA processing
  let forOdataAugmented = transform4odata(model, options);

  // Assemble result object
  let result = {
    services: Object.create(null),
    messages: model.messages,
  }
  if (options.toOdata.csn) {
    // TODO: make compactSortedJson the default
    result.csn = options.newCsn ? compactModel(forOdataAugmented)
                                : (options.testMode ? compactSorted(forOdataAugmented) : compact(forOdataAugmented));
    result._augmentedCsn = forOdataAugmented;
  }

  // Create annotations and metadata once per service
  if (options.toOdata.xml || options.toOdata.json) {
    for (let serviceName of getServiceNames(model))
    {
      let forOdata = postProcessForBackwardCompatibility(forOdataAugmented, serviceName);
      // FIXME: Unify handling of version and tntFlavor (use original options)
      let l_edm = csn2edm(forOdata, { version: options.toOdata.version, tntFlavor : options.tntFlavor });

      result.services[serviceName] = {};
      if (options.toOdata.xml) {
        if (options.toOdata.separate) {
          result.services[serviceName].annotations = l_edm.toXML('annotations');
          result.services[serviceName].metadata = l_edm.toXML('metadata');
        }
        if (options.toOdata.combined) {
          result.services[serviceName].combined = l_edm.toXML('all');
        }
      }
      if (options.toOdata.json) {
        // JSON output is not available for ODATA V2
        if (options.toOdata.version == 'v2') {
          signal(error`ODATA JSON output is not available for ODATA V2`);
        }
        // FIXME: Why only metadata_json - isn't this rather a 'combined_json' ? If so, rename it!
        result.services[serviceName].metadata_json = l_edm.toJSON();
      }
    }
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forOdataAugmented.messages && forOdataAugmented.messages.length > 0) {
    result.messages = forOdataAugmented.messages;
  }
  return result;
}

// Generate CDS source text for augmented CSN model 'model'.
// The following options control what is actually generated:
//   options : {
//     FIXME: This option should be removed and something like 'toCdl.dialect: 'hana' be
//            used instead.
//     toHana : if true, HANA-specific source dialect is generated (affects e.g. the
//              translation of '$self.foo' in paths and ::-ish namespace declarations)
//   }
// One source is created per top-level artifact.
// Return a dictionary of top-level artifacts
// by their names, like this:
// { "foo" : "using XY; context foo {...};",
//   "bar::wiz" : "namespace bar::; entity wiz {...};"
// }
// Throws a CompilationError on errors.
function toCdl(model, options) {
  // Must perform propagation now if it was disabled for the original CSN output
  // FIXME: Hmm, or maybe we don't - this might even benefit from not propagating anything ...
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  // Merge options with those from model
  options = mergeOptions({ toCdl : true }, model.options, options);
  return toCdsSourceNew(model, options);
}

// Generate OpenAPI JSON version 3 for the augmented CSN 'model'.
// The following options control what is actually generated:
//   options : {
//     toSwagger.json      : if true, generate OpenAPI JSON output
//     toSwagger.csn       : if true, generate the transformed CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If neither 'toSwagger.json' nor 'toSwagger.csn' are provided, the default is to generate
// only OpenAPI JSON.
// If all provided options are part of 'toSwagger', the 'toSwagger' wrapper can be omitted.
// One OpenAPI JSON object is created per service.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result: {
//     csn               : the (compact) transformed CSN model including all services
//     _augmentedCsn     : (subject to change): the augmented CSN model including all services
//     services: {
//       <servicename>: {
//         openapi: '3.0.0',
//         info: { ... },
//         paths: { ...},
//         components: {
//           schemas: { ... }
//         }
//       }
//     }
//   }
//
// Throws a CompilationError on errors.
function toSwagger(model, options) {
  // Must perform propagation now if it was disabled for the original CSN output
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  // Optional wrapper?
  if (options && !options.toSwagger) {
    options = { toSwagger : options };
  }
  // Merge options with those from model
  options = mergeOptions(model.options, options);
  // If neither 'json' nor 'csn' is specified as output option, produce 'json'
  if (!options.toSwagger || (!options.toSwagger.json && !options.toSwagger.csn)) {
    options = mergeOptions({ toSwagger: { json: true } }, options);
  }
  // Actual implementation
  return csnToSwagger(model, options);
}

// Generate SQL DDL statements for augmented CSN 'model'.
// The following options control what is actually generated:
//   options : {
//     toSql.names         : either 'flat' (default), 'deep' or 'hdbcds'
//                           'flat':  Produce SQL table and view names in uppercase and
//                                    flattened with underscores (no quotes required)
//                           'deep':  Produce SQL table and view names in original case
//                                    as in CDL (with dots), but flatten element names with
//                                    underscores (requires quotes).
//                           'hdbcds: Produce SQL table, view and column names as HANA CDS
//                                    would generate them from the same CDS source (like "deep",
//                                    but using element names with dots).
//     toSql.associations  : either 'assocs' (default, keep associations as they are if possible)
//                           or 'joins' (replace associations by joins)
//     toSql.src           : if true, generate SQL DDL source files (default)
//     toSql.csn           : if true, generate the transformed CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If 'toSql.names' is not provided, 'deep' is used.
// If 'toSql.associations' is not provided, 'assocs' is used.
// If neither 'toSql.src' nor 'toSql.csn' are provided, the default is to generate only SQL DDL
// source files.
// If all provided options are part of 'toSql', the 'toSql' wrapper can be omitted.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model
//     _augmentedCsn     : (subject to change): the augmented CSN model
//     sql               : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : a string with SQL DDL statements for artifact 'X', terminated with ';'.
//                         Please note that the name of 'X' may contain characters that are not
//                         legal for filenames on all operating systems (e.g. ':', '\' or '/').
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toSql(model, options) {
  // Must perform propagation now if it was disabled for the original CSN output
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  // Optional wrapper?
  if (options && !options.toSql) {
    options = { toSql : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toSql : getDefaultBackendOptions().toSql }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toSql.src && !options.toSql.csn) {
    options.toSql.src = true;
  }

  // Special case: For naming variant 'hdbcds' in combination with 'toSql', 'forHana' must leave
  // namespaces alone (but must still flatten structs because we need the leaf element names).
  if (options.toSql.names == 'hdbcds') {
    options = mergeOptions(options, { forHana : { keepNamespaces: true } });
  }

  // FIXME: Currently, '--to-sql' implies transformation for HANA (transferring the options to forHana)
  let forSqlAugmented = transformForHana(model, mergeOptions(options, { forHana : options.toSql } ));

  // Assemble result
  let result = {};
  if (options.toSql.src) {
    result.sql = toSqlDdl(forSqlAugmented);
  }
  if (options.toSql.csn) {
    result._augmentedCsn = forSqlAugmented;
    result.csn = options.newCsn ? compactModel(forSqlAugmented) : compactSorted(forSqlAugmented);
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forSqlAugmented.messages && forSqlAugmented.messages.length > 0) {
    result.messages = forSqlAugmented.messages;
  }
  return result;
}

// FIXME: Not yet supported, only in beta mode
// Generate SQL DDL rename statements for a migration, renaming existing tables and their
// columns so that they match the result of "toHana" or "toSql" with the "{ names: 'flat' }
// option.
// Expects the naming convention of the existing tables to be either 'deep' or 'hdbcds' (default).
// The following options control what is actually generated:
//   options : {
//     toRename.names      :  existing names, either 'deep' or 'hdbcds' (default)
//   }
// Return a dictionary of top-level artifacts by their names, like this:
// { "foo" : "RENAME TABLE \"foo\" ...",
//   "bar::wiz" : "RENAME VIEW \"bar::wiz\" ..."
// }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If all provided options are part of 'toRename', the 'toRename' wrapper can be omitted.
// The result object contains the generation results as follows:
//   result : {
//     rename            : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : a string with SQL DDL statements for artifact 'X', terminated with ';'.
//                         Please note that the name of 'X' may contain characters that are not
//                         legal for filenames on all operating systems (e.g. ':', '\' or '/').
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toRename(model, options) {
  const { error, signal } = alerts(model);

  // Must perform propagation now if it was disabled for the original CSN output
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  // Optional wrapper?
  if (options && !options.toRename) {
    options = { toRename : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toRename : getDefaultBackendOptions().toRename }, model.options, options);

  // Requires beta mode
  if (!options.betaMode) {
    signal(error`Generation of SQL rename statements is not supported yet (only in beta mode)`);
  }

  // Special case: For naming variant 'hdbcds' in combination with 'toRename', 'forHana' must leave
  // namespaces alone (but must still flatten structs because we need the leaf element names).
  if (options.toRename.names == 'hdbcds') {
    options = mergeOptions(options, { forHana : { keepNamespaces: true } });
  }

  // FIXME: Currently, '--to-rename' implies transformation for HANA (transferring the options to forHana)
  let forHanaAugmented = transformForHana(model, mergeOptions(options, { forHana : options.toRename } ));

  // Assemble result
  let result = {
    rename : toRenameDdl(forHanaAugmented),
  };

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forHanaAugmented.messages && forHanaAugmented.messages.length > 0) {
    result.messages = forHanaAugmented.messages;
  }
  return result;
}

// Generate files for translation of localized annotations for augmented CSN 'model'.
// The following options control what is actually generated:
//   options : {
//     FIXME: Should not be a choice between the two styles but rather a collection of flags
//     toI18n.style : can be 'prop' for property files (default) or 'ui5' for a CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If all provided options are part of 'toI18n', the 'toI18n' wrapper can be omitted.
// Returns Object with having as property names the representation of the location of the annotation
// and respective values - the annotation string value
function toI18n(model, options) {
  // No propagation required (actually, we are better off better without it)

  // Optional wrapper?
  if (options && !options.toI18n) {
    options = { toI18n : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toI18n : getDefaultBackendOptions().toI18n }, model.options, options);

  // Generate what was requested
  if (options.toI18n.style == 'prop') {
    return exportAnnos(model, options);
  } else if (options.toI18n.style == 'ui5') {
    return exportUi5Style(model, options);
  } else {
    throw new Error(`Invalid style ${options.toI18n.style} for toI18n`);
  }
}

// Generate compact CSN for augmented CSN 'model'
// The following options control what is actually generated:
//   options : {
//     testMode : if true, the result is extra-stable for automated tests (sorted, no 'version')
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
function toCsn(model, options) {
  // Propagation has been performed (or not) by the compiler - leave that as it was.
  
  // Merge options with those from model
  options = mergeOptions({ toCsn : true }, model.options, options);
  return options.newCsn ? compactModel(model)
                        : (options.testMode ? compactSorted(model) : compact(model));
}

// Return a set of options containing the defaults that would be applied by the backends.
// Note that this only contains simple mergeable default values, not conditional defaults
// that depend in any way on other options (e.g. toSql provides 'src' if neither 'src' nor
// 'csn' is given: this is a conditional default).   
function getDefaultBackendOptions() {
  return {
    toHana: {
      names : 'flat',
      associations: 'assocs',
    },
    toOdata: {
      version : 'v4',
    },
    toRename: {
      names: 'hdbcds',
    },
    toSql: {
      names : 'flat',
      associations: 'assocs',
    },
    toI18n: {
      style: 'prop',
    },
  };
} 

module.exports = {
  toHana,
  toOdata,
  toCdl,
  toSwagger,
  toSql,
  toI18n,
  toCsn,
  getDefaultBackendOptions,
  toRename,
}
