let W = require("./walker");

function createInstance(model) {
  let U = require("./augmentor3utils.js")(model)
  return getTransformers(model,U);
}

function getTransformers(model,U) {

  function newValue(val, path, name, which=U.WILO_FULL) {
    if(val===undefined)
      return undefined;
    if(U.isAugmented(val))
      return undefined;
    let ret;
    let literal = typeof val; // TODO
    if(val===null) {
      ret = { literal: 'null', val };
    }
    else if(Array.isArray(val)) { // process array
      ret = { literal: 'array',
        val: val.map((V,I) => newValue( V, path.concat(''+I) ) )
      };
    }
    else if(literal !== "object") {  // number, string
      ret = { literal, val };
    }
    else if ('#' in val) {      // TODO: length / other property test?
      ret = { literal: 'enum', symbol: { id: val['#']} };
    }
    else if ('=' in val) {    // TODO: length / other property test?
      let location = U.newLocation(path);
      ret = { path: val['='].split('.').map( id => ({ id, location }) ) };
    }
    else {
      let struct = {};// TODO why not -> Object.create(null);
      ret = { literal: 'struct', struct };
      W.forEach(val, (K,V) => {
        struct[K] = newValue(V, path.concat(K), K);
      })
    }
    if(name) {
      ret.name = {id:name};
      U.setLocation(ret.name, path);
    }
    U.setLocation(ret, path, which);
    if(ret.symbol)
      U.setLocation(ret.symbol, path);
    U.setAugmented(ret)
    return ret;
  }

  function modifyCondition(node, name, path) {
    node.onCond = augmentXPR(node.on, path.concat(name));
    delete node["on"]
  }

  function modifyIncludes(node, name, path) {
    let location = U.newLocation(path.concat(name), U.WILO_LAST)
    let value = node[name];
    let r = value.map(X => {
      return {path:[{id:X,location}],location}
    })
    node[name] = r;
  }

  function modifyValue(node, name, path) {
    let value = newValue(node[name], path.concat(name))
    if(value!==undefined)
      node[name] = value;
  }

  function modifyBoolean(node, name, path) {
    let value = node[name];
    if(value !== undefined) {
      node[name]={val: value};
      U.setLocation(node[name], path.concat(name));
    }
  }

  function annotateExtensions(/*node, name, path*/) {
  }

  function ignore(/*node, name, path*/) {
  }

  function nonEmptyDict(/*node, name, path*/) {
  }

  function insertOrderDict(/*node, name, path*/) {
  }

  function arrayAsDict(node, name, path, xsnName=name) {
    let A = node[name]
    let R = Object.create(null);
    A.forEach((X,I) => {
      let ipath = path.concat([name,I]);
      let location = U.newLocation(ipath, U.WILO_FULL);
      let locationRef = U.newLocation(ipath.concat("ref"), U.WILO_FULL);
      let elementName = U.getLastElement(X.ref);
      let O = {
        kind:"key",
        targetElement: {
          path: X.ref.map((Y,J) => {
            let location = U.newLocation(ipath.concat(["ref",""+J]), U.WILO_FULL);
            return {id:Y,location};
          }),
          location:locationRef
        },
        location
      }
      //if "as" is present set it as "name" property
      if(X.as !== undefined) {
        elementName = X.as;
        O.name = {
          id:  X.as,
          location: U.newLocation(ipath.concat("as"), U.WILO_LAST)
        }
      }
      R[elementName] = O;
    })
    node[xsnName] = R;
    // Remark: transformation via in-place replacement is probably not the best idea...
    if (xsnName !== name)
      delete node[name];
  }

  function modifyKind(node) {
    if(node.kind === "view")
      node.kind = "entity";
  }

  function modifyNumber(node, name, path, newName = undefined) {
    if(U.isAugmented(node[name]))
      return;
    let location = U.newLocation(path.concat(name), U.WILO_LAST)
    let value=node[name];
    if(newName!==undefined) {
      delete node[name]
      name = newName;
    }
    if(value !== undefined) {
      node[name]={val: value, literal:"number", location};
      U.setAugmented(node[name]);
    }
  }

  function cardinality(node, name, path) {
    let lpath = path.concat([name]);
    let cardinality= node.cardinality;
    if(cardinality) {
      U.setLocation(cardinality, lpath);
      if(cardinality.src !== undefined) {
        if(cardinality.src === "*")
          cardinality.sourceMax = newValue(cardinality.src, lpath.concat("src"), undefined, U.WILO_LAST);
        else
          modifyNumber(cardinality, "src", lpath, "sourceMax");
        delete cardinality["src"]
      }
      if(cardinality.min !== undefined) {
        if(cardinality.min === "*")
          cardinality.targetMin = newValue(cardinality.min, lpath.concat("min"), undefined, U.WILO_LAST);
        else
          modifyNumber(cardinality, "min", lpath, "targetMin");
        delete cardinality["min"]
      }
      if(cardinality.max !== undefined) {
        if(cardinality.max === "*")
          cardinality.targetMax = newValue(cardinality.max, lpath.concat("max"), undefined, U.WILO_LAST);
        else
          modifyNumber(cardinality, "max", lpath, "targetMax");
        delete cardinality["max"]
      }
    }
  }

  function standard(/*node, name, path*/) {
  }

  function augmentTypeRef(val,path) {
    let location = U.newLocation(path, U.WILO_LAST)
    let ids = [val];
    let newPath;
    if(typeof val == 'string') {
      ids = val.split(".");
      if(ids[0]==="cds") // cds.XYZ
        ids=[val]
      newPath = ids.map(id => {
        return {id, location};
      });
    } else if(val.ref) {
      newPath = refAsPath(val.ref, path.concat("ref"))
    } else
      throw Error ("Unexpected type reference '"+(typeof val)+"' under "+path.join("/"));
    let r = {
      path:newPath,
      location
    }
    if(val.ref) {
      let element = val.ref.slice(1);
      r.element = element.join(".");
    }
    return r;
  }

  function artifactRef(node, name, path) {
    node[name] = augmentTypeRef(node[name],path.concat(name));
  }

  function fromOld(/*node, name, path*/) {
  }

  function condition(/*node, name, path*/) {
  }

  function augmentLiteralValue(val, path) {
    let location = U.newLocation(path)
    let literal = typeof val;
    return {val, literal, location};
  }

  function refAsPath(ref, path) {
    let R = ref.map((id,I) => {
      let location = U.newLocation(path.concat(""+I))
      return {id,location}
    })
    return R;
  }

  function augmentExpressionItem(val, path) {
    let location = U.newLocation(path)
    if(val === null)
      return {val:null,location}
    let t = typeof val;
    if(t === "string") {
      return val;
    } else if(t === "boolean")
      return {val, literal: 'boolean', location};
    if(val.hasOwnProperty("ref")) {
      return {
        path: refAsPath(val.ref, path.concat("ref")), // TODO remove this later - here 'ref' is renamed to 'path'
        location};
    } else if(val.hasOwnProperty("literal")) {
      if(!val.hasOwnProperty("val"))
        throw Error("Literal without val property")
      val.location = U.newLocation(path);
      return val;
    } else if(val.hasOwnProperty("val")) {
      return augmentLiteralValue(val.val, path)
    } else if(val.hasOwnProperty("func")) {
      return {
        op:{val: "call"},
        func: val.func,
        args: val.args
      }
    } else if(val.hasOwnProperty("#")) {
      return {
        literal:"enum", symbol:{id:val["#"],location},location
      }
    }
    throw Error("augmentExpressionItem failed: "+JSON.stringify(val)+path.join("/"))
  }

  function modifyExpression(node, name, path) {
    let X = node[name];
    if(!Array.isArray(X))
      throw Error("Expression should be an array");
    node[name] = augmentExpression(X, path.concat(name));
  }

  function augmentXPR(xpr, path) {
    if(xpr===undefined)
      return undefined;
    let location = U.newLocation(path, U.WILO_FULL)
    return {
      op: { val:"xpr", location} ,
      args: augmentExpression(xpr, path),
      location
    }
  }

  function augmentExpression(X,path) {
    if(!Array.isArray(X))
      throw Error("Expression should be an array");
    return X.map((Y,I) => augmentExpressionItem(Y, path.concat(""+I)))
  }

  function query(node, name, path) {
    let location = U.newLocation(path.concat(name), U.WILO_FULL)
    let selectPath = path.concat([name,"SELECT"]);
    let fromPath = selectPath.concat("from");
    let columnsPath = selectPath.concat("columns");

    function getQuerySource(q) {
      let qo = q.SELECT;
      if(qo.from.ref) {
        let ref = qo.from.ref;
        let refPath = fromPath.concat("ref")
        return ref.map( (X,I) => {
          return {
            id:X,
            location:U.newLocation(refPath.concat(I), U.WILO_FULL)
          }
        })
      }
      return undefined;
    }

    let src = getQuerySource(node.query);

    let columns = node.query.SELECT.columns;
    let elements = Object.create(null);
    columns.forEach((C,iC) => {
      if(C.ref) {
        let refPath = columnsPath.concat([iC,"ref"])
        let elementNameId = C.ref.join(".")
        let elementNameLocation = U.newLocation(refPath, U.WILO_FULL);
        let path = C.ref.map((E,iE) => {
          return {
            id:E,
            location:U.newLocation(refPath.concat(iE), U.WILO_FULL)
          };
        })
        if(C.as) {
          elementNameId=C.as;
          elementNameLocation = U.newLocation(columnsPath.concat([iC,"as"]), U.WILO_FULL);
        }
        let elementName = {id: elementNameId, location: elementNameLocation};
        if(!C.as)
          elementName.$inferred="as";
        elements[elementNameId] = {
          value: {path, location: elementNameLocation},
          name: elementName,
          kind: "element",
          location: elementNameLocation
        };
      }
    })

    let all;
    if(Array.isArray(columns)) {
      if(columns.includes("*"))
        all = {val: true, location};
    }
    let from = node.query.SELECT.from;
    let fromName;
    let locationFrom = U.newLocation(fromPath, U.WILO_FULL)
    if(!from.as) {
      fromName = {
        id:src.map(X => X.id).join("."),
        $inferred:"as",
        location: U.newLocation(fromPath.concat("ref"), U.WILO_FULL)
      }
    } else {
      fromName = {
        id:from.as,
        location: U.newLocation(fromPath.concat("as"), U.WILO_FULL)
      }
    }

    let where = augmentXPR(node.query.SELECT.where, selectPath.concat("where"))

    let orderBy = node.query.SELECT.orderBy;
    if(orderBy !== undefined) {
      let orderByPath = selectPath.concat("orderBy");
      orderBy = orderBy.map((X,iX) => {
        let sort;
        let nulls;
        if(X.sort) {
          sort = {
            val: X.sort,
            location: U.newLocation(orderByPath.concat(iX,"sort"), U.WILO_FULL)
          }
        }
        if(X.nulls) {
          nulls = {
            val: X.nulls,
            location: U.newLocation(orderByPath.concat(iX,"nulls"), U.WILO_FULL)
          }
        }
        let value;
        if(X.xpr) {
          value = augmentXPR(X.xpr, orderByPath.concat(iX,"xpr"));
        } else {
          value = {
            path:X.ref.map((Y,iY) => {
              return {
                id:Y,
                location: U.newLocation(orderByPath.concat(iX,"ref",iY), U.WILO_FULL)
              }
            }),
            location: U.newLocation(orderByPath.concat(iX), U.WILO_FULL)
          }
        }
        let r = {value};
        if(sort)
          r.sort = sort;
        if(nulls)
          r.nulls = nulls;
        return r;
      });
    }

    let limitOffset = node.query.SELECT.limit;
    let limit,offset;
    if(limitOffset !== undefined) {
      let limitPath = selectPath.concat("limit");
      if(limitOffset.rows)
        limit = {
          val: limitOffset.rows.val,
          literal:"number",
          location: U.newLocation(limitPath.concat("rows","val"), U.WILO_LAST)
        };
      if(limitOffset.offset)
        offset = {
          val: limitOffset.offset.val,
          literal:"number",
          location: U.newLocation(limitPath.concat("offset","val"), U.WILO_LAST)
        };
    }

    let R = {
      op: {val:"query", location},
      location,
      kind:"query",
      elements,
      from:[ {
        path:src,
        name: fromName,
        location: locationFrom
      }]
    }
    // set optional properties
    if(all)
      R.all=all;
    if(where)
      R.where=where;
    if(orderBy)
      R.orderBy=orderBy;
    if(limit)
      R.limit=limit;
    if(offset)
      R.offset=offset;
    node[name] = R;
  }

  function modifyAnnotation(node, key, path) {
    node[key] = newAnnotation(key, node[key], path);

    function newAnnotation(anAnno, aValue, path) {
      if (aValue instanceof Object && 'literal' in aValue)
        throw new Error('strange re-run')
      let name = {};
      U.setLocation(name, path.concat(anAnno), U.WILO_FIRST);
      let ret = {};
      if(aValue!==true && aValue!==undefined)
        ret = newValue(aValue, path.concat(anAnno));
      ret.name = name;
      return ret;
    }

  }

  function enumValue(/*node, name, path*/) {
  }

  return {
    newValue,
    ///////
    '@': modifyAnnotation,
    '$': ignore,
    $inferred: a => a && true,
    annotationAssignments: ignore, // TODO: make it $annotations
    artifacts: ignore,             // almost just $artifacts
    blocks: ignore,                // TODO: make it $blocks
    indexNo: ignore,               // TODO XSN: remove
    queries: ignore,               // TODO: make it $queries
    location: ignore,
    // future ------------------------------------------------------------------
    extensions: annotateExtensions,           // TODO: list non-applied
    quoted: ignore,               // really?  What about CURRENT_DATE vs "CURRENT_DATE"?
    // members -----------------------------------------------------------------
    actions: nonEmptyDict,
    elements: insertOrderDict,
    enum: insertOrderDict,
    keys: (node, name, path) => arrayAsDict(node, name, path, 'foreignKeys'),
    mixin: insertOrderDict,       // only in queries with special handling
    params: insertOrderDict,
    // different XSN later -----------------------------------------------------
    calculated: ignore,            // later in name: $inferred: 'as'
    implicitForeignKeys: ignore,   // later in assoc: $inferred: { foreignKeys: 'fk' } or $inferred on each fk
    origin: ignore,                // remove (introduce non-enum _origin link)
    projection: ignore,            // later in entity: $syntax: 'projection'
    source: ignore,                // remove
    viaAll: ignore,                // later in elem: $inferred: '*'
    // general properties of constructs ----------------------------------------
    abstract: modifyBoolean,
    localized: modifyBoolean,
    dbType: modifyValue,                // TODO: currently with --hana-flavor only
    default: modifyExpression,
    impl: ignore,               // obsolete - remove
    key: modifyBoolean,
    kind: modifyKind,
    name: ignore,
    virtual: modifyValue,
    notNull: modifyValue,
    masked: modifyValue,
    returns: standard,            // storing the return type of actions
    // type properties ---------------------------------------------------------
    cardinality,
    includes: modifyIncludes, // also entities
    length: modifyValue,
    on: modifyCondition,
    onCond : ignore,
    precision: modifyValue,
    redirected: ignore,           // TODO: no need for this
    scale: modifyValue,
    target: artifactRef,
    type: artifactRef,
    items: standard,
    // inner properties which should not occur anymore -------------------------
    path: ignore,
    sourceMax: ignore,
    targetMin: ignore,//modifyValue,
    targetMax: ignore,//modifyValue,
    targetElement: ignore,        // special display of foreign key
    // queries -----------------------------------------------------------------
    from: fromOld,
    all: ignore,                  // should not occur
    exclude: (excl, csn) => { csn.excluding = Object.keys(excl); }, // XSN TODO: exclude->excluding
    groupBy: a => a.map(modifyExpression),
    having: condition,
    limit: ignore,                // TODO XSN: include offset
    offset: ignore,             // TODO XSN: move into `limit`
    orderBy: ignore, // TODO XSN: make `sort` and `nulls` sibling properties
    query,
    value: enumValue,             // do not list for select items as elements
    where: condition,
    // special HANA CDS featues ------------------------------------------------
    sequenceOptions: ignore,    // TODO: currently not in the JSON by HANA
    // direct exports
    modifyNumber,
  }
}

module.exports = createInstance;
