'use strict';

const { cloneWithTransformations, setProp } = require('../base/model');
const deepCopy = require('../base/deepCopy');
const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { mergeOptions } = require('../model/modelUtils');
const alerts = require('../base/alerts');

// Returns the default 'skip' options for operating with TNT flavor
function getDefaultTntFlavorOptions() {
  // Please keep this in sync with what TNT actually uses
  return {
    skipGeneratedFKsWithout_: false,  // if true: Generate foreign key names with a '_' as separator
    skipValueListMagic: false,        // if true: Do not listen for @Common.ValueList.entity and generate NavProp
                                      //          and sap:value-list="fixed-values" @ Property/Parameter
    skipUsingFromIgnoring: false,                    // if true: Do not ignore the FROM of USING declarations, error for IDs after USING
    skipSloppyAnnoAssignments: false,                // if true: Do not allow sloppy annotation assignments syntax for context definitions - use @(...)
    skipServiceIncludes: false,                      // if true: Do not include contexts into services via "@extends" annotation
    skipPropagatingFromProjectionSrc: false,         // if true: Do not propagate properties from source to projection
    skipPropagatingFromInclude: false,               // if true: Do not propagate properties from (first) included artifact
    skipPropagatingActions: false,                   // if true: Do not propagate bound actions (and functions)
    skipPropagatingIncludes: false,                  // if true: Do not propagate the list of included artifacts
    skipNotPropagatingIndexableAnno: false,          // if true: Do not make an exception for the propagation of the '@Indexable' annotation

    // ----- annotation preprocessing -----
    skipAnnosTextArrangementReordering: false,       // if true: Do not automatically produce correct form for TextArrangementAnnotation
    // skipAnnosEnforceRecordType: false,               // if true: Let `--odata-omit-record-type` decide about unnecessary record type attributes
    skipAnnosTextAndValueListForAssocs: false,       // if true: Do not artificially generate '@Common.Text' and '@Common.ValueList' for associations
    skipAnnosRemoveManagedAssociationAnnos: false,   // if true: Do not remove annotations from managed associations
    skipAnnosSubstitutingFKeysForAssocs: false,      // if true: Do not replace paths to assocations by paths to their (single) foreign key in
                                                     //          selected annotations (currently '@UI.LineItem', '@UI.Identification',
                                                     //          '@UI.FieldGroup', '@UI.SelectionFields')
  };
}

// Perform TNT-specific extensions for augmented 'inputModel'. Each service S that has an '@extends: XXX'
// annotation gets a copy of all artifacts from context/service 'com.sap.gtt.core.CoreServices.XXX'.
// All associations and compositions in service S (whether copied into S or originally part of S) that
// pointed into 'XXX' are then re-targeted to S.
// Return an (augmented) copy of 'inputModel' with the transformation applied. Do not change the original inputModel.
// Throws a CompilationError on errors. Warnings are stored in the result model.
function transformTntExtensions(inputModel, options) {
  const { error, signal } = alerts(inputModel);
  // Deep-copy the original model
  let model = deepCopy(inputModel);
  model.messages = inputModel.messages;
  model.options = mergeOptions(model.options, options);
  // Do nothing except deep-copy if no TNT-flavor or if skipped
  if (!model.options.tntFlavor || model.options.tntFlavor.skipServiceIncludes) {
    return model;
  }
  // Find services that have an '@extends' annotation
  for (let name in model.definitions) {
    let artifact = model.definitions[name];
    if (artifact.kind == 'service' && artifact['@extends']) {
      let serviceName = name;
      let annotationValue = artifact['@extends'].path.map(step => step.id).join('.');
      // FIXME: The '@extends' annotation should at least contain the fully qualified name
      // of the context to be included - we assume here that it starts with 'com.sap.gtt.core.CoreServices.'
      let includedContextName = 'com.sap.gtt.core.CoreServices.' + annotationValue;
      // console.log('Extending service ' + name + ' with ' + includedContextName);
      // Find the context to be included
      let includedContext = model.definitions[includedContextName];
      if (includedContext == undefined) {
        signal(error`Cannot extend service "${serviceName}" with "${includedContextName}": not found`, artifact['@extends'].location);
        continue;
      }
      // Must be a context or a service
      if (includedContext.kind != 'context' && includedContext.kind != 'service') {
        signal(error`Cannot extend service "${serviceName}" with "${includedContextName}": "${includedContext.kind}" is neither context nor service`, artifact['@extends'].location);
        continue;
      }
      // Copy all artifacts contained within the included context/service (by means of their name prefix only!)
      for (let name in model.definitions) {
        if (name.startsWith(includedContextName + '.')) {
          let sourceName = name;
          let targetName = sourceName.replace(includedContextName, serviceName);
          // console.log('Copying artifact ' + sourceName + ' to ' + targetName);
          if (model.definitions[targetName]) {
            signal(error`Cannot extend service "${serviceName}" with "${includedContextName}": "${targetName}" already exists`, artifact['@extends'].location);
          }
          // We can only import one level of artifacts here (i.e. no containers)
          let localName = sourceName.substring(includedContextName.length + 1);
          if (localName.indexOf('.') != -1) {
            signal(error`Cannot extend service "${serviceName}" with artifact "${sourceName}": only entities/types are allowed, not contexts/services`, artifact['@extends'].location);
          }
          // Deep-copy the source artifact
          let sourceArtifact = model.definitions[sourceName];
          let targetArtifact = cloneWithTransformations(sourceArtifact, {});
          // FIXME: In order not to have to manually adapt all internal links for actions and their parameters,
          // we refrain from deep-copying them here and simply take them as they are - niemand hat die Absicht, sie zu veraendern anyway ...
          if (sourceArtifact.actions) {
            targetArtifact.actions = sourceArtifact.actions;
          }
          if (targetArtifact.elements != undefined) {
            for (let elementName in targetArtifact.elements) {
              let sourceElement = sourceArtifact.elements[elementName];
              let targetElement = targetArtifact.elements[elementName];
              // Restore _artifact in element type
              if (targetElement.type) {
                setProp(targetElement.type, '_artifact', sourceElement.type._artifact);
              }
              // Restore _artifact and _status in element origins
              // FIXME: Remove once the compactor no longer renders 'origin'
              if (targetElement.origin) {
                setProp(targetElement.origin, '_artifact', sourceElement.origin._artifact);
                setProp(targetElement.origin, '_status', sourceElement.origin._status);
              }
              if (targetElement.value) {
                setProp(targetElement.value, '_artifact', sourceElement.value._artifact);
              }
              setProp(targetElement, '_main', targetArtifact);
              // FIXME: Not entirely complete for nested stuff, but good enough for now...
              setProp(targetElement, '_parent', targetArtifact);
              if (sourceElement._finalType) {
                setProp(targetElement, '_finalType', sourceElement._finalType);
              }
            }
          }
          // Restore _artifact in artifact type
          if (targetArtifact.type) {
            setProp(targetArtifact.type, '_artifact', sourceArtifact.type._artifact);
          }
          // Restore _artifact in includes (if any)
          for (let i = 0; i < (targetArtifact.includes || []).length; i++) {
            setProp(targetArtifact.includes[i], '_artifact', sourceArtifact.includes[i]._artifact);
          }
          // Adapt the target artifact's name (artificial, i.e. no path)
          targetArtifact.name = {
            absolute: targetName,
            id: sourceArtifact.name.id,
          }
          model.definitions[targetName] = targetArtifact;
          // Adapt target artifact's parent/child relation
          artifact.artifacts[localName] = targetArtifact;
          setProp(targetArtifact, '_parent', artifact);
          if (sourceArtifact.source != targetArtifact.source) {
            targetArtifact.source = sourceArtifact.source;
          }
        }
      }
      // Adapt all association targets within the service that has included the context (by means of their name prefix only!)
      for (let name in model.definitions) {
        if (name.startsWith(serviceName + '.')) {
          let artifact = model.definitions[name];
          // If the artifact has association elements, adapt their targets and foreign keys
          for (let elementName in artifact.elements || {}) {
            let element = artifact.elements[elementName];
            if (element.target != undefined) {
              element.target.absolute = element.target.absolute.replace(includedContextName, serviceName);
              setProp(element.target, '_artifact', model.definitions[element.target.absolute]);
              if (element.foreignKeys != undefined) {
                for (let foreignKeyName in element.foreignKeys) {
                  let foreignKey = element.foreignKeys[foreignKeyName];
                  foreignKey.name.absolute = element.name.absolute;
                  setProp(foreignKey.targetElement, '_artifact', element.target._artifact.elements[foreignKey.name.id]);
                }
              }
            }
          }
        }
      }
    }
  }
  // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError(sortMessages(model.messages), model);
  }
  return model;
}

module.exports = {
  getDefaultTntFlavorOptions,
  transformTntExtensions,
}
