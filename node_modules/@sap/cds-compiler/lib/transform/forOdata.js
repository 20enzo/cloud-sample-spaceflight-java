'use strict';

const { forEachDefinition, forEachMemberRecursively, setProp } = require('../base/model');
const { compactSorted, compact } = require('../json/compactor');
const deepCopy = require('../base/deepCopy');
const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { isManagedAssociationElement, isStructuredElement, isAssociation, isElementWithType,
        renameAnnotation, copyAnnotations, foreachPath, hasBoolAnnotation, } = require('../model/modelUtils');
const transformUtils = require('./transformUtils');
const { mergeOptions } = require('../model/modelUtils');
const alerts = require('../base/alerts');

// New version of transform4odata. Expects an augmented 'inputModel', processes it for ODATA.
// The result should be suitable for consumption by EDMX processors (annotations and metadata)
// and also as a final CSN output for the ODATA runtime (when compacted).
// Performs the following transformations:
// - Flatten structured elements (and foreign keys of managed associations pointing to
//   keys that are themselves managed associations).
// - Generate foreign key fields for entities with managed associations (annotated with
//   '@odata.foreignKey4'). Propagate along projections accordingly. Names are built using
//   <assoc>_<key>, conflicts are checked. 
// - Complete the 'foreignKeys' property for all managed associations, so that there
//   is always a 'generatedFieldName' for the corresponding generated foreign key field.
// - Implicitly redirect associations based on exposure
// - Check that exposed associations do not point to non-exposed targets
// - Add an attribute '_service' to all artifacts that are exposed in a service (pointing to
//   the service artifact). This should be used by EDMX processors to detect exposed artifacts.
// - Unravel derived type chains, propagating annotations upwards.
// - Rename annotations according to a fixed list of short-hands
// Returns an (augmented) copy of 'inputModel' with the transformation applied. Does not change the original inputModel.
// Throws a CompilationError on errors. Warnings are stored in the result model.
function transform4odata(inputModel, options) {
  const { error, warning, signal } = alerts(inputModel);
  let model = deepCopy(inputModel);
  model.messages = inputModel.messages;
  options = mergeOptions(inputModel.options, options);
  model.options = options;
  const { flattenForeignKeys, createForeignKeyElement, checkForeignKeys,
          flattenStructuredElement, flattenStructStepsInPath, preprocessAction,
          setServiceProperty, checkExposedAssoc, toFinalBaseType, addImplicitRedirections,
          isBacklinkAssociation, } = transformUtils.getTransformers(model, '_');
  // First walk through the model: perform preparations only
  // Set '_service' property for all artifacts and sub-artifacts, for each service in the model
  setServiceProperty(model);

  // Second walk through the model: Do the main part of the work
  forEachDefinition(model, (artifact) => {
    // For entities and views only: Flatten structs (might result in new elements)
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        if (isStructuredElement(elem)) {
          // Remove the structured element, replace it by its flattened form
          delete artifact.elements[elemName];
          let flatElems = flattenStructuredElement(elem);
          for (let flatElemName in flatElems) {
            if (artifact.elements[flatElemName]) {
              signal(error`"${artifact.name.absolute}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`, elem.location);
            }
            artifact.elements[flatElemName] = flatElems[flatElemName];
             // FIXME: Should also adapt indexNo of the newly added elements and all subsequent ones
          }
        }
        if (!isElementWithType(elem)) {
          signal(error`Element "${artifact.name.absolute}.${elemName}" does not have a type: Elements of ODATA entities must have a type`, elem.location);
        }
      }
    }
    // Types must not have anonymous structured elements
    else if (artifact.kind == 'type') {
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        if (elem.elements) {
          signal(error`Element "${artifact.name.absolute}.${elemName}" has an anonymous structured type: this is not (yet) supported for ODATA`, artifact.location);
        }
      }
    }
    forEachMemberRecursively(artifact, (member) => {
      // Unravel derived type chains for elements, actions, action parameters (propagating annotations)
      toFinalBaseType(member);
      toFinalBaseType(member.items);
      toFinalBaseType(member.returns);
      // Resolve annotation shorthands for elements, actions, action parameters
      renameShorthandAnnotations(member);
      // check annotations
      checkAnnotations(member);
      // Generate foreign key elements for managed associations
      if (isManagedAssociationElement(member)) {
        // Flatten foreign keys (replacing foreign keys that are managed associations be their respective foreign keys)
        member.foreignKeys = flattenForeignKeys(member.foreignKeys);
        // Generate foreign key elements
        for (let name in member.foreignKeys) {
          let foreignKeyElement = createForeignKeyElement(member, member.foreignKeys[name]);
          toFinalBaseType(foreignKeyElement);
          // Propagate the association's annotations to the foreign key element
          // (Overwriting because they should win over the derived type unraveling)
          copyAnnotations(member, foreignKeyElement, true);
        }
      }
      // Entities only: Flatten structs used in paths
      if (artifact.kind == 'entity') {
        foreachPath(member, (path, pathOwner) => {
          pathOwner.path = flattenStructStepsInPath(path);
        });
      }
    });
    // Unravel derived type chains for types and annotations (propagating annotations)
    if (artifact.kind != 'entity') {
      toFinalBaseType(artifact);
      toFinalBaseType(artifact.items);
    }
    // If the artifact is a derived structured type, unravel that as well
    if (artifact.kind == 'type' && artifact.type && artifact.type._artifact.elements) {
      // Take the final type's elements
      // FIXME: Actually, we should deep-copy here and adapt _parent, _main, name , ...
      artifact.elements = artifact.type._artifact.elements;
      // The artifact's type is now 'cds.struct', which is not shown
      delete artifact.type;
    }
    // Resolve annotation shorthands for entities, types, annotations, ...
    renameShorthandAnnotations(artifact);
    // check annotations
    checkAnnotations(artifact);
  });

  // Perform implicit redirection of non-exposed association targets
  addImplicitRedirections(model);

  // Third walk through the model: Now all artificially generated things are in place
  forEachDefinition(model, artifact => {
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        // Check for valid foreign keys
        if (isAssociation(elem.type)) {
          checkForeignKeys(elem);
        }

        // Take care of associations to "contained" sub-entities (this is the header/container,
        // assoc points to the containee/item)
        if (hasBoolAnnotation(elem, '@odata.contained')) {
          // Must be a backlink association, otherwise @odata.contained is not allowed
          if (!isBacklinkAssociation(elem, artifact)) {
            signal(error`${artifact.name.absolute}.${elemName}: Only backlink associations can be annotated with "@odata.contained"`, elem.location);
          }
          else {
            // Retrieve the contained artifact (the item entity where the corresponding forward association is)
            let containedArtifact = elem.target._artifact;
            // Sanity check
            if (!containedArtifact) {
              throw new Error('Expected target artifact of @odata.contained assoc to be resolved: ' + JSON.stringify(elem));
            }
            if (containedArtifact.params) {
              signal(error`${artifact.name.absolute}.${elemName}: Target entity "${containedArtifact.name.absolute}" has parameters, so it cannot be contained in another entity`, elem.location);
            }
            // An entity must only be contained in one container
            else if (containedArtifact._containerEntity) {
              signal(error`${artifact.name.absolute}.${elemName}: Target entity "${containedArtifact.name.absolute}" is already contained in "${containedArtifact._containerEntity}"`, elem.location);
            }
            else {
              // Let the contained artifact (item) know its container (header)
              containedArtifact._containerEntity = artifact.name.absolute;
              // Retrieve the forward association pointing to the container (i.e. to this entity)
              for (let containedElemName in containedArtifact.elements) {
                let containedElem = containedArtifact.elements[containedElemName];
                if (isAssociation(containedElem.type) && !isBacklinkAssociation(containedElem, containedArtifact)) {
                  // Sanity check
                  if (!containedElem.target || !containedElem.target._artifact) {
                    throw new Error('Expected target artifact of assoc in container to be resolved: ' + JSON.stringify(containedElem));
                  }
                  // If this is the corresponding forward association, let it know that it points to the container
                  if (containedElem.target._artifact.name.absolute == artifact.name.absolute) {
                    containedElem._isToContainer = true;
                    // If this is really a header/item relationship (i.e. two different entities involved), the forward
                    // association must be NOT NULL
                    if (containedArtifact.name.absolute != artifact.name.absolute) {
                      if (!containedElem.notNull) {
                        signal(error`"${containedArtifact.name.absolute}.${containedElemName}: Association to container entity must have "NOT NULL"`, containedElem.location);
                      }
                    }
                    // Otherwise (recursive hierarchy relationship, only one entity involved), it must not be NOT NULL
                    else {
                      if (containedElem.notNull) {
                        signal(error`"${containedArtifact.name.absolute}.${containedElemName}: Association to container entity in a recursive hierarchy must not have "NOT NULL"`, containedElem.location);
                      }
                    }
                  }
                }
              }
            }
          }
        }

        // Remove '$projection' from paths in the element's ON-condition
        // FIXME: Hack - should actually be done by the compiler, and should only
        // affect the element itself, not the various other places sharing the same
        // ON-condition object, e.g. the MIXIN and the query (there, the ON-condition
        // should actually retain its '$projection').
        foreachPath(elem.onCond || {}, (path, node) => {
          if (path[0].id == '$projection') {
            node.path = node.path.slice(1);
          }
        });
      }
    }
    forEachMemberRecursively(artifact, member => {
      // Check that exposed associations do not point to non-exposed targets
      if (artifact._service && isAssociation(member.type)) {
        checkExposedAssoc(artifact, member);
      }
    });

    // Preprocess bound actions/functions
    if (artifact.kind === 'entity' && artifact.actions && artifact._service) {
      Object.keys(artifact.actions).forEach(actName => preprocessAction(artifact.actions[actName]));
    }

    // Preprocess unbound actions/function
    if ((artifact.kind === 'action' || artifact.kind === 'function') && artifact._service) {
      preprocessAction(artifact);
    }
  });

  // Fourth walk through the model: Check media type and key-ness (requires that containers have been identified in pass 3) 
  var illV2Prefix = RegExp('^(_|[0-9])');
  forEachDefinition(model, artifact => {
    // Perform checks for exposed non-abstract entities and views
    if (artifact._service && !artifact.abstract && (artifact.kind == 'entity' || artifact.kind == 'view')) {
      let keyCount = 0;
      let mediaTypes = [];
      // Walk the elements
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];

        // For ODATA V2, element names must not start with digit or '_'
        if (options.toOdata.version == 'v2') {
          if (illV2Prefix.test(elemName)) {
            signal(error`"${artifact.name.absolute}.${elemName}: Element name must not begin with '${elemName[0]}' for OData V2`, elem.location);
          }
        }

        // Count keys and elements annotated with @Core.MediaType
        if (elem.key != undefined) {
          keyCount++;
        }
        if (elem['@Core.MediaType']) {
          mediaTypes.push([elemName, elem]);
        }
      }

      // Exposed non-abstract entities in non-contained artifacts must have a key
      if (keyCount == 0 && !artifact._containerEntity) {
        signal(error`Entity "${artifact.name.absolute}" does not have a key: ODATA entities must have a key`, artifact.location);
      }

      // Additional checks for ODATA V2 regarding remaining keys
      if (options.toOdata.version == 'v2') {
        // Elements that are annotated with @Core.HasStream are removed from the entity type.
        // If these are all keys then this would end up with a key-less EntityType wich is illegal in V2
        let mtkeys = mediaTypes.filter(e=>e[1].key);
        if (mtkeys.length > 0 && keyCount == mtkeys.length) {
          signal(error`"${artifact.name.absolute}: Key elements [${mtkeys.map(e=>e[0]).join(', ')}] annotated with '@Core.MediaType' are removed from Odata V2 resulting in keyless EntityType`, artifact.location);
        }
        // Today only one MediaType is allowed in V2
        if (mediaTypes.length > 1) {
          signal(error`"${artifact.name.absolute}: Elements [${mediaTypes.map(e=>e[0]).join(', ')}] annotated with '@Core.MediaType', OData V2 allows only one`, artifact.location);
        }
      }

      // Check media type compatibility for all OData versions
      let allowedTypes = ['cds.String', 'cds.Binary', 'cds.LargeBinary'];
      mediaTypes.forEach(e => {
        if (!allowedTypes.includes(e[1]._finalType.type._artifact.name.absolute)) {
          signal(error`"${artifact.name.absolute}.${e[0]}": Element annoted with '@Core.MediaType' must be of either type "${allowedTypes.join(', ')}"`, e[1].location);
        }
      });
    }
  });

  // Throw up if we have errors
  if (hasErrors(model.messages)) {
    throw new CompilationError(sortMessages(model.messages), model);
  }
  return model;

  // Apply checks to all annotations in the model
  // node: artifact/element/action/function/parameter/... that carries the annotations
  function checkAnnotations(node) {
    // currently there is only one check: annotations @sap:... must have a string or boolean value
    //   or no value (as shorcut for boolean value true)
    let annoNames = Object.keys(node).filter(x => x.startsWith('@sap.'));
    for (let name of annoNames) {
      if (node[name].path ||
          !(node[name].literal == undefined || node[name].literal == 'boolean' || node[name].literal == 'string')) {
        signal(warning`Annotation "${name}" must have a string or boolean value`, node[name].location);
      }
    }
  }
}

// Rename shorthand annotations within artifact or element 'node' according to a builtin
// list.
function renameShorthandAnnotations(node) {
  // FIXME: Verify this list - are they all still required? Do we need any more?
  const mappings = {
    '@label': '@Common.Label',
    '@title': '@Common.Label',
    '@ValueList.entity': '@Common.ValueList.entity',
    '@ValueList.type': '@Common.ValueList.type',
    '@Capabilities.Deletable': '@Capabilities.DeleteRestrictions.Deletable',
    '@Capabilities.Insertable': '@Capabilities.InsertRestrictions.Insertable',
    '@Capabilities.Updatable': '@Capabilities.UpdateRestrictions.Updatable',
    '@readonly': '@Core.Immutable',
  }

  for (let name in node) {
    // Rename according to map above
    if (mappings[name] != undefined) {
      renameAnnotation(node, name, mappings[name]);
    }

    // Special case: '@important: [true|false]' becomes '@UI.Importance: [#High|#Low]'
    if (name == '@important') {
      renameAnnotation(node, name, '@UI.Importance');
      let annotation = node['@UI.Importance'];
      annotation.literal = 'enum';
      annotation.symbol = {
        // Note that an original '@important' without ': true' shows up as undefined value here!!
        id: (annotation.val == undefined || annotation.val == true) ? 'High' : 'Low',
      };
      // FIXME: Strangely, enum-valued annotations have no value
      delete annotation.val;
    }
  }
}

// Return an array of service names contained in (augmented or compacted) 'model''
function getServiceNames(model) {
  let resultDict = Object.create(null);
  forEachDefinition(model, (artifact, artifactName) => {
    if (artifact.kind == 'service') {
      resultDict[artifactName] = artifact;
    }
  });
  return Object.keys(resultDict);
}

// Post-process an augmented CSN model 'model' that has been produced by 'transform4odata' so that it
// looks like the original (compacted) output of the '4odata' transformation'.
// If 'serviceName' is provided, only artifacts from this service are considered for the output.
// Most of this should not be necessary once we adapt the EDMX generation to use augmented CSN.
// Currently this involves the following steps:
// - Convert to compact CSN
//   => EDMX processors should actually use augmented CSN
// - Keep only exposed artifacts
//   => EDMX processors should instead look only at those artifacts in augmented CSN that have '_service'
// - Filter out everything but the one service selected
//   => EDMX processors should handle this based on '_service', too
// Return a (compacted) copy of 'model' with the transformation applied. Do not change the original model.
function postProcessForBackwardCompatibility(model, serviceName=undefined) {
  // Compact the model
  let compactedModel = (model.options.testMode) ? compactSorted(model) : compact(model);
  setProp(compactedModel, 'messages', model.messages);

  // Iterate artifact definitions on the augmented model, but modify the compacted one in parallel
  forEachDefinition(model, (artifact, artifactName) => {
    // Remove artifacts that are not exposed
    if (!artifact._service) {
      delete compactedModel.definitions[artifactName];
      return;
    }
    // Ignore if not part of specified service (if any)
    if (serviceName != undefined && serviceName != artifact._service.name.absolute) {
      delete compactedModel.definitions[artifactName];
      return;
    }
  });
  return compactedModel;
}

module.exports = {
  transform4odata,
  getServiceNames,
  postProcessForBackwardCompatibility,
}
