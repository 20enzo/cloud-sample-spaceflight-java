//

'use strict';

const { forEachDefinition, forEachMember, applyLinearly, setProp }
      = require( '../base/model');
var { setMemberParent, linkToOrigin } = require('./shared');
// const { refString } = require( '../base/messages')

function propagateLinearly( ...args ) {
  return applyLinearly( 'propagated', ...args );
}

// the export function
function propagateAssignments( model, options = model.options || {} ) {
  const typeProperties = {
    type: null, // propagateType,
    length: null,
    precision: null,
    scale: null,
    items: propagateTypeProperties,
    target: 0,
    implicitForeignKeys: null,
    source: null,
    // default: null,    // see propagateSingle()
    // notNull: null,    // see propagateSingle()
    cardinality: null,
    foreignKeys: propagateDictionary,
    on: null, onCond: 0,     // combine, copy when resolve in ON
    elements: propagateDictionary,
    enum: propagateDictionary,
    localized: null,
    virtual: null,
  };

  forEachDefinition( model, function( def ) {
    // TODO: make exportAnnotations inspect the _finalType instead:
    if (options.toI18n && options.toI18n.style == 'prop') {
      propagateLinearly( def, o => o.type, propagateTypeProperties );
      return;
    }
    if (options.tntFlavor) {
      if (!options.tntFlavor.skipPropagatingFromInclude)
        propagateLinearly( def, includesSource, propagateSingle );
      if (!options.tntFlavor.skipPropagatingFromProjectionSrc)
        propagateLinearly( def, p => p.source, propagateSingle );
    }
    propagateInMembers( def );
  });
  return model;

  function propagateInMembers( def ) {
    forEachMember( def, function( elem ) {
      propagateLinearly( elem, o => o.origin, propagateSingle );
      propagateInMembers( elem );
    });
  }

  // Propagation function.  Used to inherit along properties `origin` (used for
  // members only), and with --tnt-flavor: `source` and `includes[0]`.  The
  // properties are the type properties and annotation assignments.
  function propagateSingle( target, source ) {
    if (target.kind === 'key')
      return;
    propagateTypeProperties( target, source );
    if (target.origin && source === target.origin._artifact) { // along `origin`
      // inherit `default` only along structure includes
      if ('default' in source && !('default' in target)) { //&&
        //  !target.value) {      // from structure includes
        target.default = source.default;
      }
      // inherit `notNull` along select items without association or structure includes
      if ('notNull' in source && !('notNull' in target) &&
          (!target.value || withoutAssociation( target.value.path )) ) {
        target.notNull = source.notNull;
      }
    }

    if (source.params) {
      target.params = propagateDictionary( target.params, source.params, target );
    }
    if (source.returns)
      target.returns = propagateTypeProperties( null, source.returns, target );

    if (options.tntFlavor) {
      if (!options.tntFlavor.skipPropagatingActions)
        propagateActions( target, source );
      // FIXME: very questionable if we really want that
      if (source.includes && !options.tntFlavor.skipPropagatingIncludes) {
        target.includes = source.includes;
      }
    }
    for (let prop in source) {
      if (prop.charAt(0) !== '@' ||
          prop in target ||
          options.tntFlavor && !options.tntFlavor.skipNotPropagatingIndexableAnno && prop === '@com.sap.gtt.core.CoreModel.Indexable')
        continue;
      // TODO: if we decide that annotations have a link to the attached
      // construct, we need to shallow-copy and set this link here, too
      target[prop] = source[prop];
      // FIXME: the following makes toI18n fail!  Why?
      // target[prop] = Object.assign( { $inferred: 'prop' }, source[prop] );
    }
  }

  function withoutAssociation( path ) {
    for (let item of path || []) {
      if (item._artifact && item._artifact._finalType && item._artifact._finalType.target)
        return false;
    }
    return true;
  }

  //function propagateType( target, source )
  function propagateTypeProperties( target, source, parent ) {
    if (!target) {
      target = Object.assign( {}, source );
      // Object.defineProperty( target, '_finalType', { value: source._finalType } );
    }
    if (target.kind === 'key' && // TODO: this should move below !!!!!!!
        ( source.target || source.type && source.type._artifact && !source.type._artifact.builtin ))
      return target;            // do not propagate for foreign keys which are assocs - TODO
    let value = (target.redirected) ? target : (source._finalType || source);
    // Propagated `elements`, `foreignKeys` etc should have a _finalType:
    if (!target._finalType)
      setProp( target, '_finalType', value );

    // TODO: adapt foreign keys with redirect and on condition in general
    if (!parent && !target.redirected) {
      for (let prop in typeProperties) {
        if (prop in target && typeProperties[prop] !== 0) {
          setProp( target, '_finalType', target );
          return target;
        }
      }
    }
    for (let prop in typeProperties) {
      // if (prop === 'foreignKeys') console.log ('FK', source.kind, source.name)
      if (prop in source && !(prop in target)) {
        let transfer = typeProperties[prop];
        target[prop] = (transfer)
          ? transfer( null, source[prop], parent || target )
          : source[prop];
      }
    }
    return target;
  }

  function propagateDictionary( target, source, parent ) {
    if (!target)
      target = Object.create(null);
    for (let name in source) {
      if (name in target)
        continue;
      let src  = source[name];
      let elem = target[name] = Object.assign( {}, src );
      elem.name = Object.assign( {}, src.name );
      // console.log(elem.kind,elem.name)
      setMemberParent( elem, name, parent );
      if (src.returns)          // TODO: what about items?
        elem.returns = propagateTypeProperties( null, src.returns, elem );
      else
        propagateTypeProperties( elem, src, elem );
      if (src.params)          // for actions
        elem.params = propagateDictionary( null, src.params, elem );
    }
    return target;
  }

  function propagateActions( target, source ) {
    if (source.actions) {
      target.actions = propagateDictionary( target.actions, source.actions, target );
    }
  }

  // If we have more than one include later, we need something like applyInOrder
  function includesSource( def ) {
    return def.includes && def.includes.length >= 1 && def.includes[0];
  }
}

function propagate( model ) {
  const props = {
    '@com.sap.gtt.core.CoreModel.Indexable': never,
    '@cds.persistence.exists': never,
    '@cds.persistence.table': never,
    '@': always,
    default: always,
    virtual: notViaType,
    notNull,                    // a variant of notViaType()
    targetElement: onlyViaParent,
    value: onlyViaParent,      // enum symbol value
    // masked: special = done in definer
    // key: special = done in resolver
    // actions: struct includes & primary source - TODO: do in definer/resolver
    // params/returns
    type: always,
    length: always,
    precision: always,
    scale: always,
    localized: always,
    target: always,
    cardinality: always,
    onCond: always,             // is expensive, but often rewritten - TODO: on
    on: ( prop, target, source ) => { target[prop] = source[prop]; }, // TODO: get rid of this soon!
    foreignKeys: expensive,
    items: always,              // TODO: do not if there are expensive props in target items
    elements: expensive,
    enum: expensive,
  };

  forEachDefinition( model, run );
  return model;

  function run( art ) {
    if (!art)
      return;
    if (!checkAndSetStatus( art )) {
      // console.log('DONE:',refString(art), art.elements ? Object.keys(art.elements) : 0)
      forEachMember( art, run );
      return;
    }
    // console.log('RUN:',refString(art), art.elements ? Object.keys(art.elements) : 0)
    let chain = [];
    let target = art;
    let source = getOrigin( target );
    while (source && checkAndSetStatus( source )) {
      chain.push({ target, source });
      target = source;
      source = getOrigin( target );
    }
    if (source) {                 // the source has fully propagated properties
      step({ target, source });
    }
    else if (target.includes) {
      let news = [ target ];
      while (news.length) {
        let structs = [].concat( ...news );
        news = [];
        for (target of structs) {
          let incl = target.includes;
          if (incl) {
            chain.push( ...incl.map( i => ({ target, source: i._artifact }) ) );
            news.push( incl.map( i => i._artifact ).filter( checkAndSetStatus ) );
          }
        }
      }
    }
    chain.reverse().forEach( step );
    forEachMember( art, run ); // after propagation in parent!
  }

  function step({ target, source }) {
    // console.log('PROPS:',source&&refString(source),'->',refString(target))
    let viaType = target.type && !target.type.$inferred;
    let keys = Object.keys( source );
    for (let prop of keys) {
      if (prop in target)       // TODO: warning with competing props from multi-includes
        continue;
      let transformer = props[prop] || props[prop.charAt(0)];
      if (transformer)
        transformer( prop, target, source, viaType );
    }
  }

  function never () {}

  function always( prop, target, source ) {
    target[prop] = Object.assign( { $inferred: 'prop' }, source[prop] );
    if ('_artifact' in source[prop])
      setProp( target[prop], '_artifact', source[prop]._artifact );
    if ('_artifact' in source[prop])
      setProp( target[prop], '_artifact', source[prop]._artifact );
  }

  // Expensive properties are not really propagated if they can be directly
  // accessed at their _finalType being a main artifact
  // (TODO: improve for type T: OtherStruct.elem; )
  // This should be adapted if elements of referred types can be annotated
  // (i.e. check whether there are annotations on it)
  function expensive( prop, target, source ) {
    if (target._finalType && !target._finalType._main)
      return;
    let location = target.type && !target.type.$inferred && target.type.location
                || target.location;
    let dict = source[prop];
    for (let name in dict) {
      let member = linkToOrigin( dict[name], name, target, prop, location );
      member.$inferred = 'proxy';
      if ('_finalType' in dict[name])
        setProp( member, '_finalType', dict[name]._finalType);
    }
  }

  function notViaType( prop, target, source, viaType ) {
    if (!viaType)
      always( prop, target, source );
  }

  function onlyViaParent( prop, target, source ) {
    if (target.$inferred === 'proxy')
      always( prop, target, source );
  }

  function notNull( prop, target, source, viaType ) {
    // TODO: also if we access sub element - set in definer/resolver
    // TODO: check whether this is correct
    if (!viaType && (!target.value ||
                     target.value && withoutAssociation( target.value.path ) && !nullAssocInPath(target.value.path)
                    )
       )
      always( prop, target, source );

    // return true if path contains an association with target-min cardinality 0
    // TODO: check whether this is correct
    function nullAssocInPath(path) {
      for (let item of path || []) {
        let art = item._artifact;
        if (art && art._finalType && art._finalType.target &&
            !(art.cardinality && art.cardinality.targetMin && art.cardinality.targetMin.val>0))
          return true;
      }
      return false;
    }
  }
}

function withoutAssociation( path ) {
  for (let item of path || []) {
    // CHECK: why leave loop on first assoc?
    if (item._artifact && item._artifact._finalType && item._artifact._finalType.target)
      return item !== path[ path.length-1 ]; // ok on last
  }
  return true;
}

function getOrigin( art ) {
  if (art.$from && art.$from.length) { // query
    let tabref = art.$from[0]._artifact;
    return (tabref && tabref.kind === 'element')
      ? tabref._finalType && tabref._finalType.target
      : tabref;
  }
  else {
    return (art.type && !art.type.$inferred)
      ? art.type._artifact
      : art.origin && art.origin._artifact;
  }
}

function checkAndSetStatus( art ) {
  if (art._status === 'propagated')
    return false;
  setProp( art, '_status', 'propagated' );
  return true;
}

module.exports = {
  propagate,
  propagateAssignments
};
