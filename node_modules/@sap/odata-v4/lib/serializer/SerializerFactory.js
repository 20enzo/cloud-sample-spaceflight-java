'use strict';

const moduleCache = require('../ModuleCache');
const ResourceJsonSerializer = moduleCache.lookup('ResourceJsonSerializer');
const EdmPrimitiveTypeKind = require('../edm/EdmPrimitiveTypeKind');
const JsonContentTypeInfo = require('../format/JsonContentTypeInfo');
const ContentTypes = JsonContentTypeInfo.ContentTypes;
const ValueConverter = require('../utils/ValueConverter');
const ValueValidator = require('../validator/ValueValidator');
const SerializationError = require('../errors/SerializationError');
const ExpandHelper = require('../uri/ExpandHelper');
const QueryOptions = require('../uri/UriInfo').QueryOptions;
const HeaderNames = require('../http/HttpHeader').HeaderNames;
const JsonAnnotations = require('../format/JsonFormat').Annotations;

/**
 * Function interface for serializer functions
 *
 * @callback SerializerFunction
 * @param {Context} odata context
 * @param {Object} data
 * @param {Object} options
 * @param {Function} next
 */

class SerializerFactory {

    /**
     * Check JSON format parameters.
     * @param {Array.<{name:string,value:string}>} parameters
     * @returns {boolean} whether the parameters are supported
     */
    static checkJsonParameters(parameters) {
        for (const parameter of parameters) {
            const name = parameter.name.toLowerCase();
            const value = parameter.value.toLowerCase();
            switch (name) {
                case JsonContentTypeInfo.FormatParameter.ODATA_METADATA:
                    if (value !== JsonContentTypeInfo.FormatParameterMetadataValues.MINIMAL) return false;
                    break;
                case JsonContentTypeInfo.FormatParameter.STREAMING:
                    if (value !== 'false') return false;
                    break;
                case JsonContentTypeInfo.FormatParameter.IEEE754.toLowerCase():
                    if (value !== 'false' && value !== 'true') return false;
                    break;
                case JsonContentTypeInfo.FormatParameter.EXPONENTIAL_DECIMALS.toLowerCase():
                    if (value !== 'false' && value !== 'true') return false;
                    break;
                case JsonContentTypeInfo.FormatParameter.CHARSET.toLowerCase():
                    if (!value) return false;
                    break;
                default:
                    return false;
            }
        }
        return true;
    }

    /**
     * Serializes entity-collection resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceEntityCollection(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceEntityCollection()...');

        const request = context.getRequest();
        const uriInfo = request.getUriInfo();
        const entitySet = uriInfo.getLastSegment().getEntitySet() || uriInfo.getLastSegment().getTarget();
        const entityType = uriInfo.getFinalEdmType();
        // A transient type (recognized through its method getOptionalProperty) has no entity set.
        const entityTypeOrSet = entityType.getOptionalProperty ? entityType : entitySet || entityType;

        const serializer = new ResourceJsonSerializer(
            new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));

        const content = serializer.serializeEntityCollection(entityTypeOrSet, data,
            uriInfo.getQueryOption(QueryOptions.SELECT), ExpandHelper.getFinalExpand(request),
            !!request.getConcurrentResource() && !uriInfo.getLastSegment().getAction());

        next(null, content);
    }

    /**
     * Serializes entity resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceEntity(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceEntity()...');

        let content;
        if (data.value != null) {
            const request = context.getRequest();
            const uriInfo = request.getUriInfo();
            const entitySet = uriInfo.getLastSegment().getEntitySet() || uriInfo.getLastSegment().getTarget();
            const entityType = uriInfo.getFinalEdmType();
            // A transient type (recognized through its method getOptionalProperty) has no entity set.
            const entityTypeOrSet = entityType.getOptionalProperty ? entityType : entitySet || entityType;

            const serializer = new ResourceJsonSerializer(
                new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
            content = serializer.serializeEntity(entityTypeOrSet, data,
                uriInfo.getQueryOption(QueryOptions.SELECT), ExpandHelper.getFinalExpand(request),
                !!request.getConcurrentResource() && !uriInfo.getLastSegment().getAction());
        }
        next(null, content);
    }

    /**
     * Serializes primitive resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourcePrimitive(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourcePrimitive()...');

        let content;
        if (data.value != null) {
            const request = context.getRequest();
            const uriInfo = request.getUriInfo();
            const type = uriInfo.getFinalEdmType();
            const serializer = new ResourceJsonSerializer(
                new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
            content = serializer.serializePrimitive(type, data,
                !!request.getConcurrentResource() && !uriInfo.getLastSegment().getAction());
        }
        next(null, content);
    }

    /**
     * Serializes primitive-collection resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourcePrimitiveCollection(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourcePrimitiveCollection()...');

        const request = context.getRequest();
        const uriInfo = request.getUriInfo();
        const type = uriInfo.getFinalEdmType();
        const serializer = new ResourceJsonSerializer(
            new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
        next(null, serializer.serializePrimitiveCollection(type, data,
            !!request.getConcurrentResource() && !uriInfo.getLastSegment().getAction()));
    }

    /**
     * Serializes complex resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceComplex(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceComplex()...');

        let content;
        if (data.value !== null && data.value !== undefined) {
            const request = context.getRequest();
            const uriInfo = request.getUriInfo();
            const type = uriInfo.getFinalEdmType();
            const serializer = new ResourceJsonSerializer(
                new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
            content = serializer.serializeComplex(type, data,
                uriInfo.getQueryOption(QueryOptions.SELECT), ExpandHelper.getFinalExpand(request),
                !!request.getConcurrentResource() && !uriInfo.getLastSegment().getAction());
        }
        next(null, content);
    }

    /**
     * Serializes complex-collection resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceComplexCollection(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceComplexCollection()...');

        const request = context.getRequest();
        const uriInfo = request.getUriInfo();
        const type = uriInfo.getFinalEdmType();
        const serializer = new ResourceJsonSerializer(
            new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
        next(null, serializer.serializeComplexCollection(type, data,
            uriInfo.getQueryOption(QueryOptions.SELECT), ExpandHelper.getFinalExpand(request),
            !!request.getConcurrentResource() && !uriInfo.getLastSegment().getAction()));
    }

    /**
     * Serializes reference-collection resources.
     * @param {Context} context odata context
     * @param {Object[]} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceReferenceCollection(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceReferenceCollection()...');

        const pathSegments = context.getRequest().getUriInfo().getPathSegments();
        const serializer = new ResourceJsonSerializer(
            new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
        next(null, serializer.serializeReferenceCollection(pathSegments, data));
    }

    /**
     * Serializes reference resources.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static resourceReference(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.resourceReference()...');

        let content;
        if (data && data.value) {
            const pathSegments = context.getRequest().getUriInfo().getPathSegments();
            const serializer = new ResourceJsonSerializer(
                new JsonContentTypeInfo(context.getResponse().getContract().getContentTypeInfo()));
            content = serializer.serializeReference(pathSegments, data);
        }
        next(null, content);
    }

    /**
     * Serializes primitive-property raw values.
     * @param {Context} context odata context
     * @param {Object} data the data
     * @param {Object} options options
     * @param {Function} next callback function
     */
    static value(context, data, options, next) {
        context.getLogger().path('Entering SerializerFactory.value()...');

        const response = context.getResponse();
        const uriInfo = context.getRequest().getUriInfo();
        const type = uriInfo.getFinalEdmType();
        const property = uriInfo.getLastSegment(-1).getProperty();
        let value = data.value;

        if (value == null) {
            const nullable = property ? property.isNullable() : true;
            if (!nullable) throw new SerializationError('Not nullable value must not be null');
        } else if (type === EdmPrimitiveTypeKind.Binary) {
            const maxLength = property ? property.getMaxLength() : null;
            new ValueValidator().validateBinary(value, maxLength);
            const contentType = options && options[JsonAnnotations.MEDIA_CONTENT_TYPE] ?
                options[JsonAnnotations.MEDIA_CONTENT_TYPE] :
                ContentTypes.BINARY;
            response.setHeader(HeaderNames.CONTENT_TYPE, contentType);
        } else {
            const converter = new ValueConverter(new ValueValidator(),
                // The result is a string, so the parameter to format according to IEEE754 can be set unconditionally.
                // This is needed, e.g., for large Int64 values.
                new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true'));
            value = String(converter.convert(property || type, value));
            response.setHeader(HeaderNames.CONTENT_TYPE, ContentTypes.TEXT_PLAIN);
        }

        next(null, value);
    }
}

module.exports = SerializerFactory;
