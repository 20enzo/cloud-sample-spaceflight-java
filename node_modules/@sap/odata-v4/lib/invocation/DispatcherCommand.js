'use strict';

const Command = require('./Command');
const RepresentationKinds = require('../format/RepresentationKind').Kinds;
const MetaProperties = require('../format/JsonFormat').MetaProperties;

/**
 * The `next` callback to be called upon finish execution.
 *
 * @callback Next
 * @param {?Error} error An error if there is one or null if not
 */

/**
 * Executes the request dispatching.
 *
 * @extends Command
 */
class DispatcherCommand extends Command {

    /**
     * Creates an instance of DispatcherCommand.
     *
     * @param {Context} context The current odata context
     * @param {ComponentManager} componentManager The current component manager instance
     * @param {Dispatcher} dispatcher The current dispatcher
     */
    constructor(context, componentManager, dispatcher) {
        super(context);
        this._componentManager = componentManager;
        this._dispatcher = dispatcher;
    }

    /**
     * Executes the registered request dispatcher
     *
     * @param {Next} next The next callback to be called on finish
     */
    execute(next) {
        const context = this.getContext();
        const logger = context.getLogger();
        logger.path('Entering DispatcherCommand.execute()...');

        const contract = context.getResponse().getContract();
        const locale = contract.getLocale();
        // If $metadata is requested and a locale is set, the locale-specific metadata document should be cached
        const isLocaleSpecificMetadataRequest = (contract.getRepresentationKind() === RepresentationKinds.METADATA
            && locale != null);
        const metadataCache = context.getService()._getMetadataCache();
        if (isLocaleSpecificMetadataRequest) {
            const cachedMetadata = metadataCache.get(contract.getContentTypeInfo().getMimeType(), locale);
            if (cachedMetadata) {
                logger.info('Skip dispatching, as $metadata was retrieved from cache');
                context.getResponse()
                    .setBody({ value: cachedMetadata.metadata, [MetaProperties.ETAG]: cachedMetadata.etag });
                context.getRequest().validateEtag(cachedMetadata.etag);
                return next();
            }
        }

        logger.info('Start dispatching...');

        this._dispatcher.dispatch(context, this._componentManager)
            .then(result => {
                if (isLocaleSpecificMetadataRequest && result.data != null && result.data.value != null) {
                    metadataCache.set(contract.getContentTypeInfo().getMimeType(), locale, result.data.value);
                    const metadataEtag = metadataCache.get(contract.getContentTypeInfo().getMimeType(), locale).etag;
                    context.getRequest().validateEtag(metadataEtag);
                    let data = result.data;
                    data[MetaProperties.ETAG] = metadataEtag;
                }

                context.getResponse().setBody(result.data);
                context.getResponse().setOdataOptions(result.options);
                return next();
            }).catch(next);

        return undefined;
    }
}

module.exports = DispatcherCommand;
