'use strict';

const EventListenerCommand = require('./EventListenerCommand');
const OdataVersionValidationCommand = require('./OdataVersionValidationCommand');
const UriParserCommand = require('./UriParserCommand');
const QueryOptionsValidationCommand = require('./QueryOptionsValidationCommand');
const QueryOptionsParserCommand = require('./QueryOptionsParserCommand');
const ConditionalRequestPreValidationCommand = require('./ConditionalRequestPreValidationCommand');
const ConditionalRequestControlCommand = require('./ConditionalRequestControlCommand');
const ParsePreferHeaderCommand = require('./ParsePreferHeaderCommand');
const OperationValidationCommand = require('./OperationValidationCommand');
const ContentNegotiatorCommand = require('./ContentNegotiatorCommand');
const LocaleNegotiatorCommand = require('./LocaleNegotiatorCommand');
const PresetResponseHeadersCommand = require('./PresetResponseHeadersCommand');
const SetStatuscodeCommand = require('./SetStatuscodeCommand');
const SendResponseCommand = require('./SendResponseCommand');
const DeserializingCommand = require('./DeserializingCommand');
const DispatcherCommand = require('./DispatcherCommand');
const SetResponseHeadersCommand = require('./SetResponseHeadersCommand');
const SerializingCommand = require('./SerializingCommand');
const ErrorSerializingCommand = require('./ErrorSerializingCommand');
const ErrorContentNegotiatorCommand = require('./ErrorContentNegotiatorCommand');
const DebugContentNegotiatorCommand = require('./DebugContentNegotiatorCommand');
const DebugSerializingCommand = require('./DebugSerializingCommand');
const InjectionCommand = require('./InjectionCommand');
const BatchStartCommand = require('./batch/BatchStartCommand');
const BatchValidationCommand = require('./batch/BatchValidationCommand');
const BatchExecutionListBuilderCommand = require('./batch/BatchExecutionInfoBuilderCommand');
const BatchExecutionListProcessorCommand = require('./batch/BatchExecutionInfoProcessorCommand');

const RequestContentNegotiator = require('../format/RequestContentNegotiator');
const ContextUrlFactory = require('../serializer/ContextURLFactory');
const NextLinkSerializer = require('../serializer/NextLinkSerializer');
const DeserializerFactory = require('../deserializer/DeserializerFactory');
const HttpStatusCode = require('../http/HttpStatusCode');
const HeaderNames = require('../http/HttpHeader').HeaderNames;
const Components = require('../core/ComponentManager').Components;

const contextUrlFactoryInstance = new ContextUrlFactory();
const nextLinkSerializerInstance = new NextLinkSerializer();

/**
 * The CommandFactory creates chains of commands which can be used for execution by a corresponding executor.
 */
class CommandFactory {

    /**
     * Creates a chain of commands which can be used to execute a default single request.
     * If the url indicates that the request should be in debug mode,
     * additional debug commands to handle the debug mode will be added to the command chain.
     * If the url indicates that the request should be profiled,
     * additional profiling commands will be added to the command chain.
     *
     * @param {Object} options An options object with configuration properties
     * @param {ComponentManager} options.componentManager The current component manager instance
     * @param {FormatManager} options.formatManager The current format manager instance
     * @param {Context} options.context The current odata context instance
     * @param {boolean} options.isDebug If true request will be processed in debug mode
     * @param {boolean} options.isProfiling if true the request will be profiled
     * @returns {Array.<Array>} an array of commands with their descriptions
     */
    static createForSingleRequest(options) {
        const context = options.context;
        const request = context.getRequest();
        const response = context.getResponse();
        const logger = context.getLogger();

        const uriParser = options.componentManager.getComponent(Components.URI_PARSER)
            .setPerformanceMonitor(context.getPerformanceMonitor());
        const contentNegotiator = options.componentManager.getComponent(Components.CONTENT_NEGOTIATOR)
            .setLogger(logger);
        const requestValidator = options.componentManager.getComponent(Components.REQUEST_VALIDATOR)
            .setLogger(logger);

        const dispatcher = options.componentManager.getComponent(Components.DISPATCHER);

        logger.path('Entering CommandFactory.createForSingleRequest(options)...');

        let result = [
            [
                new EventListenerCommand(context, options.componentManager.getComponent('request'), 'request'),
                'Eventlistener request'
            ],
            [
                new OdataVersionValidationCommand(context, HeaderNames.ODATA_VERSION, HeaderNames.ODATA_MAXVERSION),
                'Request header validation'
            ],
            [new UriParserCommand(uriParser, request, logger), 'Uri parsing'],
            [new ParsePreferHeaderCommand(context, requestValidator), 'Prefer parsing'],
            [new OperationValidationCommand(context, requestValidator), 'Operation validation'],
            [
                new QueryOptionsValidationCommand(requestValidator, request, response, logger),
                'Query options validation'
            ],
            [new QueryOptionsParserCommand(uriParser, request, logger), 'Query options parsing'],
            [new ConditionalRequestPreValidationCommand(context), 'Conditional request validation'],
            [new ContentNegotiatorCommand(context, options.formatManager, contentNegotiator), 'Content negotiation'],
            [new LocaleNegotiatorCommand(context), 'Locale negotiation'],
            [
                new PresetResponseHeadersCommand(request, response, context.getService().getOdataVersion(), logger),
                'Preset response headers'
            ],
            [
                new DeserializingCommand(context, options.bodyParserManager, new RequestContentNegotiator()),
                'Deserialize request body'
            ],
            [new DispatcherCommand(context, options.componentManager, dispatcher), 'Handler dispatching'],
            [new ConditionalRequestControlCommand(context), 'Conditional request control'],
            [
                new SetResponseHeadersCommand(request, response, context.getService().getFormatManager(), logger),
                'Set response headers'
            ],
            [new SetStatuscodeCommand(context, HttpStatusCode.resolveSuccessStatusCode), 'Set status code'],
            [new SerializingCommand(context, contextUrlFactoryInstance, nextLinkSerializerInstance), 'Serializing'],
            [new SendResponseCommand(context), 'Send response']
        ];
        if (options.isDebug) CommandFactory._addDebugCommands(result, options);
        return result;
    }

    /**
     * Creates a chain of commands which can be used to execute an error event.
     * If the url indicates that the request should be in debug mode,
     * additional debug commands to handle the debug mode will be added to the command chain.
     * If the url indicates that the request should be profiled,
     * additional profiling commands will be added to the command chain.
     *
     * @param {Object} options An options object with configuration properties
     * @param {Object} options.componentManager The current component manager instance
     * @param {Object} options.formatManager The current format manager instance
     * @param {Object} options.context The current odata context instance
     * @param {boolean} options.isDebug If true request will be processed in debug mode
     * @param {boolean} options.isProfiling if true the request will be profiled
     * @returns {Array.<Array>} an array of commands with their descriptions
     */
    static createForSingleRequestError(options) {
        const context = options.context;
        const logger = context.getLogger();

        const contentNegotiator = options.componentManager.getComponent(Components.CONTENT_NEGOTIATOR)
            .setLogger(logger);

        let result = [
            [
                new EventListenerCommand(context, options.componentManager.getComponent('error'), 'error'),
                'Eventlistener error'
            ], [
                new ErrorContentNegotiatorCommand(context, options.formatManager, contentNegotiator),
                'Error content negotiation'
            ],
            [
                new PresetResponseHeadersCommand(context.getRequest(), context.getResponse(),
                    context.getService().getOdataVersion(), logger),
                'Set error response headers'
            ],
            [new SetStatuscodeCommand(context, HttpStatusCode.resolveErrorStatusCode), 'Set error status code'],
            [new ErrorSerializingCommand(context), 'Serializing error'],
            [new SendResponseCommand(context), 'Send error response']
        ];
        if (options.isDebug) CommandFactory._addDebugCommands(result, options);
        return result;
    }

    /**
     * Adds debug negotiation and debug serializing commands to the provided chain of commands.
     * @param {Array.<Array>} commands Array of commands with their descriptions to add the debug commands to
     * @param {Object} options An options object with configuration properties
     * @param {Object} options.formatManager The current format manager instance
     * @param {Object} options.context The current odata context instance
     */
    static _addDebugCommands(commands, options) {
        const context = options.context;
        const logger = context.getLogger();

        const contentNegotiator = options.componentManager.getComponent(Components.CONTENT_NEGOTIATOR)
            .setLogger(logger);

        // For debug output, we have to stop the runtime measurement prematurely;
        // otherwise we won't get the total runtime in the output (which is written in a command, too).
        commands.push([
            new InjectionCommand(context, (odataContext, next) => {
                odataContext.getPerformanceMonitor().stop();
                next();
            }),
            '']);

        const binaryParserFunction = DeserializerFactory.createBinaryDeserializer();
        commands.push([
            new InjectionCommand(context, (odataContext, next) => {
                if (!odataContext.getRequest().getBody()) {
                    binaryParserFunction(odataContext.getRequest(),
                        (error, body) => {
                            odataContext.getRequest().setBody(Buffer.from(body).toString());
                            next(error);
                        });
                } else {
                    next();
                }
            }),
            '']);

        commands.push([new DebugContentNegotiatorCommand(context, options.formatManager, contentNegotiator), '']);
        commands.push([new SetStatuscodeCommand(context, HttpStatusCode.resolveDebugStatusCode), '']);
        commands.push([new DebugSerializingCommand(context), '']);
        commands.push([
            new PresetResponseHeadersCommand(context.getRequest(), context.getResponse(),
                context.getService().getOdataVersion(), logger), '']);
        commands.push([new SendResponseCommand(context), '']);
    }

    /**
     * Create batch commands.
     * @param {BatchContext} batchContext
     * @returns {Array.<Array>} an array of commands with their descriptions
     */
    static createBatchCommands(batchContext) {
        return [
            [new BatchValidationCommand(batchContext), ''], // validate the request list (check request id and atomicity groups)
            [new BatchExecutionListBuilderCommand(batchContext), ''], // create commands for execution
            [new BatchStartCommand(batchContext), ''], // emit batch start event
            [new BatchExecutionListProcessorCommand(batchContext), ''] // execute batch request
        ];
    }
}

module.exports = CommandFactory;
