'use strict';

const Command = require('./Command');
const StatusCodes = require('../http/HttpStatusCode').StatusCodes;
const RepresentationKinds = require('../format/RepresentationKind').Kinds;

/**
* The `next` callback to be called upon finish execution.
*
* @callback Next
* @param {?Error} error An error if there is one or null if not
*/

/**
 * Executes the validation of the request conditional request.
 */
class ConditionalRequestControlCommand extends Command {

    constructor(context) {
        super(context);
    }

    execute(next) {
        const logger = this.getContext().getLogger();

        logger.path('Entering ConditionalRequestControlCommand.execute()...');

        const request = this.getContext().getRequest();
        const response = this.getContext().getResponse();

        // Validate the etag validation has been called by the data handler.
        if (request.isConditional()) {

            if (!request.validateEtagHasBeenCalled()) {
                return next(new Error(
                    'Error in conditional request processing.' +
                    ' The function validateEtag(etag) has to be called by the application.'
                ));
            }

            // Do not set statusCode directly because of internal response cache.
            if (request.getETAGValidationStatus() === StatusCodes.NOT_MODIFIED) {
                response.setStatusCode(StatusCodes.NOT_MODIFIED);

                const formatManager = this.getContext().getService().getFormatManager();
                response.getContract().setSerializerFunction(formatManager
                    .getFormatDescriptions(RepresentationKinds.NO_CONTENT, null)[0]
                    .getSerializerFunction());
            }
        }

        return next();
    }
}

module.exports = ConditionalRequestControlCommand;
