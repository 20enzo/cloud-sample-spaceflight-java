'use strict';

const MethodNotAllowedError = require('../errors/MethodNotAllowedError');
const NotImplementedError = require('../errors/NotImplementedError');

const ResourceKind = require('../uri/UriResource').ResourceKind;
const Components = require('./ComponentManager').Components;
const HttpMethods = require('../http/HttpMethod').Methods;

/**
 * Validate if the requested method is included in an array of one ore more allowed methods.
 *
 * @param {string} requestMethod The request method.
 * @param {...string} allowedMethods One or more allowed methods.
 * @private
 */
function validateHttpMethod(requestMethod, ...allowedMethods) {
    for (const allowedMethod of allowedMethods) {
        if (requestMethod === allowedMethod) {
            return;
        }
    }
    throw new MethodNotAllowedError();
}

/**
 * The main odata dispatcher for resource dispatching. The dispatcher resolves the appropriate
 * handler for the request and is responsible for its execution.
 */
class Dispatcher {

    /**
     * Dispatch the request to the appropriate handler.
     *
     * @param {Context} context The odata context.
     * @param {ComponentManager} componentManager The component manager with registered components.
     * @returns {Promise} Resolve with execution result data or rejects with an error
     */
    dispatch(context, componentManager) {
        const logger = context.getLogger();
        logger.path('Entering Dispatcher.dispatch()...');

        const request = context.getRequest();
        const lastKind = request.getUriInfo().getLastSegment().getKind();

        logger.debug('Found kind of last uriInfo segment: ', lastKind);

        switch (lastKind) {
            case ResourceKind.METADATA:
                validateHttpMethod(request.getMethod(), HttpMethods.GET);
                return this._handle(context, componentManager, Components.METADATA_HANDLER);

            case ResourceKind.SERVICE:
                validateHttpMethod(request.getMethod(), HttpMethods.GET, HttpMethods.HEAD);
                return this._handle(context, componentManager, Components.SERVICE_HANDLER);

            case ResourceKind.BATCH:
                validateHttpMethod(request.getMethod(), HttpMethods.POST);
                return this._handle(context, componentManager, Components.BATCH_EXECUTE_HANDLER);

            case ResourceKind.BOUND_ACTION:
            case ResourceKind.ACTION_IMPORT:
                validateHttpMethod(request.getMethod(), HttpMethods.POST);
                return this._handle(context, componentManager, Components.ACTION_EXECUTE_HANDLER);

            default:
                break;
        }

        switch (request.getMethod()) {
            case HttpMethods.GET:
                return this._handle(context, componentManager, Components.DATA_READ_HANDLER);

            case HttpMethods.DELETE:
                return this._handle(context, componentManager, Components.DATA_DELETE_HANDLER);

            case HttpMethods.POST:
                return this._handle(context, componentManager, Components.DATA_CREATE_HANDLER);

            case HttpMethods.PATCH:
            case HttpMethods.PUT:
                return this._handle(context, componentManager, Components.DATA_UPDATE_HANDLER);

            case HttpMethods.HEAD:
                throw new NotImplementedError();

            default:
                throw new MethodNotAllowedError();
        }
    }

    /**
     * Handle a request with the selected handler.
     *
     * @param {Context} context The odata context.
     * @param {ComponentManager} componentManager The component manager with registered components.
     * @param {string} handlerName The name of the handler.
     * @returns {Promise} Resolve with execution result data or rejects with an error
     * @private
     */
    _handle(context, componentManager, handlerName) {

        const logger = context.getLogger();
        logger.path('Entering Dispatcher._handle()...');

        const handler = componentManager.getComponent(handlerName);
        logger.debug('Handler found for name', handlerName, handler);

        if (!handler) {
            throw new NotImplementedError(`Not implemented: Handler '${handlerName}' could not be found`);
        }

        const performanceMonitor = context.getPerformanceMonitor()
            .getChild('Handler dispatching')
            .createChild('Process handler ' + handlerName).start();

        return new Promise((resolve, reject) => {
            handler(context.getRequest(), context.getResponse(),
                (err, resultData, resultOptions) => {
                    logger.debug('Options result of handler operation:', resultOptions);

                    return err ? reject(err) : resolve({ data: resultData, options: resultOptions });
                });
        }).then((result) => {
            performanceMonitor.stop();
            return result;
        });

    }
}

module.exports = Dispatcher;
