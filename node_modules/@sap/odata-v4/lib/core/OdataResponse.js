'use strict';

const stream = require('stream');
const PreferenceApplied = require('../http/PreferencesApplied.js');
const validateThat = require('../validator/ParameterValidator').validateThat;

/**
 * Response object wrapper to carry original response information.
 * If any error occurs in the underlying stream, the OdataResponse object emits this error.
 * If any data was written, a finish event will be emitted
 *
 * @extends stream.Writeable
 * @hideconstructor
 */
class OdataResponse extends stream.Writable {

    /**
     * Creates an instance of OdataResponse. The odata response is a writable stream.
     *
     * @param {PlainHttpResponse|http.ServerResponse} inResponse - The original response object.
     * @param {Object} streamOptions - The writable stream options.
     */
    constructor(inResponse, streamOptions) {
        super(streamOptions);

        this._response = inResponse;

        this._response.on('error', err => this.emit('error', err));
        this._response.on('finish', () => this.emit('finish'));

        this._isBuffered = false;
        this._buffer = Buffer.from('');

        this._preferencesApplied = null;

        this._statusCodeHasBeenSet = false;

        this._contract = null;

        this._loggerFacade = null;
    }

    /**
     * Returns the current logger instance.
     *
     * @returns {LoggerFacade} The current logger facade
     */
    getLogger() {
        return this._loggerFacade;
    }

    /**
     * Sets the current logger instance.
     *
     * @param {Object} logger The current logger
     * @returns {OdataResponse} This odata response instance
     * @package
     */
    setLogger(logger) {
        this._loggerFacade = logger;
        return this;
    }

    /**
     * Sets the response contract.
     *
     * @param {ResponseContract} contract The response contract
     * @returns {OdataResponse} this response object
     * @package
     */
    setContract(contract) {
        if (this._contract !== null) {
            this._originalContract = this._contract;
        }
        this._contract = contract;
        return this;
    }

    /**
     * Returns the current response contract.
     *
     * @returns {ResponseContract} The current response contract
     */
    getContract() {
        return this._contract;
    }

    /**
     * Returns the original response contract.
     *
     * @returns {ResponseContract} The original response contract
     */
    getOriginalContract() {
        return this._originalContract;
    }

    /**
     * Returns true if this response is in buffered mode, else false.
     *
     * @returns {boolean} True if in buffered mode, else false.
     */
    isBuffered() {
        return this._isBuffered;
    }

    /**
     * Returns the internal buffer.
     *
     * @returns {Buffer} The internal buffer.
     */
    getBuffer() {
        return this._buffer;
    }

    /**
     * Ends the the response and closes the underlying client connection.
     *
     * @param {string} data Any data to send to the client.
     * @returns {OdataResponse} Return this instance of OdataResponse.
     * @package
     */
    end(data) {
        if (!this.isBuffered()) {
            this._response.end(data);
            this._buffer = Buffer.from('');
        } else {
            this._concatBuffer(data);
        }
        return this;
    }

    /**
     * Internal stream implementation method.
     *
     * @param {string|Object} data Data to write.
     * @param {string} encoding The encoding, default is utf8.
     * @param {Function} callback Called when data was written.
     * @private
     */
    _write(data, encoding, callback) {
        if (!this.isBuffered()) {
            this._response.write(data, encoding);
        } else {
            this._concatBuffer(data);
        }
        callback();
    }

    /**
     * Concatenates the data to the internal buffer.
     *
     * @param {*} data The data to concatenate
     * @private
     */
    _concatBuffer(data) {
        if (data === null || data === undefined) {
            return;
        }
        const buf = Buffer.from(data);
        const totalLength = buf.length + this.getBuffer().length;
        this._buffer = Buffer.concat([this.getBuffer(), buf], totalLength);
    }

    /**
     * Sets the response status code.
     * The status code can only be set once unless the overwrite option isn't used.
     *
     * @param {number} statusCode The status code to set.
     * @param {Object} [options] An options object to control the behavior for setting the status code.
     * @param {Object} [options.overwrite] If true the status code will be set anyway. Default is 'false'
     * @throws IllegalArgumentError If the status code is not a number.
     * @returns {OdataResponse} This instance of odata response.
     */
    setStatusCode(statusCode, options = { overwrite: false }) {

        if (!this._statusCodeHasBeenSet || options.overwrite) {
            validateThat('statusCode', statusCode).typeOf('number');
            if (options.overwrite) {
                this._statusCodeOriginal = this._response.statusCode;
            }
            this._response.statusCode = statusCode;
            this._statusCodeHasBeenSet = true;
        }

        return this;
    }

    /**
     * Return the current status code of this response.
     *
     * @returns {number} The current status code.
     */
    getStatusCode() {
        return this._response.statusCode;
    }

    /**
     * Returns the original status code before overwriting
     *
     * @returns {number} the original status code
     */
    getOriginalStatusCode() {
        return this._statusCodeOriginal;
    }

    /**
     * Sets the status message of the http response.
     *
     * @param {string} msg The message to set.
     * @returns {OdataResponse} This instance of odata response.
     */
    setStatusMessage(msg) {
        this._response.statusMessage = msg;
        return this;
    }

    /**
     * Returns the status message of the http response.
     *
     * @returns {string} The status message
     */
    getStatusMessage() {
        return this._response.statusMessage;
    }

    /**
     * Set this response into buffered mode. If buffered mode is active, all data writing to
     * to response will be buffered and can be fetch by method .getBuffer().
     *
     * @param {boolean} isBuffered If true, response will be in buffered mode, else false
     * @returns {OdataResponse} This instance of odata response.
     */
    setBuffered(isBuffered) {
        this._isBuffered = isBuffered;
        return this;
    }

    /**
     * Stores all Preferences, which were actually applied by the application or library.
     *
     * @returns {PreferenceApplied} an object which stores the actually applied Preferences.
     */
    getPreferencesApplied() {
        if (this._preferencesApplied === null) {
            this._preferencesApplied = new PreferenceApplied();
        }
        return this._preferencesApplied;
    }

    /**
     * Set a header. The header name will be handled as case-insensitive key.
     * If a header already exists then the header will be replaced by this new value.
     *
     * @param {string} name Case-insensitive header name.
     * @param {string} value Value for the given header name.
     * @see <a href="http://ietf.org/rfc/rfc7230.txt">RFC 7230, section 3.2.2</a>
     */
    setHeader(name, value) {
        this._response.setHeader(name, value);
        return this;
    }

    /**
     * Returns the corresponding header value found by name.
     *
     * @param {string} name The name of the header value.
     * @returns {string} The value for the header, or undefined if not found.
     */
    getHeader(name) {
        return this._response.getHeader(name);
    }

    /**
     * Returns all available headers set.
     *
     * @returns {Object} All headers with header: headerValue pairs.
     */
    getHeaders() {
        /*
         * ._response._headers is a node.js private ServerResponse property which we decided to
         * use for now to get the headers of the response.
         * Currently the is no other effective possibility to get headers from response.
         */
        return this._response._headers;
    }

    /**
     * Returns true if the headers of the response were been already send.
     *
     * @returns {boolean} true if headers were already been sent, else false
     */
    isHeadersSent() {
        return this._response.headersSent;
    }

    /**
     * Returns the response body created by application. This body should be send to the client
     * @returns {*} This body
     */
    getBody() {
        return this._body;
    }

    /**
     * Sets the response body. The body is set though the processing of the dispatcher command.
     *
     * @param {*} body The response body
     * @returns {OdataResponse} This instance
     */
    setBody(body) {
        this._body = body;
        return this;
    }

    /**
     * @typedef {Object} Options
     */

    /**
     * Returns the odata response options. These options are needed for serialization.
     *
     * @returns {Options} The odata response options
     */
    getOdataOptions() {
        return this._odataOptions;
    }

    /**
     * Sets the odata response options.
     *
     * @param {Options} The odata response options
     * @returns {OdataResponse} This instance
     * @package
     */
    setOdataOptions(options) {
        this._odataOptions = options;
        return this;
    }
}

module.exports = OdataResponse;
