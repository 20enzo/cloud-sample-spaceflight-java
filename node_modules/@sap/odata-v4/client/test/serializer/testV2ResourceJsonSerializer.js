'use strict';

const assert = require('assert');

const V2ResourceJsonSerializer = require('../../lib/serializer/V2ResourceJsonSerializer');
const SerializationError = require('../../../lib/errors/SerializationError');
const IllegalArgumentError = require('../../../lib/errors/IllegalArgumentError');
const TestUtils = require('../../../test/TestUtils');
const names = require('../../../techService/names');

const edm = TestUtils.createEdm();
const etAllPrim = edm.getEntityType(names.entityTypeProviderNames.nameETAllPrim);
const etCompComp = edm.getEntityType(names.entityTypeProviderNames.nameETCompComp);
const etCompAllPrim = edm.getEntityType(names.entityTypeProviderNames.nameETCompAllPrim);
const ctAllPrim = edm.getComplexType(names.complexTypeProviderNames.nameCTAllPrim);

const serializer = new V2ResourceJsonSerializer();

describe(__filename, () => {
    describe('should serialize entity', () => {
        it('with all properties', () =>
            assert.strictEqual(
                serializer.serializeEntity(etAllPrim, {
                    value: {
                        PropertyInt16: 32767, PropertyString: 'string', PropertyBoolean: true,
                        PropertyByte: 255, PropertySByte: 127, PropertyInt32: 2147483647,
                        PropertyInt64: '9223372036854775807',
                        PropertySingle: 1790000000000, PropertyDouble: -17900000000000000, PropertyDecimal: '34',
                        PropertyBinary: Buffer.from([0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF]),
                        PropertyDateTimeOffset: '2001-04-19T04:25:21Z',
                        PropertyGuid: '01234567-89ab-cdef-0123-456789abcdef', PropertyTimeOfDay: '11:12:13'
                    }
                }),
                '{"PropertyInt16":32767,"PropertyString":"string","PropertyBoolean":true,'
                + '"PropertyByte":255,"PropertySByte":127,"PropertyInt32":2147483647,'
                + '"PropertyInt64":"9223372036854775807",'
                + '"PropertySingle":"1790000000000","PropertyDouble":"-17900000000000000",'
                + '"PropertyDecimal":"34","PropertyBinary":"ASNFZ4mrze8=",'
                + '"PropertyDateTimeOffset":"/Date(987654321000)/",'
                + '"PropertyGuid":"01234567-89ab-cdef-0123-456789abcdef","PropertyTimeOfDay":"PT11H12M13S"}'));

        it('with expanded navigation properties', () =>
            assert.strictEqual(
                serializer.serializeEntity(etAllPrim, {
                    value: {
                        NavPropertyETTwoPrimOne: { PropertyString: 'abc' },
                        NavPropertyETTwoPrimMany: [{ PropertyString: 'def' }, { PropertyString: 'ghi' }]
                    }
                }),
                '{"NavPropertyETTwoPrimOne":{"PropertyString":"abc"},'
                + '"NavPropertyETTwoPrimMany":[{"PropertyString":"def"},{"PropertyString":"ghi"}]}'));

        it('with null-valued navigation properties', () =>
            assert.strictEqual(
                serializer.serializeEntity(etAllPrim,
                    { value: { NavPropertyETTwoPrimOne: null, NavPropertyETTwoPrimMany: null } }),
                '{}'));

        it('with bind operations', () =>
            assert.strictEqual(
                serializer.serializeEntity(etAllPrim, { value:
                    {
                        PropertyBoolean: false,
                        'NavPropertyETTwoPrimOne*@odata.bind': 'ESTwoPrim(32767)',
                        'NavPropertyETTwoPrimMany*@odata.bind': ['ESTwoPrim(32767)', 'ESTwoPrim(32766)'],
                        PropertyString: 'ab'
                    }
                }),
                '{"PropertyBoolean":false,"NavPropertyETTwoPrimOne":{"__metadata":{"url":"ESTwoPrim(32767)"}},'
                + '"NavPropertyETTwoPrimMany":[{"__metadata":{"url":"ESTwoPrim(32767)"}},'
                + '{"__metadata":{"url":"ESTwoPrim(32766)"}}],"PropertyString":"ab"}'));
    });

    describe('should throw error on serializing wrong entity', () => {
        function testError(input, message) {
            assert.throws(() => serializer.serializeEntity(etAllPrim, input),
                error => error instanceof IllegalArgumentError && error.message === message
                    || error instanceof SerializationError && error.getRootCause().message === message);
        }

        it('without data', () => testError(null, "Parameter 'data' must not be undefined"));
        it('with non-object', () => testError([], "Parameter 'data.value' must not be undefined"));
        it('with non-object value', () => testError({ value: 1 }, "Parameter 'data.value' must be type of 'Object'"));
        it('without value', () => testError({ PropertyInt16: 1 }, "Parameter 'data.value' must not be undefined"));

        it('with not existing property', () =>
            testError({ value: { wrong: 42 } },
                "The entity data contain a 'wrong' property which is neither a structural nor a navigation property "
                + "of the 'ETAllPrim' type"));

        it('with null value for non-nullable property', () =>
            testError({ value: { PropertyInt16: null } },
                "The property 'PropertyInt16' is not nullable and must not have a null value."));

        it('with wrong value for navigation property', () =>
            testError({ value: { PropertyInt16: 1, NavPropertyETTwoPrimMany: {} } },
                "The provided data does not fit the type of the navigation property 'NavPropertyETTwoPrimMany'."));

        it('with wrong value for bind operation', () =>
            testError({ value: { 'NavPropertyETTwoPrimOne*@odata.bind': [] } },
                "The provided data does not fit the type of the navigation property 'NavPropertyETTwoPrimOne'."));

        it('with value and bind operation for the same navigation property', () =>
            testError({ value: { NavPropertyETTwoPrimMany: [], 'NavPropertyETTwoPrimMany*@odata.bind': [] } },
                "Providing simultaneously data and bind operation for navigation property 'NavPropertyETTwoPrimMany' "
                + 'is not supported.'));

        it('with bind operation and value for the same navigation property', () =>
            testError(
                { value: { 'NavPropertyETTwoPrimOne*@odata.bind': 'ESTwoPrim(-365)', NavPropertyETTwoPrimOne: {} } },
                "Providing simultaneously data and bind operation for navigation property 'NavPropertyETTwoPrimOne' "
                + 'is not supported.'));
    });

    describe('should serialize primitive property', () => {
        function testPrimitive(title, propertyName, value, expectedSerialization) {
            it(title, () => assert.strictEqual(
                serializer.serializePrimitive(ctAllPrim.getProperty(propertyName), { value }),
                '{"' + propertyName + '":' + expectedSerialization + '}'));
        }

        testPrimitive('with non-null value', 'PropertyInt16', 99, '99');

        testPrimitive('with time-of-day value with fractional seconds', 'PropertyTimeOfDay',
            '01:02:03.456', '"PT01H02M03.456S"');
        testPrimitive('with date-time-offset value before the epoch', 'PropertyDateTimeOffset',
            '1969-12-31T23:01:02.03Z', '"/Date(-3537970)/"');
        testPrimitive('with date-time-offset value with fractional seconds', 'PropertyDateTimeOffset',
            '1970-01-01T01:02:03.05Z', '"/Date(3723050)/"');
        testPrimitive('with date-time-offset value with fractional seconds with trailing 0s', 'PropertyDateTimeOffset',
            '1970-01-01T00:00:00.001000000000Z', '"/Date(1)/"');

        testPrimitive('with property with timezone offset', 'PropertyDateTimeOffset',
            '2001-04-19T04:25:21+02:00', '"/Date(987654321000+0120)/"');
        testPrimitive('with property with large timezone offset', 'PropertyDateTimeOffset',
            '2001-04-19T04:25:21-12:30', '"/Date(987654321000-0750)/"');
        testPrimitive('with property with timezone offset and fractional seconds', 'PropertyDateTimeOffset',
            '2001-04-19T04:25:21.05+00:30', '"/Date(987654321050+0030)/"');

        testPrimitive('with not-a-number double value', 'PropertyDouble', Number.NaN, '"Nan"');
        testPrimitive('with infinity double value', 'PropertyDouble', Number.POSITIVE_INFINITY, '"INF"');
        testPrimitive('with negative infinity single value', 'PropertyDouble', Number.NEGATIVE_INFINITY, '"-INF"');

        testPrimitive('with null value', 'PropertyByte', null, 'null');
    });

    describe('should throw error on serializing wrong primitive property', () => {
        function testError(propertyName, input, message) {
            assert.throws(
                () => serializer.serializePrimitive(etAllPrim.getProperty(propertyName), input),
                error => error instanceof IllegalArgumentError && error.message === message
                    || error.getRootCause().message === message);
        }

        it('without data', () => testError('PropertyByte', null, "Parameter 'data' must not be undefined"));
        it('with non-object', () => testError('PropertyByte', 42, "Parameter 'data' must be type of 'Object'"));

        it('with non-object data', () =>
            testError('PropertyByte', [],
                'Invalid value: undefined. An integer value must be specified for a value of Edm.Byte type.'));

        it('without value', () =>
            testError('PropertyByte', { x: 1 },
                'Invalid value: undefined. An integer value must be specified for a value of Edm.Byte type.'));

        it('with non-number for Edm.Decimal value', () =>
            testError('PropertyDecimal', { value: '1e2e3' },
                'Invalid value: 1e2e3. A number or a string representing a number must be specified for a value of '
                + 'Edm.Decimal type.'));

        it('with large JSON number for Edm.Int64 value', () =>
            testError('PropertyInt64', { value: 1e20 },
                'Invalid value: 100000000000000000000. The value does not representing an integer or '
                + 'its value is not in range from -9223372036854775808 to 9223372036854775807'));

        it('with wrong value', () =>
            testError('PropertyDateTimeOffset', { value: '/Date(123+01:30)/' },
                'Invalid value: /Date(123+01:30)/. A string value in the format YYYY-MM-DDThh:mm:ss.sTZD '
                + 'must be specified for a value of Edm.DateTimeOffset type.'));

        it('with facet-violating value for date-time property', () =>
            testError('PropertyDateTimeOffset', { value: '2001-04-19T04:25:21.9Z' },
                'Invalid value: 2001-04-19T04:25:21.9Z. '
                + 'The number of milliseconds does not correspond to the Precision facet value 0'));

        it('with value with sub-millisecond precision for date-time property', () =>
            assert.throws(
                () => serializer.serializePrimitive(ctAllPrim.getProperty('PropertyDateTimeOffset'),
                    { value: '2000-02-29T01:02:03.9876Z' }),
                error => error instanceof SerializationError
                    && error.getRootCause().message === "The Edm.DateTimeOffset value '2000-02-29T01:02:03.9876Z' has "
                        + 'more than three digits for fractional seconds; this is not supported.'));

        it('with facet-violating value for time property', () =>
            testError('PropertyTimeOfDay', { value: '01:02:03.9' },
                'Invalid value: 01:02:03.9. '
                + 'The number of milliseconds does not correspond to the Precision facet value 0'));

        it('with null value for non-nullable property', () =>
            testError('PropertyInt16', { value: null },
                "The property 'PropertyInt16' is not nullable and must not have a null value."));
    });

    describe('should serialize complex property', () => {
        it('with values', () =>
            assert.strictEqual(
                serializer.serializeComplex(etCompComp.getProperty('PropertyComp'),
                    { value: { PropertyComp: { PropertyInt16: 99, PropertyString: 'abc' } } }),
                '{"PropertyComp":{"PropertyComp":{"PropertyInt16":99,"PropertyString":"abc"}}}'));

        it('with null value', () =>
            assert.strictEqual(
                serializer.serializeComplex(etCompComp.getProperty('PropertyComp'), { value: null }),
                '{"PropertyComp":null}'));

        it('with time property with fractional seconds', () =>
            assert.strictEqual(
                serializer.serializeComplex(etCompAllPrim.getProperty('PropertyComp'),
                    { value: { PropertyTimeOfDay: '01:02:03.01234567' } }),
                '{"PropertyComp":{"PropertyTimeOfDay":"PT01H02M03.01234567S"}}'));
    });

    describe('should throw error on serializing wrong complex property', () => {
        function testError(input, message) {
            assert.throws(
                () => serializer.serializeComplex(etCompComp.getProperty('PropertyComp'), input),
                error => error instanceof IllegalArgumentError && error.message === message);
        }

        it('without data', () => testError(null, "Parameter 'data' must not be undefined"));
        it('with non-object', () => testError(42, "Parameter 'data' must be type of 'Object'"));
        it('with non-object data', () => testError([], "Parameter 'data.value' must not be undefined"));
        it('without value', () => testError({ x: 1 }, "Parameter 'data.value' must not be undefined"));
        it('with non-object value', () => testError({ value: 1 }, "Parameter 'data.value' must be type of 'Object'"));
    });
});
