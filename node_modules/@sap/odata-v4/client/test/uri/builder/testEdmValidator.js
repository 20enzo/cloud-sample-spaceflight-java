'use strict';

const assert = require('assert');
const EdmValidator = require('../../../lib/uri/builder/EdmValidator');
const EdmPrimitiveTypeKind = require('../../../../lib/edm/EdmPrimitiveTypeKind');
const EdmTypeKind = require('../../../../lib/edm/EdmType').TypeKind;
const SegmentInfo = require('../../../lib/uri/builder/SegmentInfo');
const SegmentParameter = require('../../../lib/uri/builder/SegmentParameter');
const ResourceKind = require('../../../../lib/uri/UriResource').ResourceKind;
const FQN = require('../../../../lib/FullQualifiedName');
const edm = require('../../../../test/TestUtils').createEdm();

/**
 * @param {string} name
 * @return {FullQualifiedName}
 */
const createFqn = (name) => {
    return new FQN('Namespace1_Alias', name);
};

describe(__filename, () => {
    describe('should test EdmValidator()', () => {

        /**
         * @type {EdmValidator}
         */
        let edmValidator;
        beforeEach(() => {
            edmValidator = new EdmValidator(edm);
        });

        describe('should test ._validateEntitySet()', () => {
            it('should return the entityType for an existing EntitySet', () => {
                const enitySet = 'ESAllPrim';
                const segment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, enitySet);
                const type = edmValidator._validateEntitySet(segment);
                assert.strictEqual(type, edm.getEntityContainer().getEntitySet(enitySet).getEntityType());
            });

            it('should throw an Error if the passed segment does not represent an EntitySet', () => {
                const segment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'NonExitingEntitySet');
                assert.throws(() => {
                    edmValidator._validateEntitySet(segment);
                });
            });

        });

        describe('should test ._validateSingleton()', () => {

            it('should return the entityType for an existing Singleton', () => {
                const singleton = 'SINav';
                const segment = new SegmentInfo(ResourceKind.SINGLETON, singleton);
                const type = edmValidator._validateSingleton(segment);
                assert.strictEqual(type, edm.getEntityContainer().getSingleton(singleton).getEntityType());
            });

            it('should throw an Error if the passed segment does not represent a Singleton', () => {
                const segment = new SegmentInfo(ResourceKind.SINGLETON, 'NonExitingSingleton');
                assert.throws(() => {
                    edmValidator._validateSingleton(segment);
                });
            });

        });

        describe('should test ._validateFunctionImport()', () => {

            const test = data => {
                it(`should return type "${data.expectedType.getName()}" for "${data.functionImport}"`, () => {
                    const segment = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, data.functionImport);
                    const type = edmValidator._validateFunctionImport(segment);
                    assert.strictEqual(type, data.expectedType);
                });
            };

            const testdata = [
                {
                    functionImport: 'FICRTESTwoKeyNav',
                    expectedType: edm.getEntityType(createFqn('ETTwoKeyNav'))
                },
                {
                    functionImport: 'FICRTCollESTwoKeyNavParam',
                    expectedType: edm.getEntityType(createFqn('ETTwoKeyNav'))
                },
                {
                    functionImport: 'FICRTCTTwoPrim',
                    expectedType: edm.getComplexType(createFqn('CTTwoPrim'))
                },
                {
                    functionImport: 'FICRTCollCTTwoPrim',
                    expectedType: edm.getComplexType(createFqn('CTTwoPrim'))
                },
                {
                    functionImport: 'FICRTString',
                    expectedType: EdmPrimitiveTypeKind.String
                },
                {
                    functionImport: 'FICRTCollString',
                    expectedType: EdmPrimitiveTypeKind.String
                },
                {
                    functionImport: 'FINRTInt16',
                    expectedType: EdmPrimitiveTypeKind.Int16
                }
            ];

            for (const data of testdata) {
                test(data);
            }

            it('should throw an error for a FunctionImport that has an overloaded underlying function', () => {
                // Overload functions are currently not supported
                const functionImport = 'FIC_RTTimeOfDay_';
                const segment = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, functionImport);
                assert.throws(() => {
                    edmValidator._validateFunctionImport(segment);
                });
            });
        });

        describe('should test ._validateProperty()', () => {

            it('should return the ComplexType for a ComplexProperty on an Entity', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESCompComp');
                edmValidator.validateSegment(null, entitySegment);
                const complexProperty = new SegmentInfo(ResourceKind.COMPLEX_PROPERTY, 'PropertyComp');
                const type = edmValidator._validateProperty(entitySegment, complexProperty);
                const expectedType = edm.getEntityType(createFqn('ETCompComp')).getProperty('PropertyComp');
                assert.strictEqual(type, expectedType);
            });

            it('should return the ComplexType for a ComplexProperty on an Entity(FunctionImport)', () => {
                const entitySegment = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTESTwoKeyNav');
                edmValidator.validateSegment(null, entitySegment);
                const complexProperty = new SegmentInfo(ResourceKind.COMPLEX_PROPERTY, 'PropertyComp');
                const type = edmValidator._validateProperty(entitySegment, complexProperty);
                const expectedType = edm.getEntityType(createFqn('ETTwoKeyNav')).getProperty('PropertyComp');
                assert.deepEqual(type, expectedType);
            });

            it('should return the ComplexType for a ComplexCollection on an Entity', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESMixPrimCollComp');
                edmValidator.validateSegment(null, entitySegment);
                const complexProperty = new SegmentInfo(ResourceKind.COMPLEX_COLLECTION_PROPERTY, 'CollPropertyComp');
                const type = edmValidator._validateProperty(entitySegment, complexProperty);
                const expectedType = edm.getEntityType(createFqn('ETMixPrimCollComp')).getProperty('CollPropertyComp');
                assert.strictEqual(type, expectedType);
            });

            it('should return the ComplexType for a ComplexProperty on a ComplexProperty', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESCompComp');
                edmValidator.validateSegment(null, entitySegment);
                entitySegment.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                const complexSegment = new SegmentInfo(ResourceKind.COMPLEX_PROPERTY, 'PropertyComp');
                edmValidator.validateSegment(entitySegment, complexSegment);

                const complexProperty = new SegmentInfo(ResourceKind.COMPLEX_PROPERTY, 'PropertyComp');
                const type = edmValidator._validateProperty(complexSegment, complexProperty);
                const expectedType = edm.getEntityType(createFqn('ETCompComp')).getProperty('PropertyComp')
                    .getType().getProperty('PropertyComp');
                assert.strictEqual(type, expectedType);
            });

            it('should return the ComplexType for a ComplexCollection on a ComplexProperty', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESCompCollComp');
                edmValidator.validateSegment(null, entitySegment);
                entitySegment.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                const complexSegment = new SegmentInfo(ResourceKind.COMPLEX_PROPERTY, 'PropertyComp');
                edmValidator.validateSegment(entitySegment, complexSegment);
                const primitive = new SegmentInfo(ResourceKind.COMPLEX_COLLECTION_PROPERTY, 'CollPropertyComp');
                const type = edmValidator._validateProperty(complexSegment, primitive);
                const expectedType = edm.getEntityType(createFqn('ETCompCollComp')).getProperty('PropertyComp')
                    .getType().getProperty('CollPropertyComp');
                assert.strictEqual(type, expectedType);
            });

            it('should return the PrimitiveType for a PrimitiveProperty on an Entity', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entitySegment);

                const primitiveProperty = new SegmentInfo(ResourceKind.PRIMITIVE_PROPERTY, 'PropertyInt16');
                const type = edmValidator._validateProperty(entitySegment, primitiveProperty);
                assert.strictEqual(type, edm.getEntityType(createFqn('ETAllPrim')).getProperty('PropertyInt16'));
            });

            it('should return the PrimitiveType for a PrimitiveCollection on an Entity', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESCollAllPrim');
                edmValidator.validateSegment(null, entitySegment);

                const primitiveProperty =
                    new SegmentInfo(ResourceKind.PRIMITIVE_COLLECTION_PROPERTY, 'CollPropertyString');
                const type = edmValidator._validateProperty(entitySegment, primitiveProperty);
                const expectedType = edm.getEntityType(createFqn('ETCollAllPrim')).getProperty('CollPropertyString');
                assert.strictEqual(type, expectedType);
            });

            it('should return the PrimitiveType for a PrimitiveProperty on an Entity(FunctionImport)', () => {
                const entitySegment = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTESTwoKeyNav');
                edmValidator.validateSegment(null, entitySegment);

                const primitiveProperty = new SegmentInfo(ResourceKind.PRIMITIVE_PROPERTY, 'PropertyInt16');
                const type = edmValidator._validateProperty(entitySegment, primitiveProperty);
                assert.strictEqual(type, edm.getEntityType(createFqn('ETTwoKeyNav')).getProperty('PropertyInt16'));
            });

            it('should return the PrimitiveType for a PrimitiveProperty on a ComplexProperty', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESCompAllPrim');
                edmValidator.validateSegment(null, entitySegment);
                entitySegment.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                const complexSegment = new SegmentInfo(ResourceKind.COMPLEX_PROPERTY, 'PropertyComp');
                edmValidator.validateSegment(entitySegment, complexSegment);

                const primitiveProperty = new SegmentInfo(ResourceKind.PRIMITIVE_PROPERTY, 'PropertyInt16');
                const type = edmValidator._validateProperty(complexSegment, primitiveProperty);
                const expectedType = edm.getEntityType(createFqn('ETCompAllPrim')).getProperty('PropertyComp')
                    .getType().getProperty('PropertyInt16');
                assert.strictEqual(type, expectedType);
            });

            it('should return the PrimitiveType for a PrimitiveCollection on a ComplexProperty', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESCompCollAllPrim');
                edmValidator.validateSegment(null, entitySegment);
                entitySegment.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                const complexSegment = new SegmentInfo(ResourceKind.COMPLEX_PROPERTY, 'PropertyComp');
                edmValidator.validateSegment(entitySegment, complexSegment);

                const primitiveProperty =
                    new SegmentInfo(ResourceKind.PRIMITIVE_COLLECTION_PROPERTY, 'CollPropertyString');
                const type = edmValidator._validateProperty(complexSegment, primitiveProperty);
                const expectedType = edm.getEntityType(createFqn('ETCompCollAllPrim')).getProperty('PropertyComp')
                    .getType().getProperty('CollPropertyString');
                assert.strictEqual(type, expectedType);
            });

            it('should return the PrimitiveType for a PrimitiveProperty on a ComplexProperty(FunctionImport)', () => {
                const entitySegment = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCTTwoPrim');
                edmValidator.validateSegment(null, entitySegment);

                const primitiveProperty = new SegmentInfo(ResourceKind.PRIMITIVE_PROPERTY, 'PropertyInt16');
                const type = edmValidator._validateProperty(entitySegment, primitiveProperty);
                const expectedType = edm.getComplexType(createFqn('CTTwoPrim')).getProperty('PropertyInt16');
                assert.strictEqual(type, expectedType);
            });

            it('should throw an error, if the requested property does not exist on the entity', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entitySegment);
                const primitiveProperty = new SegmentInfo(ResourceKind.PRIMITIVE_PROPERTY, 'NonExistingProperty');
                assert.throws(() => edmValidator._validateProperty(entitySegment, primitiveProperty));
            });

            it('should throw an error, if the property is requested as complex but is not complex', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entitySegment);
                const complexProperty = new SegmentInfo(ResourceKind.COMPLEX_PROPERTY, 'PropertyInt16');
                assert.throws(() => edmValidator._validateProperty(entitySegment, complexProperty));
            });

            it('should throw an error, if the property is requested as primitive but is complex', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESMixPrimCollComp');
                edmValidator.validateSegment(null, entitySegment);
                const primitiveProperty = new SegmentInfo(ResourceKind.PRIMITIVE_PROPERTY, 'PropertyComp');
                assert.throws(() => edmValidator._validateProperty(entitySegment, primitiveProperty));
            });

            it('should throw an error, if the property is requested as collection but is not a collection', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESMixPrimCollComp');
                edmValidator.validateSegment(null, entitySegment);
                const collectionProperty = new SegmentInfo(ResourceKind.PRIMITIVE_COLLECTION_PROPERTY, 'PropertyInt16');
                assert.throws(() => edmValidator._validateProperty(entitySegment, collectionProperty));
            });

            it('should throw an error, if the property is not requested as collection but is a collection', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESMixPrimCollComp');
                edmValidator.validateSegment(null, entitySegment);
                const primitiveProperty = new SegmentInfo(ResourceKind.PRIMITIVE_PROPERTY, 'CollPropertyString');
                assert.throws(() => edmValidator._validateProperty(entitySegment, primitiveProperty));
            });

        });

        describe('should test _validateNavigationProperty()', () => {

            it('should return the EntityType for a NavigationToMany on an Entity', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entitySegment);

                const navigationProperty = new SegmentInfo(ResourceKind.NAVIGATION_TO_MANY, 'NavPropertyETTwoPrimMany');
                const type = edmValidator._validateNavigationProperty(entitySegment, navigationProperty);
                assert.strictEqual(type, edm.getEntityType(createFqn('ETTwoPrim')));
            });

            it('should return the EntityType for a NavigationToMany on an Entity(FunctionImport)', () => {
                const entitySegment = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTESTwoKeyNav');
                edmValidator.validateSegment(null, entitySegment);

                const navProperty = new SegmentInfo(ResourceKind.NAVIGATION_TO_MANY, 'NavPropertyETTwoKeyNavMany');
                const type = edmValidator._validateNavigationProperty(entitySegment, navProperty);
                assert.strictEqual(type, edm.getEntityType(createFqn('ETTwoKeyNav')));
            });

            it('should return the EntityType for a NavigationToOne on an Entity', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entitySegment);

                const navigationProperty = new SegmentInfo(ResourceKind.NAVIGATION_TO_ONE, 'NavPropertyETTwoPrimOne');
                const type = edmValidator._validateNavigationProperty(entitySegment, navigationProperty);
                assert.strictEqual(type, edm.getEntityType(createFqn('ETTwoPrim')));
            });

            it('should return the EntityType for a NavigationToMany on an Entity(FunctionImport)', () => {
                const entitySegment = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTESTwoKeyNav');
                edmValidator.validateSegment(null, entitySegment);

                const navProperty = new SegmentInfo(ResourceKind.NAVIGATION_TO_ONE, 'NavPropertyETTwoKeyNavOne');
                const type = edmValidator._validateNavigationProperty(entitySegment, navProperty);
                assert.strictEqual(type, edm.getEntityType(createFqn('ETTwoKeyNav')));
            });

            it('should throw an error, if a NavigationToOne is called with a NavigationToMany', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entitySegment);

                const navigationProperty = new SegmentInfo(ResourceKind.NAVIGATION_TO_MANY, 'NavPropertyETTwoPrimOne');
                assert.throws(() => { edmValidator._validateNavigationProperty(entitySegment, navigationProperty); });
            });

            it('should throw an error, if a NavigationToMany is called with a NavigationToOne', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entitySegment);

                const navigationProperty = new SegmentInfo(ResourceKind.NAVIGATION_TO_ONE, 'NavPropertyETTwoPrimMany');
                assert.throws(() => { edmValidator._validateNavigationProperty(entitySegment, navigationProperty); });
            });

            it('should throw an error, if a NavigationToOne does not exist on an Entity', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entitySegment);

                const navigationProperty = new SegmentInfo(ResourceKind.NAVIGATION_TO_ONE, 'NavPropertyNotExisting');
                assert.throws(() => { edmValidator._validateNavigationProperty(entitySegment, navigationProperty); });
            });

            it('should throw an error, if a NavigationToMany does not exist on an Entity', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entitySegment);

                const navigationProperty = new SegmentInfo(ResourceKind.NAVIGATION_TO_MANY, 'NavPropertyNotExisting');
                assert.throws(() => { edmValidator._validateNavigationProperty(entitySegment, navigationProperty); });
            });

        });

        describe('should test _validateKeyParameter()', () => {

            const test = data => {
                it(`should return type "${data.type}" for key-property "${data.propertyName}"`, () => {
                    const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllKey');
                    edmValidator.validateSegment(null, entitySegment);
                    const key = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                        .setName(data.propertyName);
                    const type = edmValidator._validateKeyParameter(entitySegment, key);
                    assert.strictEqual(type, data.type);
                });
            };

            const testdata = [
                {
                    propertyName: 'PropertyString',
                    type: EdmPrimitiveTypeKind.String
                },
                {
                    propertyName: 'PropertyBoolean',
                    type: EdmPrimitiveTypeKind.Boolean
                },
                {
                    propertyName: 'PropertyByte',
                    type: EdmPrimitiveTypeKind.Byte
                },
                {
                    propertyName: 'PropertySByte',
                    type: EdmPrimitiveTypeKind.SByte
                },
                {
                    propertyName: 'PropertyInt16',
                    type: EdmPrimitiveTypeKind.Int16
                },
                {
                    propertyName: 'PropertyInt32',
                    type: EdmPrimitiveTypeKind.Int32
                },
                {
                    propertyName: 'PropertyInt64',
                    type: EdmPrimitiveTypeKind.Int64
                },
                {
                    propertyName: 'PropertyDecimal',
                    type: EdmPrimitiveTypeKind.Decimal
                },
                {
                    propertyName: 'PropertyDate',
                    type: EdmPrimitiveTypeKind.Date
                },
                {
                    propertyName: 'PropertyDateTimeOffset',
                    type: EdmPrimitiveTypeKind.DateTimeOffset
                },
                {
                    propertyName: 'PropertyDuration',
                    type: EdmPrimitiveTypeKind.Duration
                },
                {
                    propertyName: 'PropertyGuid',
                    type: EdmPrimitiveTypeKind.Guid
                },
                {
                    propertyName: 'PropertyTimeOfDay',
                    type: EdmPrimitiveTypeKind.TimeOfDay
                }
            ];

            for (const data of testdata) { test(data); }

            it('should return the EdmPrimitiveType for a single key property without the name provided', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoPrim');
                edmValidator.validateSegment(null, entitySegment);
                const key = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE);
                const type = edmValidator._validateKeyParameter(entitySegment, key);
                assert.strictEqual(type, EdmPrimitiveTypeKind.Int16);
            });

            it('should throw an error if the provided type does not match with the edm (without property name)', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoPrim');
                edmValidator.validateSegment(null, entitySegment);
                const key = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setType(EdmPrimitiveTypeKind.Int32);
                assert.throws(() => { edmValidator._validateKeyParameter(entitySegment, key); });
            });

            it('should throw an error if the provided type does not match with the edm (with property name)', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoPrim');
                edmValidator.validateSegment(null, entitySegment);
                const key = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyInt16').setType(EdmPrimitiveTypeKind.Int32);
                assert.throws(() => { edmValidator._validateKeyParameter(entitySegment, key); });
            });

            it('should throw an error if the key property with the provided name does not exist', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoPrim');
                edmValidator.validateSegment(null, entitySegment);
                const key = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('NonExistingProperty');
                assert.throws(() => { edmValidator._validateKeyParameter(entitySegment, key); });
            });

            it('should throw an error if the key property was already set', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                edmValidator.validateSegment(null, entitySegment);
                const key = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyInt16');
                edmValidator._validateKeyParameter(entitySegment, key);
                assert.throws(() => { edmValidator._validateKeyParameter(entitySegment, key); });
            });

            it('should throw an error if no key property name was provided for a complex key', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                edmValidator.validateSegment(null, entitySegment);
                const key = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE);
                assert.throws(() => { edmValidator._validateKeyParameter(entitySegment, key); });
            });

        });

        describe('should test _validateFunctionParameter()', () => {

            it('should return the EdmPrimitiveType of a function Parameter', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollCTTwoPrimTwoParam');
                edmValidator.validateSegment(null, functionImport);

                const parameter = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER)
                    .setName('ParameterInt16');
                const type = edmValidator._validateFunctionParameter(functionImport, parameter);
                assert.strictEqual(type, EdmPrimitiveTypeKind.Int16);
            });

            it('should throw an error if the function parameter was already set', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollCTTwoPrimTwoParam');
                edmValidator.validateSegment(null, functionImport);

                const parameter = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER)
                    .setName('ParameterInt16');
                edmValidator._validateFunctionParameter(functionImport, parameter);
                assert.throws(() => { edmValidator._validateFunctionParameter(functionImport, parameter); });
            });

            it('should throw an error if the parameter with the provided name does not exist', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollCTTwoPrimTwoParam');
                edmValidator.validateSegment(null, functionImport);

                const parameter = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER)
                    .setName('NonExistingParameter');
                assert.throws(() => { edmValidator._validateFunctionParameter(functionImport, parameter); });
            });

            it('should throw an error if no name was provided for the parameter', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollCTTwoPrimTwoParam');
                edmValidator.validateSegment(null, functionImport);

                const parameter = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER);
                assert.throws(() => { edmValidator._validateFunctionParameter(functionImport, parameter); });
            });

            it('should throw an error if the provided type does not match with the edm', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollCTTwoPrimTwoParam');
                edmValidator.validateSegment(null, functionImport);

                const parameter = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER)
                    .setName('ParameterInt16').setType(EdmPrimitiveTypeKind.String);
                assert.throws(() => { edmValidator._validateFunctionParameter(functionImport, parameter); });
            });
        });

        describe('should test _validateRemainingProperties()', () => {

            it('should not throw an error, if all key-properties on an EntitySet were set', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                const propertyInt16 = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyInt16');
                const propertyString = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyString');
                edmValidator.validateSegment(null, entitySegment);
                edmValidator.validateParameter(entitySegment, propertyInt16);
                edmValidator.validateParameter(entitySegment, propertyString);
                edmValidator._validateRemainingProperties(entitySegment);
            });

            it('should throw an error, if only a partial set of key-properties was set on an EntitySet', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                const propertyInt16 = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyInt16');
                edmValidator.validateSegment(null, entitySegment);
                edmValidator.validateParameter(entitySegment, propertyInt16);
                assert.throws(() => { edmValidator._validateRemainingProperties(entitySegment); });
            });

            it('should not throw an error, if no key-properties were set on an EntitySet', () => {
                const entitySegment = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                edmValidator.validateSegment(null, entitySegment);
                edmValidator._validateRemainingProperties(entitySegment);
            });

            it('should not throw an error, if all function parameters were provided', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollCTTwoPrimTwoParam');
                const parameterInt16 = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER)
                    .setName('ParameterInt16').setType(EdmPrimitiveTypeKind.Int16);
                const parameterString = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER)
                    .setName('ParameterString').setType(EdmPrimitiveTypeKind.String);
                edmValidator.validateSegment(null, functionImport);
                edmValidator.validateParameter(functionImport, parameterInt16);
                edmValidator.validateParameter(functionImport, parameterString);
                edmValidator._validateRemainingProperties(functionImport);
            });

            it('should throw an error, if only a partial set of function parameters were provided', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollCTTwoPrimTwoParam');
                const parameterInt16 = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER)
                    .setName('ParameterInt16').setType(EdmPrimitiveTypeKind.Int16);
                edmValidator.validateSegment(null, functionImport);
                edmValidator.validateParameter(functionImport, parameterInt16);
                assert.throws(() => { edmValidator._validateRemainingProperties(functionImport); });
            });

            it('should throw an error, if none of the function parameters were provided', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollCTTwoPrimTwoParam');
                edmValidator.validateSegment(null, functionImport);
                assert.throws(() => { edmValidator._validateRemainingProperties(functionImport); });
            });

            it('should not throw an error, if all function parameters and key-properties were provided', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollESTwoKeyNavParam');
                const parameterInt16 = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER)
                    .setName('ParameterInt16').setType(EdmPrimitiveTypeKind.Int16);
                const propertyInt16 = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyInt16').setType(EdmPrimitiveTypeKind.Int16);
                const propertyString = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyString').setType(EdmPrimitiveTypeKind.String);
                edmValidator.validateSegment(null, functionImport);
                edmValidator.validateParameter(functionImport, parameterInt16);
                edmValidator.validateParameter(functionImport, propertyInt16);
                edmValidator.validateParameter(functionImport, propertyString);
                edmValidator._validateRemainingProperties(functionImport);
            });

            it('should throw an error, if not all function parameters but all key-properties were provided', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollESTwoKeyNavParam');
                const propertyInt16 = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyInt16').setType(EdmPrimitiveTypeKind.Int16);
                const propertyString = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyString').setType(EdmPrimitiveTypeKind.String);
                edmValidator.validateSegment(null, functionImport);
                edmValidator.validateParameter(functionImport, propertyInt16);
                edmValidator.validateParameter(functionImport, propertyString);
                assert.throws(() => { edmValidator._validateRemainingProperties(functionImport); });
            });

            it('should throw an error, if all function parameters but not all key-properties were provided', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollESTwoKeyNavParam');
                const parameterInt16 = new SegmentParameter(SegmentParameter.ParameterKind.FUNCTION_PARAMETER)
                    .setName('ParameterInt16').setType(EdmPrimitiveTypeKind.Int16);
                const propertyString = new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE)
                    .setName('PropertyString').setType(EdmPrimitiveTypeKind.String);
                edmValidator.validateSegment(null, functionImport);
                edmValidator.validateParameter(functionImport, parameterInt16);
                edmValidator.validateParameter(functionImport, propertyString);
                assert.throws(() => { edmValidator._validateRemainingProperties(functionImport); });
            });
        });

        describe('should test _postvalidateFunction()', () => {

            it('should not throw an Error if the functionImport returned an expected EdmTypeKind', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollESTwoKeyNavParam');
                edmValidator.validateSegment(null, functionImport);
                edmValidator._postvalidateFunction([EdmTypeKind.ENTITY], true, functionImport, 'Something');
            });

            it('should not throw an Error if no collection required and functionImport returns single Entity', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTESTwoKeyNav');
                edmValidator.validateSegment(null, functionImport);
                edmValidator._postvalidateFunction([EdmTypeKind.ENTITY], false, functionImport, 'Something');
            });

            it('should not throw an Error if no collection required and functionImport + keys return an Entity', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollESTwoKeyNavParam');
                edmValidator.validateSegment(null, functionImport);
                functionImport.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                edmValidator._postvalidateFunction([EdmTypeKind.ENTITY], false, functionImport, 'Something');
            });

            it('should throw an Error if the functionImport did not return an expected EdmTypeKind', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollESTwoKeyNavParam');
                edmValidator.validateSegment(null, functionImport);
                assert.throws(() => {
                    edmValidator._postvalidateFunction([EdmTypeKind.COMPLEX], true, functionImport, 'Something');
                });
            });

            it('should throw an Error if the functionImport returns a collection, but none is required', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollESTwoKeyNavParam');
                edmValidator.validateSegment(null, functionImport);
                assert.throws(() => {
                    edmValidator._postvalidateFunction([EdmTypeKind.ENTITY], false, functionImport, 'Something');
                });
            });

            it('should throw an Error if collection is required, but function Import returns an Entity', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTESTwoKeyNav');
                edmValidator.validateSegment(null, functionImport);
                assert.throws(() => {
                    edmValidator._postvalidateFunction([EdmTypeKind.ENTITY], true, functionImport, 'Something');
                });
            });

            it('should throw an Error if collection is required, but functionImport with keys was called', () => {
                const functionImport = new SegmentInfo(ResourceKind.FUNCTION_IMPORT, 'FICRTCollESTwoKeyNavParam');
                edmValidator.validateSegment(null, functionImport);
                functionImport.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                assert.throws(() => {
                    edmValidator._postvalidateFunction([EdmTypeKind.ENTITY], true, functionImport, 'Something');
                });
            });
        });

        describe('should test _validateBoundFunction()', () => {

            const testReturnType = (setup, boundFunction) => {
                it(`should return type "${boundFunction.type.getName()}" for "${boundFunction.name}"`, () => {
                    const previousSegment = setup(edmValidator);
                    const functionSegment = new SegmentInfo(ResourceKind.BOUND_FUNCTION,
                        'Namespace1_Alias.' + boundFunction.name);
                    const type = edmValidator._validateBoundFunction(previousSegment, functionSegment);
                    assert.strictEqual(type, boundFunction.type);
                });
            };

            const setupFunctions = {
                [ResourceKind.ENTITY_COLLECTION]: (validator) => {
                    const entitySet = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                    validator.validateSegment(null, entitySet);
                    return entitySet;
                },
                [ResourceKind.ENTITY]: (validator) => {
                    const entitySet = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                    validator.validateSegment(null, entitySet);
                    entitySet.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                    return entitySet;
                },
                [ResourceKind.COMPLEX_PROPERTY]: (validator) => {
                    const entitySet = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                    validator.validateSegment(null, entitySet);
                    entitySet.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                    const complex = new SegmentInfo(ResourceKind.COMPLEX_PROPERTY, 'PropertyComp');
                    validator.validateSegment(entitySet, complex);
                    return complex;
                },
                [ResourceKind.COMPLEX_COLLECTION_PROPERTY]: (validator) => {
                    const entitySet = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                    validator.validateSegment(null, entitySet);
                    entitySet.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                    const complex = new SegmentInfo(ResourceKind.COMPLEX_COLLECTION_PROPERTY, 'CollPropertyComp');
                    validator.validateSegment(entitySet, complex);
                    return complex;
                },
                [ResourceKind.PRIMITIVE_PROPERTY]: (validator) => {
                    const entitySet = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                    validator.validateSegment(null, entitySet);
                    entitySet.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                    const primitive = new SegmentInfo(ResourceKind.PRIMITIVE_PROPERTY, 'PropertyString');
                    validator.validateSegment(entitySet, primitive);
                    return primitive;
                },
                [ResourceKind.PRIMITIVE_COLLECTION_PROPERTY]: (validator) => {
                    const entitySet = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoKeyNav');
                    validator.validateSegment(null, entitySet);
                    entitySet.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                    const primitive = new SegmentInfo(ResourceKind.PRIMITIVE_COLLECTION_PROPERTY, 'CollPropertyString');
                    validator.validateSegment(entitySet, primitive);
                    return primitive;
                }
            };

            const testdata = [
                {
                    setup: setupFunctions[ResourceKind.ENTITY_COLLECTION],
                    boundFunctions: [
                        {
                            name: 'BFCESTwoKeyNavRTString',
                            type: EdmPrimitiveTypeKind.String
                        },
                        {
                            name: 'BFCESTwoKeyNavRTCollString',
                            type: EdmPrimitiveTypeKind.String
                        },
                        {
                            name: 'BFCESTwoKeyNavRTCTTwoPrim',
                            type: edm.getComplexType(createFqn('CTTwoPrim'))
                        },
                        {
                            name: 'BFCESTwoKeyNavRTCollCTTwoPrim',
                            type: edm.getComplexType(createFqn('CTTwoPrim'))
                        },
                        {
                            name: 'BFCESTwoKeyNavRTTwoKeyNav',
                            type: edm.getEntityType(createFqn('ETTwoKeyNav'))
                        },
                        {
                            name: 'BFCESTwoKeyNavRTESTwoKeyNav',
                            type: edm.getEntityType(createFqn('ETTwoKeyNav'))
                        }
                    ]
                },
                {
                    // ResourceKind.ENTITY
                    setup: setupFunctions[ResourceKind.ENTITY],
                    boundFunctions: [
                        {
                            name: 'BFCETTwoKeyNavRTESTwoKeyNav',
                            type: edm.getEntityType(createFqn('ETTwoKeyNav'))
                        },
                        {
                            name: 'BFCETTwoKeyNavRTETTwoKeyNav',
                            type: edm.getEntityType(createFqn('ETTwoKeyNav'))
                        },
                        {
                            name: 'BFCETTwoKeyNavRTCTTwoPrim',
                            type: edm.getComplexType(createFqn('CTTwoPrim'))
                        }
                    ]
                },
                {
                    setup: setupFunctions[ResourceKind.COMPLEX_PROPERTY],
                    boundFunctions: [
                        {
                            name: 'BFCCTPrimCompRTESTwoKeyNav',
                            type: edm.getEntityType(createFqn('ETTwoKeyNav'))
                        },
                        {
                            name: 'BFCCTPrimCompRTETTwoKeyNavParam',
                            type: edm.getEntityType(createFqn('ETTwoKeyNav'))
                        }
                    ]
                },
                {
                    setup: setupFunctions[ResourceKind.COMPLEX_COLLECTION_PROPERTY],
                    boundFunctions: [
                        {
                            name: 'BFCCollCTPrimCompRTESAllPrim',
                            type: edm.getEntityType(createFqn('ETAllPrim'))
                        }
                    ]
                },
                {
                    setup: setupFunctions[ResourceKind.PRIMITIVE_PROPERTY],
                    boundFunctions: [
                        {
                            name: 'BFCStringRTESTwoKeyNav',
                            type: edm.getEntityType(createFqn('ETTwoKeyNav'))
                        }
                    ]
                },
                {
                    setup: setupFunctions[ResourceKind.PRIMITIVE_COLLECTION_PROPERTY],
                    boundFunctions: [
                        {
                            name: 'BFCCollStringRTESTwoKeyNav',
                            type: edm.getEntityType(createFqn('ETTwoKeyNav'))
                        }
                    ]
                }
            ];

            for (const data of testdata) {
                for (const boundFunction of data.boundFunctions) {
                    testReturnType(data.setup, boundFunction);
                }
            }

            it('should throw an error if no boundFunction with the given name was found', () => {
                const boundFunction = new SegmentInfo(ResourceKind.BOUND_FUNCTION, 'Namespace1_Alias.NonExisting');
                assert.throws(() => { edmValidator._validateBoundFunction(null, boundFunction); });
            });

            it('should throw an error if the boundFunction with the given name is overloaded', () => {
                const boundFunction = new SegmentInfo(ResourceKind.BOUND_FUNCTION,
                    'Namespace1_Alias.BFC_RTESTwoKeyNav_');
                assert.throws(() => { edmValidator._validateBoundFunction(null, boundFunction); });
            });

            it('should throw an error, if the binding type does not match with the previous segment', () => {
                const previousSegment = setupFunctions[ResourceKind.ENTITY_COLLECTION](edmValidator);
                const boundFunction = new SegmentInfo(ResourceKind.BOUND_FUNCTION,
                    'Namespace1_Alias.BFCStringRTESTwoKeyNav');
                assert.throws(() => { edmValidator._validateBoundFunction(previousSegment, boundFunction); });
            });

            it('should throw an error, if the function requires a collection of entities as binding parameter, ' +
                'but the previous segment returns a single entity', () => {
                const previousSegment = setupFunctions[ResourceKind.ENTITY](edmValidator);
                const boundFunction = new SegmentInfo(ResourceKind.BOUND_FUNCTION,
                    'Namespace1_Alias.BFCESTwoKeyNavRTString');
                assert.throws(() => { edmValidator._validateBoundFunction(previousSegment, boundFunction); });
            });

            it('should throw an error, if the function requires a single Entity as binding parameter, ' +
                'but the previous segment returns a collection of entities', () => {
                const previousSegment = setupFunctions[ResourceKind.ENTITY_COLLECTION](edmValidator);
                const boundFunction = new SegmentInfo(ResourceKind.BOUND_FUNCTION,
                    'Namespace1_Alias.BFCETTwoKeyNavRTESTwoKeyNav');
                assert.throws(() => { edmValidator._validateBoundFunction(previousSegment, boundFunction); });
            });
        });

        describe('should test _validateBoundAction', () => {

            it('should pass if the preceding segment represents the correct EntityCollection', () => {
                const entityset = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entityset);
                const boundAction = new SegmentInfo(ResourceKind.BOUND_ACTION,
                    'Namespace1_Alias.BAESAllPrimRTETAllPrim');
                const type = edmValidator._validateBoundAction(entityset, boundAction);
                assert.strictEqual(type, edm.getEntityType(createFqn('ETAllPrim')));
            });

            it('should pass if the preceding segment represents the correct EntityType', () => {
                const entityset = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESAllPrim');
                edmValidator.validateSegment(null, entityset);
                entityset.addParameter(new SegmentParameter(SegmentParameter.ParameterKind.KEY_PREDICATE));
                const boundAction = new SegmentInfo(ResourceKind.BOUND_ACTION,
                    'Namespace1_Alias.BAETAllPrimRT');
                const type = edmValidator._validateBoundAction(entityset, boundAction);
                assert.strictEqual(type, null);
            });

            it('should throw an error, if no bound Action was found for the given name and binding parameter', () => {
                const entityset = new SegmentInfo(ResourceKind.ENTITY_COLLECTION, 'ESTwoPrim');
                edmValidator.validateSegment(null, entityset);
                const boundAction = new SegmentInfo(ResourceKind.BOUND_ACTION,
                    'Namespace1_Alias.BAETAllPrimRT');
                assert.throws(() => { edmValidator._validateBoundAction(entityset, boundAction); });
            });

        });
    });
});
