'use strict';

const assert = require('assert');
const V4UriLiteralEncoder = require('../../lib/utils/V4UriLiteralEncoder');
const EdmPrimitiveTypeKind = require('../../../lib/edm/EdmPrimitiveTypeKind');

describe(__filename, () => {
    describe('should test V4UriLiteralEncoder.encode()', () => {

        const testdata = [
            {
                title: 'should convert Edm.Binary',
                type: EdmPrimitiveTypeKind.Binary,
                value: Buffer.from('ASNFZ4mrze8=', 'base64'),
                expected: "binary'ASNFZ4mrze8='"
            },
            {
                title: 'should convert Edm.Boolean',
                type: EdmPrimitiveTypeKind.Boolean,
                value: true,
                expected: 'true'
            },
            {
                title: 'should convert Edm.Byte',
                type: EdmPrimitiveTypeKind.Byte,
                value: 123,
                expected: '123'
            },
            {
                title: 'should convert Edm.SByte',
                type: EdmPrimitiveTypeKind.SByte,
                value: -123,
                expected: '-123'
            },
            {
                title: 'should convert Edm.Date',
                type: EdmPrimitiveTypeKind.Date,
                value: '2016-08-15',
                expected: '2016-08-15'
            },
            {
                title: 'should convert Edm.DateTimeOffset',
                type: EdmPrimitiveTypeKind.DateTimeOffset,
                value: '2016-08-15T14:03:59Z',
                expected: '2016-08-15T14:03:59Z'
            },
            {
                title: 'should convert Edm.TimeOfDay',
                type: EdmPrimitiveTypeKind.TimeOfDay,
                value: '14:03:59',
                expected: '14:03:59'
            },
            {
                title: 'should convert Edm.Duration',
                type: EdmPrimitiveTypeKind.Duration,
                value: 'P1DT2H3M4S',
                expected: "duration'P1DT2H3M4S'"
            },
            {
                title: 'should convert Edm.Decimal',
                type: EdmPrimitiveTypeKind.Decimal,
                value: 123456890,
                expected: '123456890'
            },
            {
                title: 'should convert Edm.Single',
                type: EdmPrimitiveTypeKind.Single,
                value: 123.456,
                expected: '123.456'
            },
            {
                title: 'should convert Edm.Double',
                type: EdmPrimitiveTypeKind.Double,
                value: 123456.789,
                expected: '123456.789'
            },
            {
                title: 'should convert Edm.Guid',
                type: EdmPrimitiveTypeKind.Guid,
                value: '1234abcd-56ef-dc90-7f8e-a1b2c3d4e5f6',
                expected: '1234abcd-56ef-dc90-7f8e-a1b2c3d4e5f6'
            },
            {
                title: 'should convert Edm.Int16',
                type: EdmPrimitiveTypeKind.Int16,
                value: 12345,
                expected: '12345'
            },
            {
                title: 'should convert Edm.Int32',
                type: EdmPrimitiveTypeKind.Int32,
                value: 12345678,
                expected: '12345678'
            },
            {
                title: 'should convert Edm.Int64',
                type: EdmPrimitiveTypeKind.Int64,
                value: Number.MAX_SAFE_INTEGER,
                expected: `${Number.MAX_SAFE_INTEGER}`
            },
            {
                title: 'should convert Edm.String',
                type: EdmPrimitiveTypeKind.String,
                value: "te'st",
                expected: "'te''st'"
            },
            {
                title: 'should convert Edm.String',
                type: EdmPrimitiveTypeKind.String,
                value: 'te/st',
                expected: "'te%2Fst'"
            }
        ];

        for (const test of testdata) {
            it(test.title, () => {
                const encoder = new V4UriLiteralEncoder();
                const encodedValue = encoder.encode(test.value, test.type);
                assert.strictEqual(encodedValue, test.expected);
            });
        }
    });
});
