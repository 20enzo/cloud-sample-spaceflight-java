const sinon = require('sinon');
const assert = require('assert');
const fs = require('fs');
const xmljs = require('xml-js');
const TestUtils = require('../../../../test/TestUtils');
const MetadataConverter = require('../../../lib/converter/MetadataConverter');
const MetadataXmlSerializer = require('../../../../lib/serializer/MetadataXmlSerializer');

const logger = { path() { }, debug() { }, warn() { }, info() { } };

describe(__filename, () => {
    describe('MetadataConverter', () => {

        TestUtils.temporaryAllowUnsupportedFeatures();
        const client = TestUtils.createClient();

        describe('constructor', () => {

            it('should create instance of MetadataConverter', () => {
                assert.ok(new MetadataConverter() instanceof MetadataConverter);
            });

        });

        describe('Metadata.Emitter', () => {
            describe(".on('error', func).on('any', throw error).emit('any')", () => {
                it('should call on(error) handler', done => {
                    const message = 'An error';
                    new MetadataConverter.Emitter()
                        .on('error', (error) => {
                            try {
                                assert.equal(error.message, message);
                                done();
                            } catch (err) {
                                done(err);
                            }
                        })
                        .on('any', () => {
                            throw new Error(message);
                        })
                        .emit('any');
                });

            });

            describe(".emit('notExisting', func)", () => {
                it('should do nothing', done => {
                    new MetadataConverter.Emitter().emit('any');
                    done();
                });

            });
        });


        describe('Metadata.Context', () => {
            describe('.resolveAlias(null)', () => {
                it('should return null', done => {
                    const result = new MetadataConverter.Context().resolveAlias(null);
                    assert.equal(result, null);
                    done();
                });
            });
        });


        describe('.addConversion(name, strategies).execute(name, input, callback)', () => {

            it('should provide correct error on sync throw new Error in Strategy', (done) => {
                const spy = sinon.spy();

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy(() => {
                            spy();
                            throw new Error('Any error');
                        }),
                        new MetadataConverter.Strategy(() => {
                            spy();
                            throw new Error('Should not reach this code');
                        })
                    ])
                    .execute(null, (error) => {
                        try {
                            if (!error) return done(new Error('Expect error to be "Any error" but was undefined'));
                            assert.equal(error.message, 'Any error');
                            assert.equal(spy.callCount, 1);
                            return done();
                        } catch (assertationError) {
                            return done(assertationError);
                        }
                    });
            });

            it('should provide correct error on async new Error in Strategy', (done) => {
                const spy = sinon.spy();

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy((input, callback) => {
                            spy();
                            callback(new Error('Any error'));
                        }),
                        new MetadataConverter.Strategy(() => {
                            spy();
                            throw new Error('Should not reach this code');
                        })
                    ])
                    .execute(null, (error) => {
                        try {
                            if (!error) return done(new Error('Expect error to be "Any error" but was undefined'));
                            assert.equal(error.message, 'Any error');
                            assert.equal(spy.callCount, 1);
                            return done();
                        } catch (assertationError) {
                            return done(assertationError);
                        }
                    });
            });

            it('should provide correct async error on error in metadata factory', (done) => {
                let techServiceXmlAst = null;

                const sourceFile = __dirname + '/../../resources/gw-tea-tec-metadata.xml';
                const spy = sinon.spy();

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy((input, callback) => {
                            const fullMetadataXml = fs.readFileSync(sourceFile);
                            const ast = xmljs.xml2json(fullMetadataXml, { compact: false });
                            techServiceXmlAst = JSON.parse(ast);
                            callback(null, techServiceXmlAst);
                        }),
                        MetadataConverter.createOdataV4MetadataXmlToOdataV4CsdlStrategy()
                            .setLogger(logger)
                            .setMetadataFactory((path, callback) => {
                                spy();
                                callback(new Error('Error in metadata factory'));
                            })
                    ])
                    .execute(null, (error) => {
                        try {
                            if (error == null) {
                                return done(
                                    new Error('Expect error to be "Error in metadata factory" but was undefined')
                                );
                            }
                            assert.equal(error.message, 'Error in metadata factory');
                            assert.equal(spy.callCount, 1);
                            return done();
                        } catch (assertationError) {
                            return done(assertationError);
                        }
                    });
            });

            it('should provide correct error with missing metadata factory', (done) => {
                let techServiceXmlAst = null;

                const sourceFile = __dirname + '/../../resources/gw-tea-tec-metadata.xml';
                const spy = sinon.spy();

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy((input, callback) => {
                            const fullMetadataXml = fs.readFileSync(sourceFile);
                            const ast = xmljs.xml2json(fullMetadataXml, { compact: false });
                            techServiceXmlAst = JSON.parse(ast);
                            spy();
                            callback(null, techServiceXmlAst);
                        }),
                        MetadataConverter.createOdataV4MetadataXmlToOdataV4CsdlStrategy()
                    ])
                    .execute(null, (error) => {
                        try {
                            if (error == null) {
                                return done(
                                    new Error('Expect error to be "Error in metadata factory" but was undefined')
                                );
                            }

                            const message = 'No metadata factory provided. Can not resolve' +
                                " 'Org.OData.Core.V1.OptimisticConcurrency'. Please add one via" +
                                ' Strategy.setMetadataFactory(function(type, callback){})';
                            assert.equal(error.message, message);
                            assert.equal(spy.callCount, 1);
                            return done();
                        } catch (assertationError) {
                            return done(assertationError);
                        }
                    });
            });

            it('should throw an error if included metadata was not provided', (done) => {
                let techServiceXmlAst = null;
                const sourceFile1 = __dirname + '/../../resources/full-edmx.xml';

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy((input, callback) => {
                            const fullMetadataXml = fs.readFileSync(sourceFile1);
                            const ast = xmljs.xml2json(fullMetadataXml, { compact: false });
                            techServiceXmlAst = JSON.parse(ast);
                            callback(null, techServiceXmlAst);
                        }),
                        MetadataConverter.createOdataV4MetadataXmlToOdataV4CsdlStrategy()
                            .setMetadataFactory((path, callback) => {
                                callback();
                            }),
                    ])
                    .execute(null, (conversionError) => {
                        try {
                            const message = "Metadata for 'com.odata.v4.technical.scenario.external.TermAEntityType'" +
                                ' was not provided';
                            assert.equal(conversionError.message, message);
                            done();
                        } catch (error) {
                            done(error);
                        }
                    });
            });

            it('should throw an error if included metadata does not include required type', (done) => {
                let techServiceXmlAst = null;
                const sourceFile1 = __dirname + '/../../resources/full-edmx.xml';

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy((input, callback) => {
                            const fullMetadataXml = fs.readFileSync(sourceFile1);
                            const ast = xmljs.xml2json(fullMetadataXml, { compact: false });
                            techServiceXmlAst = JSON.parse(ast);
                            callback(null, techServiceXmlAst);
                        }),
                        MetadataConverter.createOdataV4MetadataXmlToOdataV4CsdlStrategy()
                            .setMetadataFactory((path, callback) => {

                                const metadataXml = fs.readFileSync(sourceFile1);
                                const jsonAstStr = xmljs.xml2json(metadataXml, { compact: false });
                                const objectAst = JSON.parse(jsonAstStr);
                                callback(null, objectAst);
                            }),
                    ])
                    .execute(null, (conversionError) => {
                        try {
                            const message = [
                                "Could not find artifact 'com.odata.v4.technical.scenario.external.TermAEntityType'",
                                'in provided EDM Schemas',
                                "'com.odata.v4.technical.scenario,com.odata.v4.technical.scenario2'"
                            ];
                            assert.equal(conversionError.message, message.join(' '));
                            done();
                        } catch (error) {
                            done(error);
                        }
                    });
            });

            it('should convert xml to json AST', (done) => {
                const testXml = '<node><element/><element/><element/></node>';
                const expectedResult = { node: { element: [{}, {}, {}] }, testProperty: 123 };

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy((input, callback) => {
                            const ast = xmljs.xml2json(input, { compact: true });
                            callback(null, JSON.parse(ast));
                        }),
                        new MetadataConverter.Strategy((input, callback) => {
                            callback(null, Object.assign(input, { testProperty: 123 }));
                        })
                    ])
                    .execute(testXml, (conversionError, result) => {
                        try {
                            if (conversionError) done(conversionError);
                            assert.deepStrictEqual(result, expectedResult);
                            done();
                        } catch (assertationError) {
                            done(assertationError);
                        }
                    });
            });

            it('should convert /$metadata xml to csdl json', (done) => {
                let techServiceXmlAst = null;

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy((input, callback) => {
                            client.get(TestUtils.getServicePrefix() + '$metadata').end((error, response) => {
                                const ast = xmljs.xml2json(response.text, { compact: false });
                                techServiceXmlAst = JSON.parse(ast);
                                callback(error, techServiceXmlAst);
                            });
                        }),
                        MetadataConverter.createOdataV4MetadataXmlToOdataV4CsdlStrategy()
                    ])
                    .execute(null, (conversionError, generatedCsdlJson) => {
                        if (conversionError) return done(conversionError);
                        try {
                            const edmProvider = TestUtils.createEdm(undefined, generatedCsdlJson);
                            let generatedXmlMetadata = new MetadataXmlSerializer(edmProvider).serialize();

                            const generatedAst = JSON.parse(xmljs.xml2json(generatedXmlMetadata, { compact: false }));
                            assert.deepStrictEqual(generatedAst, techServiceXmlAst);

                            return done();
                        } catch (assertationError) {
                            return done(assertationError);
                        }
                    });
            });



            it('should convert full-edmx.xml metadata xml to full-edm.json', (done) => {
                const sourceFile1 = __dirname + '/../../resources/full-edmx.xml';
                const sourceFile2 = __dirname + '/../../resources/full-edmx-referenced-1.xml';
                const sourceFile3 = __dirname + '/../../resources/full-edmx-referenced-2.xml';
                const targetFileXml = __dirname + '/../../resources/full-edmx-result-metadata.xml';

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy((input, callback) => {
                            const fullMetadataXml = fs.readFileSync(sourceFile1);
                            const ast = xmljs.xml2json(fullMetadataXml, { compact: false });
                            callback(null, JSON.parse(ast));
                        }),
                        MetadataConverter.createOdataV4MetadataXmlToOdataV4CsdlStrategy()
                            .setLogger(logger)
                            .setMetadataFactory((path, callback) => {
                                let file = null;
                                if (path.startsWith('com.odata.v4.technical.scenario.external')) {
                                    file = sourceFile2;
                                }
                                if (path.startsWith('com.odata.v4.technical.scenario.external2')) {
                                    file = sourceFile3;
                                }
                                if (file) {
                                    const metadataXml = fs.readFileSync(file);
                                    const jsonAstStr = xmljs.xml2json(metadataXml, { compact: false });
                                    const objectAst = JSON.parse(jsonAstStr);
                                    callback(null, objectAst);
                                } else {
                                    callback(new Error('External ' + path + ' not found'));
                                }
                            }),
                    ])
                    .execute(null, (conversionError, generatedCsdlJson) => {
                        if (conversionError) return done(conversionError);
                        try {

                            const edmProvider = TestUtils.createEdm(undefined, generatedCsdlJson);
                            const generatedMetadata = new MetadataXmlSerializer(edmProvider).serialize();
                            const expectedResult = fs.readFileSync(targetFileXml).toString();

                            assert.equal(
                                JSON.stringify(generatedMetadata),
                                JSON.stringify(expectedResult)
                            );

                            return done();
                        } catch (assertationError) {
                            return done(assertationError);
                        }
                    });
            });

            it('should convert Org.OData.Core.V1.xml csdl json', (done) => {

                const sourceFile = __dirname + '/../../resources/Org.OData.Core.V1.xml';
                const targetFile = __dirname + '/../../resources/Org.OData.Core.V1-result-metadata.xml';

                new MetadataConverter()
                    .addConversion([
                        new MetadataConverter.Strategy((input, callback) => {
                            const fullMetadataXml = fs.readFileSync(sourceFile);
                            const ast = xmljs.xml2json(fullMetadataXml, { compact: false });
                            callback(null, JSON.parse(ast));
                        }),
                        MetadataConverter.createOdataV4MetadataXmlToOdataV4CsdlStrategy(),
                    ])
                    .execute(null, (conversionError, generatedCsdlJson) => {
                        if (conversionError) return done(conversionError);
                        try {
                            const edmProvider = TestUtils.createEdm(undefined, generatedCsdlJson);
                            const generatedMetadata = new MetadataXmlSerializer(edmProvider).serialize();

                            const expectedResult = fs.readFileSync(targetFile).toString();

                            assert.equal(
                                JSON.stringify(generatedMetadata),
                                JSON.stringify(expectedResult)
                            );

                            return done();
                        } catch (assertationError) {
                            return done(assertationError);
                        }
                    });
            });

        });

    });

});
