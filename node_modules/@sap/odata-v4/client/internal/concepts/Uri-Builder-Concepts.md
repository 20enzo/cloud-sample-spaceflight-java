# Uri Builder Variants

## Validation

* Shall ABNF and/or EDM validation be optional for the client, as the server will validate the odata-url?
* ABNF Validation
    * per API -> only valid segments are allowed.
        * Example for top level:
        ```javascript
        const uri = new UriBuilder()
                .function()
                .singleton()
                .entityset()
                    .key()
                        .navigation()
                        .property()
                    .count()
                    .ref()
        ```
    * implicit when calling .build()
* EDM Validation
    * per (generated) API
        * Example:
        ```javascript
        const uri = new UriBuilder().Categories(1).Products(1).Price()
        ```
    * by providing constants
        * Example:
        ```javascript
        const EntitySets = { PRODUCTS: 'Products', CATEGORIES: 'Categories' };
        const Product = { NAME: 'Name', PRICE: 'Price', ID: 'Id'};

        const uri = new UriBuilder()
            .entityset(EntitySets.CATEGORIES)
            .navigate(EntitySets.PRODUCTS)
            .property(Product.PRICE)
        ```
    * implicit when calling .build()
        * Check each input against the edm model


## 1. UriFormatter + Utils

* Proper percent-encoding
* Utility methods to format uri literals. For example for Odata v2:
   * Edm.DateTime `datetime'yyyy-mm-ddThh:mm[:ss[.fffffff]]'` e.g. `datetime'2018-05-15T11:12'`
   * Edm.Decimal `[0-9]+.[0-9]+M|m` e.g.`1.234M`
* Cons:
   * An application developer requires (deeper) OData knowledge
   * Might be required to parse/split the uri to encode relevant parts -> lowers performance

## 2a. Fluent API

* A fluent API that allows to build the uri string
* One UriBuilder class that always returns itself to build a resource-path (+ probably the query-options)
* Example:
    ```javascript
    const uri = new UriBuilder(v2|v4)
        .entityset('EntitySet')
        .keys(32767)
        .navigate('NavigationToMany')
        .keys(32767)
        .property('ComplexProperty')
        .property('PrimitiveProperty')
        .value()
        .build();
    ```
* Cons:
    * No guarentee, that the uri is a valid odata uri, as the api does not follow abnf rules
* Pros:
    * Easier api design and architecture

## 2b. Fluent Guided API

* A fluent api that only allows to build valid OData uris.
* UriBuilder is separated in different classes, that only allow certain path segments to follow.
* Example:
    ```javascript
    const uri = new UriBuilder()
        .function()
        .singleton()
        .entityset()
            .key()
                .navigation()
                .property()
            .count()
            .ref()
    ```
* Cons:
    * More complex api, architecture and documentation
* Pros:
    * Only syntactically correct urls can be produced

## 2c. Model specific (generated) API

* A fluent API that provides methods for the specific EDM
* Example:
    ```javascript
    const uri = new UriBuilder()
        .Sales()
        .SalesOrderItem()
    ```


## 3. Uri From UriInfo

* Provide an UriInfo Object that gets serialized to the request uri
* E.g. for mashup scenarios

## 4a. SQL/CQL String to OData

* Use an SQL/CQL String that gets translated to an OData url
* Example:
    ```
    SELECT SalesOrderItems.ItemID, SalesOrderItems.Amount, SalesOrders.*
        FROM SalesOrders
        JOIN SalesOrderItems
        WHERE SalesOrderItems.Amount gt 1000
    ```

## 4b. SQL/CQL Builder

* Reuse a sql-builder api
* Example:
    ```javascript
    builder.select('SalesOrderItems.ItemID', 'SalesOrderItems.Amount', 'SalesOrders.*')
        .from('SalesOrder')
        .join('SalesOrderItems')
        .where('SalesOrderItems.Amount gt 1000')
        .build()
    ```

# Example Uri(s)

* ### Entityset with expand, select in the expand and a filter
    * v4-Uri: `SalesOrders?$expand=SalesOrderItems($select=SalesOrderItemId,Amount)&$filter=Amount gt 1000`
    * v2-Uri: `SalesOrders?$expand=SalesOrderItems&$filter=Amount gt 1000&$select=SalesOrderItems/SalesOrderItemId,SalesOrderItems/Amount`
    * 2a: fluent api:
        ```javascript
        new UriBuilder()
            .entityset('SalesOrder')
            .expand('SalesOrderItems',
                q.select('SalesOrderItemId', 'Amount')
            )
            .filter(f.gt('Amount', 1000))
            .build();
        ```
    * alternative:
        ```javascript
        new UriBuilder()
            .entityset('SalesOrder')
            .expand('SalesOrderItems')
                .select('SalesOrderItemId', 'Amount')
                .up()
            .filter(f.gt('Amount', 1000))
            .build();
        ```
    * generated api:
        ```javascript
        new UriBuilder()
            .SalesOrder()
            .expandSalesOrderItem()
                .selectSalesOrderIdemId()
                .selectAmount()
                .up()
            .filter(f.gt(SalesOrderItem.AMOUNT, 1000))
            .build();
        ```
* ### Multiple Navigation and Property Request
    * v4&v2-Uri: `SalesOrders(SoId=123)/SalesOrderItems(SalesOrderId=123,SalesOrderItemId=1)/Product/Price`
    * fluent api:
        ```javascript
        new UriBuilder()
            .entityset('SalesOrders').keys(123)
            .navigate('SalesOrderItems').keys({ SalesOrderId: 123, SalesOrderItemId: 1 })
            .navigate('Products')
            .property('Price')
            .build();
        ```
    * generated api:
        ```javascript
        new UriBuilder()
            .SalesOrder(123)
            .SalesOrderItems({SalesOrderId: 123, SalesOrderItemId: 1})
            .Product()
            .Price()
            .build();
        ```
* ### Multilevel-Expand and select within expand
    * v4: `SalesOrders?$expand=SalesOrderItems($expand=Product($select=Name,Price))`
    * v2: `SalesOrders?$expand=SalesOrderItems/Product&$select=SalesOrderItems/Products/Name,SalesOrderItems/Products/Price`
    * fluent api:
        ```javascript
        new UriBuilder()
            .entityset('SalesOrder')
            .expand('SalesOrderItems', a => a
                .expand('Product', b => b
                    .select('Name', 'Price')
                )
            )
            .build()
        ```
    * alternative:
        ```javascript
        new UriBuilder()
            .entityset('SalesOrder')
            .expand('SalesOrderItems')
                .expand('Product')
                    .select('Name', 'Price')
                    .up()
                .up()
            .build()
        ```
    * generated api:
        ```javascript
        new UriBuilder()
            .SalesOrder()
            .expandSalesOrderItem(a => a
                .expandProduct(b => b
                    .selectName()
                    .selectPrice()
                )
            )
            .build()
        ```
# Constant Generation

* Input: Edm (File)
* Output: JSON (File)
* Convert per API/CLI
* Example:
  ````javascript
  const constants = {
    ENTITYSETS: {
      ESALLPRIM: 'ESAllPrim'
    },
    ENTITYSET_PROPERTIES: {
      ESALLPRIM: {
        PROPERTYINT16: 'PropertyInt16',
        PROPERTYSTRING: 'PropertyString'
      }
    }
  }
  ````