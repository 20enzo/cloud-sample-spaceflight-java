# Metadata converter

The MetadataConverter converts Odata 4.0 XML-CSDL-Metadata documents into Odata 4.0 JSON-CSDL-Metadata format.
This converter is able to 
- Convert all type artifacts (EntityTypes, ComplexTypes, TypeDefinitions, Enumerations, etc...)
- convert all data artifacts (EntitySet, Singelton, etc...)
- convert Functions, BoundFunctions, Actions, BoundActions
- convert and resolve internal and external annotations with all expressions
- resolve external Types via external documents
- determine default value types and convert the value type specific
- This converter can also detect deferred types and values ​​if they are available later when parsing
- provide an API to resolve external documents
- provide an API to convert arbitrary abstract syntax tree node into expected structure
- provide a flexible API to enhance/exchange functionality
- lookup and assert XML namespaces to exclude non-Odata nodes
- provide an appropriate error handling

## Usage

### Create a simple Converter instance using the MetadataConverterFactory

A simple Converter instance can be created using the following code.
A simple converter instance is not able to:
- resolve external artifacts or referenced documents
- resolve annotations without expressions where the corresponding term is in an external document

Example:

```js
const MetadataConverterFactory = require('client/index').MetadataConverterFactory;

// Read the metadata xml document.
const metadataXml = readMetadataXmlSomeHow();

// Convert the xml document to the corresponding json csdl object.
MetadataConverterFactory
    .create()
    .execute(metadataXml, (error, result) => {
        // process error / result
    });
```

### Create a Converter instance with additional features

To interpret more complex metadata xml documents (with referenced documents, annotations without
expressions, etc.) you have to provide a second parameter with additional options.
Every option is optional and can be omitted.

```js
const MetadataConverterFactory = require('client/index').MetadataConverterFactory

// Read the metadata xml document.
const metadataXml = readMetadataXmlSomeHow();


const options = {

    // Resolve external/depended metadata documents.
    // This factory is called when a type artifact is needed which does not exist
    // in the current interpreted document. This method can be called more than once
    // and depends on the dependency structure of the source document.

    // Param: 'typeFqn'
    // The 'typeFqn' parameter is a String representing the full qualified name
    // of the missing type.
    // I.e: 'com.any.namespace.AnyArtifactType'.
    
    // Param: callback
    // The callback has to be called with the AST representation of the
    // external document. The callback has the signature: callback(error, result).
    metadataFactory: (typeFqn, callback) => {
        readExternalMetadataXmlSomwHow(typeFqn, (error, metadataXml) => {
            const metadataAst = MetadataConverterFactory.createAbstractSyntaxTree(metadataXml);
            callback(error, metadataAst);
        });
    },

    // Optional, can be omitted.
    logger: { path() { }, info() { }, warn() { }, debug() { } }, 

    // Optional, if the 'MetadataConverterFactory.createAbstractSyntaxTree(xmlString)' is used.
    nodeBuilder: (element) => return element;

    // Optional, The converter does not parse ignoring nodes (must be prefixed with the corresponding odata xml namespace)
    ignore: ['http://docs.oasis-open.org/odata/ns/edm:Annotation'],

    // If you provide your own abstract syntax tree factory, you can provide here.
    // If no factory is provided, a default implementation is used.
    astFactory: (metadataString) => {
        return MetadataConverterFactory.createAbstractSyntaxTree(metadataString);
    }
    
};

MetadataConverterFactory
    // By provided 'undefined' as the first paramter, you force the factory to create a
    // odata v4.0 xml csdl to odata v4.0 json csdl converter.
    // If you want to explicit select a converter you can call the create method:
    // .create('v4.0:xml -> v4.0:json', options)
    .create(undefined, options)
    .execute(metadataXml, (error, generatedJsonCsdl) => {
        // process error / result
    });

```

#### Using the node builder factory

To use any kind of an AST you have to provide a node builder factory. The implementation
of the converter expects the following structure of each and every node inside the 
AST (including the root node):

```js
{
    // The node name like 'Annotation' for <Annotation>...</Annotation> nodes.
    // The name property MUST be a string and MUST not be null.
    name: 'The name of the element node without <>',

    // If the node is a text node and does not have a child elements.
    text: 'A possible text value of this node'

    // Attributes of a node like '<Annotation Term="AnyTerm" AnotherAttribute="...">...<Annotation>'.
    // The attributes property MUST be an object and MUST not be null.
    attributes: {

        // Attribute key-value pairs including namespaces like xmlns="A.namespace".
        Term: 'A Term full qualified name value',
        AnotherAttribute: '...',
    },

    // Child elements with containing nodes. The elements property MUST be an array and
    // MUST not be null.
    elements: [
        { name: '...', attributes: {...}, elements: [...] },
        ...
    ]
}
```

Here is an example how a Browser DOM can be used to structure each AST node element:

```js
{
    nodeBuilder: (element) => {
        const node = {
            elements: [],
            name: element.nodeName,
            attributes: {}
        };

        if (element.attributes) {
            Array.from(element.attributes).forEach((attribute) => {
                node.attributes[attribute.nodeName] = attribute.nodeValue;
            })
        }

        element.childNodes.forEach((childNode) => {
            if (childNode.nodeName === '#text') {
                childNode.text = childNode.nodeValue;
            }
            node.elements.push(childNode);
        });

        return node;
    }
}
```

