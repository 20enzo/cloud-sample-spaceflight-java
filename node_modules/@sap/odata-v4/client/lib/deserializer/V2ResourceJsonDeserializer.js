'use strict';

// Require ModuleCache first because of cyclic dependencies.
require('../../../lib/ModuleCache');
const ValueConverter = require('../../../lib/utils/ValueConverter');
const ValueValidator = require('../../../lib/validator/ValueValidator');
const JsonContentTypeInfo = require('../../../lib/format/JsonContentTypeInfo');
const JsonFormat = require('../../../lib/format/JsonFormat');
const EdmTypeKind = require('../../../lib/edm/EdmType').TypeKind;
const EdmPrimitiveTypeKind = require('../../../lib/edm/EdmPrimitiveTypeKind');
const DeserializationError = require('../../../lib/errors/DeserializationError');

const DATE_TIME_OFFSET_REGEXP = new RegExp('^/Date\\((-?\\d{1,15})(?:(\\+|-)(\\d{4}))?\\)/$');
const TIME_OF_DAY_REGEXP = new RegExp('^PT(?:(\\d{1,2})H)?(?:(\\d{1,4})M)?(?:(\\d{1,5})(\\.\\d+)?S)?$');
const DOUBLE_REGEXP = new RegExp('^-?(?:\\d{1,17}|\\d\\.\\d{1,16}(?:[Ee]-?\\d{1,3})?)$');

/**
 * This class converts a provided OData Version 2 payload into a JavaScript object,
 * using OData Version 4 metadata to parse and validate the data.
 * It assumes that V2 Edm.DateTime properties are mapped to V4 Edm.DateTimeOffset properties
 * and that V2 Edm.Time properties are mapped to V4 Edm.TimeOfDay properties.
 */
class V2ResourceJsonDeserializer {

    /** Creates an instance of V2ResourceJsonDeserializer. */
    constructor() {
        this._valueValidator = new ValueValidator();
        this._converter = new ValueConverter(this._valueValidator,
            new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true'));
    }

    /**
     * Deserializes a provided JSON payload string of an entity.
     * @param {EdmType} edmType the edm type of the entity
     * @param {string} value the JSON data string to deserialize
     * @returns {Object} the deserialized result
     * @throws {DeserializationError} if provided data can not be deserialized
     */
    deserializeEntity(edmType, value) {
        try {
            return { value: this._deserializeStructuralType(edmType, this._parse(value)) };
        } catch (e) {
            if (e instanceof DeserializationError) throw e;
            throw new DeserializationError('An error occurred during deserialization of the entity.', e);
        }
    }

    /**
     * Deserializes a provided JSON payload string of an entity collection.
     * @param {EdmType} edmType the EDM type of the entity collection
     * @param {string} value the JSON data string to deserialize
     * @returns {Object[]} the deserialized result
     * @throws {DeserializationError} if provided data can not be deserialized
     */
    deserializeEntityCollection(edmType, value) {
        const collectionValue = this._parse(value);
        if (collectionValue === null || typeof collectionValue !== 'object') {
            throw new DeserializationError('Value for the collection must be an object.');
        }
        try {
            return this._deserializeEntityCollection(edmType, collectionValue);
        } catch (e) {
            if (e instanceof DeserializationError) throw e;
            throw new DeserializationError('An error occurred during deserialization of the collection.', e);
        }
    }

    /**
     * Deserializes a provided JSON payload string of a complex property.
     * @param {EdmProperty} edmProperty the EDM property
     * @param {string} propertyValue the JSON data string to deserialize
     * @returns {Object} the deserialized result
     * @throws {DeserializationError} if provided data can not be deserialized
     */
    deserializeComplexProperty(edmProperty, value) {
        return this._deserializeProperty(edmProperty, value);
    }

    /**
     * Deserializes a provided JSON payload string of a primitive property.
     * @param {EdmProperty} edmProperty the EDM property
     * @param {string} value the JSON data string to deserialize
     * @returns {number|string|boolean|Buffer} the deserialized result
     * @throws {DeserializationError} if provided data can not be deserialized
     */
    deserializePrimitiveProperty(edmProperty, value) {
        return this._deserializeProperty(edmProperty, value);
    }

    /**
     * Deserializes a provided JSON payload string of a property.
     * @param {EdmProperty} edmProperty the EDM property
     * @param {string} value the JSON data string to deserialize
     * @returns {number|string|boolean|Buffer|Object} the deserialized result
     * @throws {DeserializationError} if provided data can not be deserialized
     * @private
     */
    _deserializeProperty(edmProperty, value) {
        let propertyValue = this._parse(value);
        if (propertyValue === null || typeof propertyValue !== 'object') {
            throw new DeserializationError('Value for property must be an object.');
        }
        const propertyNames = Object.getOwnPropertyNames(propertyValue);
        if (propertyNames.length !== 1 || propertyNames[0] !== edmProperty.getName()) {
            throw new DeserializationError(`Only '${edmProperty.getName()}' is allowed in property value.`);
        }
        propertyValue = propertyValue[edmProperty.getName()];
        try {
            return {
                value: edmProperty.getType().getKind() === EdmTypeKind.COMPLEX ?
                    this._deserializeComplex(edmProperty, propertyValue) :
                    this._convertPrimitiveValue(edmProperty, propertyValue)
            };
        } catch (e) {
            if (e instanceof DeserializationError) throw e;
            throw new DeserializationError('An error occurred during deserialization of the property.', e);
        }
    }

    /**
     * Parses the data with JSON.parse(...) and removes the optional "d" wrapper.
     * @param {string} data the value to parse
     * @returns {Object|Array|number|boolean|string} the parsed value or data
     * @private
     */
    _parse(data) {
        let result = JSON.parse(data);
        const propertyNames = Object.getOwnPropertyNames(result);
        if (propertyNames.length === 1 && propertyNames[0] === 'd') result = result.d;
        return result;
    }

    /**
     * Deserializes a structural value with properties.
     * @param {EdmType} edmType the edm type of the provided value
     * @param {Object} value the structural object to deserialize
     * @returns {Object} the deserialized result
     * @throws {DeserializationError} if provided data can not be deserialized
     * @private
     */
    _deserializeStructuralType(edmType, value) {
        if (value === null || typeof value !== 'object') {
            throw new DeserializationError('Value for structural property must be an object.');
        }

        const propertyNames = Object.keys(value);
        if (propertyNames.length === 0) {
            throw new DeserializationError(`Value for type '${edmType.getFullQualifiedName()}' has no properties.`);
        }

        let result = {};
        for (const propertyName of propertyNames) {
            const propertyValue = value[propertyName];

            if (propertyName === '__metadata') {
                for (const metaInformation of Object.keys(propertyValue)) {
                    if (typeof propertyValue[metaInformation] !== 'string') {
                        throw new DeserializationError("Malformed metadata information '" + metaInformation + "'.");
                    }
                    if (metaInformation === 'id') continue;  // "id" is not in the OData V2 standard.
                    const tags = ['uri', 'type', 'etag', 'edit_media', 'media_src', 'media_etag', 'content_type'];
                    if (!tags.includes(metaInformation)) {
                        throw new DeserializationError("Unknown metadata tag '" + metaInformation + "'. "
                            + "Only '" + tags.join("', '") + "' are allowed.");
                    }
                }
                if (propertyValue.id && !propertyValue.uri) result[JsonFormat.MetaProperties.ID] = propertyValue.id;
                if (propertyValue.uri) result[JsonFormat.MetaProperties.ID] = propertyValue.uri;
                if (propertyValue.type) result[JsonFormat.MetaProperties.TYPE] = propertyValue.type;
                if (propertyValue.etag) {
                    if (propertyValue.etag.startsWith('W/"') && propertyValue.etag.endsWith('"')
                        && this._valueValidator.validateEtagValue(propertyValue.etag.slice(3, -1))) {
                        result[JsonFormat.MetaProperties.ETAG] = propertyValue.etag.slice(3, -1);
                    } else {
                        throw new DeserializationError("Malformed ETag value '" + propertyValue.etag + "'.");
                    }
                }
                if (propertyValue.edit_media) result['*@odata.mediaEditLink'] = propertyValue.edit_media;
                if (propertyValue.media_src) result['*@odata.mediaReadLink'] = propertyValue.media_src;
                if (propertyValue.media_etag) {
                    if (propertyValue.media_etag.startsWith('W/"') && propertyValue.media_etag.endsWith('"')
                        && this._valueValidator.validateEtagValue(propertyValue.media_etag.slice(3, -1))) {
                        result['*@odata.mediaEtag'] = propertyValue.media_etag.slice(3, -1);
                    } else {
                        throw new DeserializationError(
                            "Malformed media ETag value '" + propertyValue.media_etag + "'.");
                    }
                }
                if (propertyValue.content_type) {
                    result[JsonFormat.MetaProperties.MEDIA_CONTENT_TYPE] = propertyValue.content_type;
                }
                continue;
            }

            const edmProperty = edmType.getProperty(propertyName);
            if (!edmProperty) {
                throw new DeserializationError(
                    `'${propertyName}' does not exist in type '${edmType.getFullQualifiedName()}'.`);
            }

            if (edmProperty.getEntityType) {
                const expanded = this._deserializeNavigation(edmProperty, propertyValue);
                if (expanded) result[propertyName] = expanded;
            } else {
                result[propertyName] = edmProperty.getType().getKind() === EdmTypeKind.COMPLEX ?
                    this._deserializeComplex(edmProperty, propertyValue) :
                    this._convertPrimitiveValue(edmProperty, propertyValue);
            }
        }
        return result;
    }

    /**
     * Deserializes an entity collection.
     * @param {EdmType} edmType the EDM type of the entity collection
     * @param {Object} value the entity collection to deserialize
     * @returns {Object} the deserialized result
     * @throws {DeserializationError} if provided data can not be deserialized
     * @private
     */
    _deserializeEntityCollection(edmType, value) {
        let result = {};
        for (const propertyName of Object.getOwnPropertyNames(value)) {
            switch (propertyName) {
                case 'results':
                    continue;
                case '__count':
                    result[JsonFormat.MetaProperties.COUNT] = Number(this._converter.convertInt64(value[propertyName]));
                    break;
                case '__next':
                    result[JsonFormat.MetaProperties.NEXT_LINK] = value[propertyName];
                    break;
                default:
                    throw new DeserializationError(
                        "Only 'results', '__count', and '__next' are allowed in the collection value.");
            }
        }
        const entities = value.results;
        if (!Array.isArray(entities)) {
            throw new DeserializationError(`Input must be a collection of type '${edmType.getFullQualifiedName()}'.`);
        }
        result.value = entities.map(entityValue => this._deserializeStructuralType(edmType, entityValue));
        return result;
    }

    /**
     * Deserialize a navigation property.
     * @param {EdmNavigationPropery} edmProperty the navigation property to deserialize
     * @param {Object} value the value of the navigation property
     * @returns {?Object} the deserialized navigation property
     * @private
     */
    _deserializeNavigation(edmProperty, value) {
        if (value === null || typeof value !== 'object') {
            throw new DeserializationError('Value for navigation property must be an object.');
        }
        if (value.__deferred) return null;
        return edmProperty.isCollection() ?
            this._deserializeEntityCollection(edmProperty.getEntityType(), value).value :
            this._deserializeStructuralType(edmProperty.getEntityType(), value);
    }

    /**
     * Deserializes a complex value.
     * @param {EdmProperty} edmProperty the EDM property of this complex value
     * @param {Object} propertyValue the JSON value
     * @returns {Object|Object[]} the deserialized result
     * @throws {DeserializationError} if provided data can not be deserialized
     * @private
     */
    _deserializeComplex(edmProperty, propertyValue) {
        this._assertPropertyNullable(edmProperty, propertyValue);
        return propertyValue === null ? null : this._deserializeStructuralType(edmProperty.getType(), propertyValue);
    }

    /**
     * Asserts that the provided EDM property is nullable if it has a null value.
     * @param {EdmProperty|EdmNavigationProperty} edmProperty the EDM property to check
     * @param {*} propertyValue the value of the property
     * @throws {DeserializationError} if null is not allowed
     * @private
     */
    _assertPropertyNullable(edmProperty, propertyValue) {
        if (propertyValue === null && !edmProperty.isNullable()) {
            throw new DeserializationError(
                `The property '${edmProperty.getName()}' is not nullable and must not have a null value.`);
        }
    }

    /**
     * Converts a provided value into the appropriate OData value.
     * Available facets are taken into account. If the property's
     * facet nullable=true the value is allowed to be null.
     * @param {EdmProperty} edmProperty the corresponding EDM property
     * @param {?(number|string|boolean)} propertyValue the JSON value of the primitive
     * @returns {?(number|string|boolean|Buffer)} the primitive javascript value
     * @throws {DeserializationError} if the conversion was not successful
     * @private
     */
    _convertPrimitiveValue(edmProperty, propertyValue) {
        if (propertyValue === undefined) {
            throw new DeserializationError(`Missing value for property '${edmProperty.getName()}'.`);
        }
        this._assertPropertyNullable(edmProperty, propertyValue);
        if (propertyValue === null) return null;

        const type = edmProperty.getType();
        if (type === EdmPrimitiveTypeKind.Binary) {
            const valueBuffer = Buffer.from(propertyValue, 'base64');
            this._converter.convert(edmProperty, valueBuffer);  // to check the MaxLength facet
            // The method Buffer.from(...) does not throw an error on invalid input;
            // it simply returns the result of the conversion of the content up to the first error.
            // So we check if the length is correct, taking padding characters into account (see RFC 4648).
            let length = propertyValue.length * 3 / 4;  // Four base64 characters result in three octets.
            if (propertyValue.length % 4) {  // The length is not a multiple of four as it should be.
                length = 3 * Math.floor(propertyValue.length / 4)
                    // The remainder (due to missing padding characters) will result in one or two octets.
                    + Math.ceil((propertyValue.length % 4) / 2);
            } else {
                // Padding characters reduce the amount of expected octets.
                if (propertyValue.endsWith('==')) length--;
                if (propertyValue.endsWith('=')) length--;
            }
            if (valueBuffer.length < length) {
                throw new DeserializationError(
                    `The value for property '${edmProperty.getName()}' is not valid base64 content.`);
            }
            return valueBuffer;
        }

        let value = propertyValue;
        if (type === EdmPrimitiveTypeKind.Int64 || type === EdmPrimitiveTypeKind.Decimal) {
            if (typeof value !== 'string') {
                throw new DeserializationError('Invalid value: ' + value + '. '
                    + "A JSON string must be specified as value for property '" + edmProperty.getName() + "'.");
            }

        } else if (type === EdmPrimitiveTypeKind.DateTimeOffset) {
            const match = DATE_TIME_OFFSET_REGEXP.exec(propertyValue);
            if (!match) {
                throw new DeserializationError(
                    'Invalid value ' + propertyValue + ' for property ' + edmProperty.getName());
            }
            value = new Date(0);
            value.setUTCMilliseconds(parseInt(match[1], 10));
            value = value.toISOString().replace(new RegExp('\\.?0*Z'), '');
            if (match[2]) {
                const offsetMinutes = parseInt(match[3], 10);
                value += match[2]
                    + Math.trunc(offsetMinutes / 600) + Math.trunc((offsetMinutes % 600) / 60) + ':'
                    + Math.trunc((offsetMinutes % 60) / 10) + offsetMinutes % 10;
            } else {
                value += 'Z';
            }

        } else if (type === EdmPrimitiveTypeKind.TimeOfDay) {
            const match = TIME_OF_DAY_REGEXP.exec(propertyValue);
            if (!match) {
                throw new DeserializationError(
                    'Invalid value ' + propertyValue + ' for property ' + edmProperty.getName());
            }
            value = new Date(0);
            value.setUTCMilliseconds(
                (match[1] ? parseInt(match[1], 10) : 0) * 3600000
                + (match[2] ? parseInt(match[2], 10) : 0) * 60000
                + (match[3] ? parseInt(match[3], 10) : 0) * 1000);
            // Remove '1970-01-01T' from the front and '.000Z' from the end; add fractional seconds.
            value = value.toISOString().substr(11, 8) + (match[4] || '');

        } else if (type === EdmPrimitiveTypeKind.Single || type === EdmPrimitiveTypeKind.Double) {
            if (typeof value !== 'string') {
                throw new DeserializationError('Invalid value: ' + value + '. '
                    + "A JSON string must be specified as value for property '" + edmProperty.getName() + "'.");
            }
            if (value === 'INF') return Number.POSITIVE_INFINITY;
            if (value === '-INF') return Number.NEGATIVE_INFINITY;
            if (value === 'Nan') return Number.NaN;
            if (!DOUBLE_REGEXP.test(value)) {
                throw new DeserializationError('Invalid value ' + value + ' for property ' + edmProperty.getName());
            }
            value = Number(value);
        }

        // The value converter also asserts maxLength, scale, precision facets.
        return this._converter.convert(edmProperty, value);
    }
}

module.exports = V2ResourceJsonDeserializer;
