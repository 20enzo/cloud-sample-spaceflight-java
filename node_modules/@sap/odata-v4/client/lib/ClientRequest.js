const EventEmitter = require('events').EventEmitter;
const ServerResponse = require('./ServerResponse');
const State = require('./States').State;
const InProgressState = require('./States').InProgressState;
const FinishedState = require('./States').FinishedState;
const ErrorState = require('./States').ErrorState;
const url = require('url');
const http = require('http');
const https = require('https');
const ClientFormatManager = require('./ClientFormatManager');


class ClientRequestInProgressState extends InProgressState {
    constructor(...args) { super(...args); }
}

class ClientRequestFinishedState extends FinishedState {
    constructor(...args) { super(...args); }
}

class ClientRequestErrorState extends ErrorState {
    constructor(...args) { super(...args); }
}

class ClientRequestInitialState extends State {
    constructor(request, options) {
        super();
        this._request = request;
        this._options = options;
    }

    execute() {
        const odataRequest = this._request;
        const finalOptions = this._options;
        const methodToLower = finalOptions.method.toLowerCase();
        const formatManager = odataRequest.getFormatManager();

        odataRequest.setState(new ClientRequestInProgressState(odataRequest));
        odataRequest.emit('debug', 'Final request options', finalOptions);

        if (['post', 'put', 'patch'].includes(methodToLower)) {
            try {
                const serializer = formatManager.getSerializer(odataRequest);
                const resultBody = serializer(finalOptions.body);
                const request = this.createOdataClientRequest(finalOptions, odataRequest);
                request.write(resultBody);
                return request.end();
            } catch (error) {
                this.createError(error, odataRequest);
            }
        } else {
            return this.createOdataClientRequest(finalOptions, odataRequest).end();
        }

        return undefined;
    }

    createOdataClientRequest(finalOptions, request) {
        return this
            .getRequestModule(finalOptions.protocol)
            .request(finalOptions, (nodeResponse) => {
                this.createOdataClientResponse(request, nodeResponse);
            })
            .on('error', (error) => {
                this.createError(error, request);
            });
    }

    createOdataClientResponse(request, response) {

        let payload = '';

        response
            .on('data', (chunk) => {
                payload += chunk.toString();
            })
            .on('error', (error) => {
                this.createError(error, request);
            })
            .on('end', () => {
                request.setState(new ClientRequestFinishedState(response));
                request.emit('debug', 'Response payload', payload);
                const odataResponse = new ServerResponse(response, payload);
                odataResponse.setFormatManager(request.getFormatManager());
                odataResponse.setRequest(request);
                request.emit('response', odataResponse);
            });

    }

    createError(error, request) {
        request.setState(new ClientRequestErrorState(error));
        request.emit('error', error);
    }

    getRequestModule(protocol) {
        return protocol.startsWith('https') ? https : http;
    }

}


class ClientRequest extends EventEmitter {

    constructor(options) {
        super();

        if (typeof options.url !== 'object') {
            throw new Error(
                "Currently only using an UriBuilder instance is allowed to define the 'url' property"
            );
        }

        this._options = options;
        this._requestOptions = null;
        this._formatManger = new ClientFormatManager();
    }



    getFormatManager() {
        return this._formatManger;
    }

    getOptions() {
        return this._options;
    }

    getRequestOptions() {
        return this._requestOptions;
    }

    setState(state) { this._state = state; return this; }

    head() {
        this._execute('HEAD');
    }

    options() {
        this._execute('OPTIONS');
    }

    get() {
        this._execute('GET');
    }

    post(data) {
        this._execute('POST', data);
    }

    put(data) {
        this._execute('PUT', data);
    }

    patch(data) {
        this._execute('PATCH', data);
    }

    delete() {
        this._execute('DELETE');
    }

    _execute(method, data) {
        try {
            const finalReqOptions = this._buildRequestOptions(this._options, method, data);
            this._state = new ClientRequestInitialState(this, finalReqOptions);
            this._requestOptions = finalReqOptions;
            this._state.execute();
        } catch (error) {
            this.emit('error', error);
        }
    }

    _buildRequestOptions(options, method = 'GET', data) {

        const _options = this._createFromUriBuilder(options, method);

        if (_options.url && _options.url.startsWith('/')) {
            _options.url = _options.url.substring(1);
        }

        if (_options.serviceRootUrl.endsWith('/')) {
            _options.serviceRootUrl = _options.serviceRootUrl.substring(-1);
        }

        const baseOptions = url.parse(options.serviceRootUrl);
        const odataUrlOptions = url.parse(options.url);

        baseOptions.path = (baseOptions.path + '/' + (odataUrlOptions.path)).replace('//', '/');

        baseOptions.headers = _options.headers;

        this._buildHeaders(baseOptions, {
            OdataVersion: options.OdataVersion,
            ContentType: options.ContentType,
            Accept: options.Accept
        });

        baseOptions.method = method;
        if (data != null) baseOptions.body = data;

        return baseOptions;

    }

    _createFromUriBuilder(options, method) {
        const _options = options;
        _options.requestRepresentationKind = options.url.getRequestRepresentationKind(method);
        _options.requestEdmType = options.url.getRequestEdmType();
        _options.responseRepresentationKind = options.url.getResponseRepresentationKind(method);
        _options.responseEdmType = options.url.getResponseEdmType();

        if (_options.edm == null) {
            _options.edm = options.url.getEdm();
        }

        if (_options.OdataVersion == null) {
            _options.OdataVersion = options.url.getOdataVersion();
        }

        _options.url = options.url.getUrl();
        return _options;
    }

    _buildHeaders(baseOptions, configHeaders) {

        const _baseOptions = baseOptions;
        if (_baseOptions.headers == null) _baseOptions.headers = {};

        return this._buildDefaultHeaders(baseOptions, configHeaders);
    }

    _buildDefaultHeaders(baseOptions, configHeaders) {
        const _baseOptions = baseOptions;

        let odataVersionHeaderName = 'DataServiceVersion';
        let odataMaxVersionHeaderName = 'MaxDataServiceVersion';

        if (_baseOptions.headers[odataVersionHeaderName] == null) {
            _baseOptions.headers[odataVersionHeaderName] = configHeaders.OdataVersion;
        }

        if (_baseOptions.headers[odataMaxVersionHeaderName] == null) {
            _baseOptions.headers[odataMaxVersionHeaderName] = configHeaders.OdataVersion;
        }

        if (_baseOptions.headers[odataVersionHeaderName] !== '2.0') {
            let message = `Header value '${_baseOptions.headers[odataVersionHeaderName]}' for`;
            message += ` '${odataVersionHeaderName}' is not supported`;
            throw new Error(message);
        }


        // Content-Type
        if (_baseOptions.headers['Content-Type'] == null) {
            if (configHeaders.ContentType == null) {
                _baseOptions.headers['Content-Type'] = 'application/json';
            } else {
                _baseOptions.headers['Content-Type'] = configHeaders.ContentType;
            }
        }

        // Accept
        if (_baseOptions.headers.Accept == null) {
            if (configHeaders.Accept == null) {
                if (_baseOptions.path.indexOf('/$metadata') > -1) {
                    _baseOptions.headers.Accept = 'application/xml';
                } else {
                    _baseOptions.headers.Accept = 'application/json';
                }
            } else {
                _baseOptions.headers.Accept = configHeaders.Accept;
            }
        }

        return _baseOptions;
    }

}

module.exports = ClientRequest;
