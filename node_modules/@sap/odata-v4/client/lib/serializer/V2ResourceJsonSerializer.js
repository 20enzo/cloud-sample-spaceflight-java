'use strict';

const validateThat = require('../../../lib/validator/ParameterValidator').validateThat;
const ValueConverter = require('../../../lib/utils/ValueConverter');
const ValueValidator = require('../../../lib/validator/ValueValidator');
const JsonContentTypeInfo = require('../../../lib/format/JsonContentTypeInfo');
const JsonFormat = require('../../../lib/format/JsonFormat');
const EdmTypeKind = require('../../../lib/edm/EdmType').TypeKind;
const EdmPrimitiveTypeKind = require('../../../lib/edm/EdmPrimitiveTypeKind');
const SerializationError = require('../../../lib/errors/SerializationError');

/**
 * This class converts provided data in a JavaScript object into an OData Version 2 payload,
 * using OData Version 4 metadata to validate the data.
 * It assumes that V2 Edm.DateTime properties are mapped to V4 Edm.DateTimeOffset properties
 * and that V2 Edm.Time properties are mapped to V4 Edm.TimeOfDay properties.
 */
class V2ResourceJsonSerializer {

    /** Creates an instance of V2ResourceJsonSerializer. */
    constructor() {
        this._valueValidator = new ValueValidator();
        this._converter = new ValueConverter(this._valueValidator,
            new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true'));
    }

    /**
     * Serializes an entity to an OData JSON string.
     * @param {EdmEntityType} edmEntityType entity type of the entity
     * @param {Object} data entity data in an JavaScript object with a "value" property
     * @returns {string} entity, serialized in OData JSON format
     */
    serializeEntity(edmEntityType, data) {
        validateThat('edmEntityType', edmEntityType).truthy().instanceOf(Object);
        validateThat('data', data).truthy().instanceOf(Object);
        validateThat('data.value', data.value).truthy().instanceOf(Object);

        try {
            const serializedEntity = this._serializeStructuredType(edmEntityType, data.value);
            return JSON.stringify(serializedEntity);
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the entity.', error);
        }
    }

    /**
     * Serializes a primitive property to an OData JSON string.
     * @param {EdmProperty} edmProperty EDM primitive-type property
     * @param {Object} data property data in an JavaScript object with a "value" property
     * @returns {string} property, serialized in OData JSON format
     */
    serializePrimitive(edmProperty, data) {
        validateThat('edmProperty', edmProperty).truthy().instanceOf(Object);
        validateThat('data', data).truthy().instanceOf(Object);

        try {
            return JSON.stringify({ [edmProperty.getName()]: this._serializeProperty(edmProperty, data.value) });
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the primitive value', error);
        }
    }

    /**
     * Serializes a complex property to an OData JSON string.
     * @param {EdmProperty} edmProperty EDM complex-type property
     * @param {Object} data property data in an JavaScript object with a "value" property
     * @returns {string} property, serialized in OData JSON format
     */
    serializeComplex(edmProperty, data) {
        validateThat('edmProperty', edmProperty).truthy().instanceOf(Object);
        validateThat('data', data).truthy().instanceOf(Object);
        if (data.value !== null) validateThat('data.value', data.value).truthy().instanceOf(Object);

        try {
            return JSON.stringify({ [edmProperty.getName()]: this._serializeProperty(edmProperty, data.value) });
        } catch (error) {
            throw new SerializationError('An error occurred during serialization of the complex value', error);
        }
    }

    /**
     * Serializes structured data.
     * @param {EdmEntityType|EdmComplexType} edmType EDM type of the data
     * @param {Object} data data, represented as a plain object with property-value pairs
     * @returns {Object} JavaScript object representing the serialized data
     * @private
     */
    _serializeStructuredType(edmType, data) {
        const structuralProperties = edmType.getProperties();
        const navigationProperties = edmType.getNavigationProperties();

        let result = {};
        for (const name of Object.keys(data)) {
            if (name.endsWith(JsonFormat.MetaProperties.BIND)) {
                const navigationPropertyName = name.substring(0, name.indexOf(JsonFormat.MetaProperties.BIND));
                const edmNavigationProperty = navigationProperties.get(navigationPropertyName);
                if (edmNavigationProperty) {
                    if (result[navigationPropertyName]) {
                        throw new SerializationError('Providing simultaneously data and bind operation for navigation '
                            + "property '" + navigationPropertyName + "' is not supported.");
                    }
                    if (edmNavigationProperty.isCollection() && Array.isArray(data[name])
                        && data[name].every(element => typeof element === 'string')) {
                        result[navigationPropertyName] = data[name].map(
                            element => { return { __metadata: { url: element } }; });
                    } else if (!edmNavigationProperty.isCollection() && typeof data[name] === 'string') {
                        result[navigationPropertyName] = { __metadata: { url: data[name] } };
                    } else {
                        throw new SerializationError('The provided data does not fit the type of the navigation '
                            + "property '" + navigationPropertyName + "'.");
                    }
                } else {
                    throw new SerializationError("The entity data contain a '" + name + "' property bind operation "
                        + "for something that is not a navigation property of the '" + edmType.getName() + "' type");
                }
            }
            if (name.includes('@')) continue;
            if (structuralProperties.has(name)) {
                result[name] = this._serializeProperty(structuralProperties.get(name), data[name]);
            } else if (navigationProperties.has(name)) {
                if (!data[name]) continue;
                if (result[name]) {
                    throw new SerializationError('Providing simultaneously data and bind operation for navigation '
                        + "property '" + name + "' is not supported.");
                }
                result[name] = this._serializeNavigationProperty(navigationProperties.get(name), data[name]);
            } else {
                throw new SerializationError("The entity data contain a '" + name + "' property which is neither a "
                    + "structural nor a navigation property of the '" + edmType.getName() + "' type");
            }
        }
        return result;
    }

    /**
     * Serializes EDM property.
     * @param {EdmProperty} edmProperty EDM property to be serialized
     * @param {*} propertyValue property value
     * @returns {*} serialized property value
     * @private
     */
    _serializeProperty(edmProperty, propertyValue) {
        if (propertyValue === null) {
            if (edmProperty.isNullable() === undefined || edmProperty.isNullable()) return null;
            throw new SerializationError(
                "The property '" + edmProperty.getName() + "' is not nullable and must not have a null value.");
        }
        return edmProperty.getType().getKind() === EdmTypeKind.COMPLEX ?
            this._serializeStructuredType(edmProperty.getType(), propertyValue) :
            this._convertPrimitiveValue(edmProperty, propertyValue);
    }

    /**
     * Converts a provided value into the appropriate OData JSON value.
     * Available facets are taken into account.
     * @param {EdmProperty} edmProperty the corresponding EDM property
     * @param {?(number|string|boolean|Buffer)} propertyValue the JavaScript value of the property
     * @returns {?(number|string|boolean)} the OData JSON value
     * @throws {SerializationError} if the conversion was not successful
     * @private
     */
    _convertPrimitiveValue(edmProperty, propertyValue) {
        let value = propertyValue;
        switch (edmProperty.getType()) {
            case EdmPrimitiveTypeKind.DateTimeOffset:
                if (typeof value !== 'string') {
                    throw new SerializationError(
                        "A JavaScript string must be specified as value for property '" + edmProperty.getName() + "'.");
                }
                this._converter.convert(edmProperty, value);  // to check the value
                return this._convertDateTimeOffsetValue(value);

            case EdmPrimitiveTypeKind.TimeOfDay:
                if (typeof value !== 'string') {
                    throw new SerializationError(
                        "A JavaScript string must be specified as value for property '" + edmProperty.getName() + "'.");
                }
                this._converter.convert(edmProperty, value);  // to check the value
                return 'PT' + value.substring(0, 2) + 'H' + value.substring(3, 5) + 'M' + value.substring(6) + 'S';

            case EdmPrimitiveTypeKind.Single:
            case EdmPrimitiveTypeKind.Double:
                if (typeof value !== 'number') {
                    throw new SerializationError(
                        "A JavaScript number must be specified as value for property '" + edmProperty.getName() + "'.");
                }
                if (value === Number.POSITIVE_INFINITY) return 'INF';
                if (value === Number.NEGATIVE_INFINITY) return '-INF';
                if (Number.isNaN(value)) return 'Nan';
                return String(this._converter.convert(edmProperty, value));

            default:
        }

        // The value converter also asserts maxLength, scale, precision facets.
        return this._converter.convert(edmProperty, value);
    }

    /**
     * Converts a date-time-offset value into the appropriate OData V2 JSON value.
     * @param {string} value the JavaScript value
     * @returns {string} the OData V2 JSON value
     * @throws {SerializationError} if the conversion was not successful
     * @private
     */
    _convertDateTimeOffsetValue(value) {
        let indexTimeZone;
        let offset;
        if (value.endsWith('Z')) {
            indexTimeZone = value.length - 1;
            offset = '';
        } else {
            indexTimeZone = value.length - 6;
            offset = Number(value.substring(value.length - 5, value.length - 3)) * 60
                + Number(value.substring(value.length - 2, value.length));
            offset = String(offset);
            while (offset.length < 4) offset = '0' + offset;
            offset = value.substring(value.length - 6, value.length - 5) + offset;
        }

        let fract = value.indexOf('.') > -1 ? value.substring(value.indexOf('.') + 1, indexTimeZone) : '0';
        while (fract.length > 3 && fract.endsWith('0')) fract = fract.substring(0, fract.length - 1);
        if (fract.length > 3) {
            throw new SerializationError("The Edm.DateTimeOffset value '" + value
                + "' has more than three digits for fractional seconds; this is not supported.");
        }
        while (fract.length < 3) fract += '0';

        return '/Date('
            + Date.UTC(value.substring(0, 4), value.substring(5, 7) - 1, value.substring(8, 10),
                value.substring(11, 13), value.substring(14, 16), value.substring(17, 19), fract)
            + offset + ')/';
    }

    /**
     * Serialize navigation property.
     * @param {EdmNavigationProperty} edmNavigationProperty the corresponding EDM navigation property
     * @param {*} data the target data
     * @returns {Object} JavaScript object representing the serialized data
     * @private
     */
    _serializeNavigationProperty(edmNavigationProperty, data) {
        if (edmNavigationProperty.isCollection() && Array.isArray(data)) {
            return data.map(entity => this._serializeStructuredType(edmNavigationProperty.getEntityType(), entity));
        }
        if (!edmNavigationProperty.isCollection() && typeof data === 'object' && !Array.isArray(data)) {
            return this._serializeStructuredType(edmNavigationProperty.getEntityType(), data);
        }
        throw new SerializationError("The provided data does not fit the type of the navigation property '"
            + edmNavigationProperty.getName() + "'.");
    }
}

module.exports = V2ResourceJsonSerializer;
