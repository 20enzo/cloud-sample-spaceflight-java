'use strict';
const AbstractValueEncoder = require('./AbstractValueEncoder');
const EdmPrimitiveTypeKind = require('../../../lib/edm/EdmPrimitiveTypeKind');
const ValueConverter = require('../../../lib/utils/ValueConverter');
const ValueValidator = require('../../../lib/validator/ValueValidator');
const JsonContentTypeInfo = require('../../../lib/format/JsonContentTypeInfo');

/**
 * The following mapping of v2 and v4 primitive types is assumed, as we internally want to work on v4 types only:
 *         v4        |        v2
 * ------------------|------------------
 *  Date             | DateTime
 *  DateTimeOffset   | DateTimeOffset
 *  Duration         | String
 *  TimeOfDay        | Time
 *
 * So for example:
 *      .encode("2017-11-30", EdmPrimitiveTypeKind.Date) will result in "/Date(1512000000000)/"
 *      .encode("23:59:59.9999999", EdmPrimitiveTypeKind.TimeOfDay) will result in "PT23H59M59.9999999S"
 */

class V2JsonLiteralEncoder extends AbstractValueEncoder {

    constructor() {
        super();
        this._validator = new ValueValidator();
        this._converter = new ValueConverter(this._validator,
            new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true'));
    }

    /**
     * @inheritDoc
     * @return {boolean|number|string|null}
     */
    encode(value, type) {
        switch (type) {
            case EdmPrimitiveTypeKind.Binary:
                return this._converter.convertBinary(value, null);
            case EdmPrimitiveTypeKind.Boolean:
                return this._converter.convertBoolean(value);
            case EdmPrimitiveTypeKind.Byte:
                return this._converter.convertByte(value);
            case EdmPrimitiveTypeKind.Decimal:
                return this._converter.convertDecimal(value);
            case EdmPrimitiveTypeKind.Double:
                return this._converter.convertDouble(value).toString();
            case EdmPrimitiveTypeKind.Guid:
                return this._converter.convertGuid(value);
            case EdmPrimitiveTypeKind.Int16:
                return this._converter.convertInt16(value);
            case EdmPrimitiveTypeKind.Int32:
                return this._converter.convertInt32(value);
            case EdmPrimitiveTypeKind.Int64:
                return this._converter.convertInt64(value);
            case EdmPrimitiveTypeKind.SByte:
                return this._converter.convertSByte(value);
            case EdmPrimitiveTypeKind.Single:
                return this._converter.convertSingle(value).toString();
            case EdmPrimitiveTypeKind.String:
                return this._converter.convertString(value);
            case EdmPrimitiveTypeKind.Date:
                return this._encodeDateTime(value);
            case EdmPrimitiveTypeKind.DateTimeOffset:
                return this._encodeDateTimeOffset(value);
            case EdmPrimitiveTypeKind.Duration:
                return this._converter.convertDuration(value);
            case EdmPrimitiveTypeKind.TimeOfDay:
                return this._encodeTimeOfDay(value);
            default:
                return value;
        }
    }

    /**
     *
     * @param {string} value v4 Edm.Date with form: "YYYY-MM-DD"
     * @return {string} v2 Edm.DateTime with form: "/Date(millis)/"
     * @private
     */
    _encodeDateTime(value) {
        this._validator.validateDate(value);
        const millis = new Date(value).getTime();
        return `/Date(${millis})/`;
    }

    /**
     *
     * @param {string} value v4 Edm.DateTimeOffset with form: "YYYY-MM-DDThh:mm:ss.s(Z|[+-]hh:mm)"
     * @return {string} v2 Edm.DateTime with form: "/Date(millis)/"
     * @private
     */
    _encodeDateTimeOffset(value) {
        this._validator.validateDateTimeOffset(value);
        const millis = new Date(value).getTime();
        return `/Date(${millis})/`;
    }

    _encodeTimeOfDay(value) {
        this._validator.validateTimeOfDay(value);
        const fragments = value.split(':');
        let time = `PT${fragments[0]}H${fragments[1]}M`;
        if (fragments.length === 3) time += `${fragments[2]}S`;
        return time;
    }
}

module.exports = V2JsonLiteralEncoder;
