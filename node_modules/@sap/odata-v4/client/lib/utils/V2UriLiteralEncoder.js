'use strict';

const AbstractValueEncoder = require('./AbstractValueEncoder');
const EdmPrimitiveTypeKind = require('../../../lib/edm/EdmPrimitiveTypeKind');
const ValueConverter = require('../../../lib/utils/ValueConverter');
const ValueValidator = require('../../../lib/validator/ValueValidator');
const JsonContentTypeInfo = require('../../../lib/format/JsonContentTypeInfo');
const V2JsonLiteralEncoder = require('./V2JsonLiteralEncoder');

/**
 * The following mapping of v2 and v4 primitive types is assumed, as we internally want to work on v4 types only:
 *         v4        |        v2
 * ------------------|------------------
 *  Date             | DateTime
 *  DateTimeOffset   | DateTimeOffset
 *  Duration         | String
 *  TimeOfDay        | Time
 *
 */

const NaNInfRegExp = /^(NaN|INF|-INF)$/;

class V2UriLiteralEncoder extends AbstractValueEncoder {

    constructor() {
        super();
        this._v2JsonEncoder = new V2JsonLiteralEncoder();
        this._converter = new ValueConverter(new ValueValidator(),
            new JsonContentTypeInfo().addParameter(JsonContentTypeInfo.FormatParameter.IEEE754, 'true'));
    }

    /**
     * @inheritDoc
     * @return {string}
     */
    encode(value, type) {
        switch (type) {
            case EdmPrimitiveTypeKind.Binary:
                return this._encodeBinary(value);
            case EdmPrimitiveTypeKind.Boolean:
                return this._v2JsonEncoder.encode(value, type).toString();
            case EdmPrimitiveTypeKind.Byte:
                return this._v2JsonEncoder.encode(value, type).toString();
            case EdmPrimitiveTypeKind.Decimal:
                return `${this._v2JsonEncoder.encode(value, type)}M`;
            case EdmPrimitiveTypeKind.Double:
                return this._encodeDouble(value);
            case EdmPrimitiveTypeKind.Guid:
                return `guid'${this._v2JsonEncoder.encode(value, type)}'`;
            case EdmPrimitiveTypeKind.Int16:
                return this._v2JsonEncoder.encode(value, type).toString();
            case EdmPrimitiveTypeKind.Int32:
                return this._v2JsonEncoder.encode(value, type).toString();
            case EdmPrimitiveTypeKind.Int64:
                return `${this._v2JsonEncoder.encode(value, type)}L`;
            case EdmPrimitiveTypeKind.SByte:
                return this._v2JsonEncoder.encode(value, type).toString();
            case EdmPrimitiveTypeKind.Single:
                return this._encodeSingle(value);
            case EdmPrimitiveTypeKind.String:
                return this._encodeString(value);
            case EdmPrimitiveTypeKind.Date:
                return `datetime'${this._converter.convertDate(value)}T00:00:00'`;
            case EdmPrimitiveTypeKind.DateTimeOffset:
                return `datetimeoffset'${this._converter.convertDateTimeOffset(value)}'`;
            case EdmPrimitiveTypeKind.TimeOfDay:
                return `time'${this._v2JsonEncoder.encode(value, type)}'`;
            case EdmPrimitiveTypeKind.Duration:
            default:
                return value;
        }
    }

    _encodeBinary(value) {
        if (!(value instanceof Buffer)) {
            throw new Error('Value for Edm.Binary must be a Buffer');
        }
        const hexString = value.toString('hex');
        return `X'${hexString}'`;
    }

    _encodeDouble(value) {
        const doubleLiteral = this._v2JsonEncoder.encode(value, EdmPrimitiveTypeKind.Double);
        return NaNInfRegExp.test(doubleLiteral) ? doubleLiteral : `${doubleLiteral}D`;
    }

    _encodeSingle(value) {
        const singleLiteral = this._v2JsonEncoder.encode(value, EdmPrimitiveTypeKind.Single);
        return NaNInfRegExp.test(singleLiteral) ? singleLiteral : `${singleLiteral}F`;
    }

    _encodeString(value) {
        const stringLiteral = this._v2JsonEncoder.encode(value, EdmPrimitiveTypeKind.String);
        return `'${encodeURIComponent(stringLiteral.replace(/'/g, "''"))}'`;
    }
}

module.exports = V2UriLiteralEncoder;
