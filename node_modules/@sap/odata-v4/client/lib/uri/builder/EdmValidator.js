'use strict';
const AbstractValidator = require('./AbstractValidator');
const ResourceKind = require('../../../../lib/uri/UriResource').ResourceKind;
const EdmTypeKind = require('../../../../lib/edm/EdmType').TypeKind;
const ParameterKind = require('./SegmentParameter').ParameterKind;
const FQN = require('../../../../lib/FullQualifiedName');

class EdmValidator extends AbstractValidator {

    /**
     * @param {Edm} edm The EntityDataModel
     */
    constructor(edm) {
        super();
        this._edm = edm;
        this._edmContainer = this._edm.getEntityContainer();
    }

    validateEnd(previousSegment) {
        if (previousSegment) this._validateRemainingProperties(previousSegment);
    }

    /**
     * @inheritDoc
     * @return {EdmType|null}
     */
    validateSegment(previousSegment, currentSegment) {
        if (previousSegment) this._validateRemainingProperties(previousSegment);

        switch (currentSegment.getKind()) {
            case ResourceKind.ACTION_IMPORT:
                return this._validateActionImport(currentSegment);
            case ResourceKind.FUNCTION_IMPORT:
                return this._validateFunctionImport(currentSegment);
            case ResourceKind.SINGLETON:
                return this._validateSingleton(currentSegment);
            case ResourceKind.ENTITY_COLLECTION:
                return this._validateEntitySet(currentSegment);
            case ResourceKind.NAVIGATION_TO_ONE:
            case ResourceKind.NAVIGATION_TO_MANY:
                this._postvalidateFunction([EdmTypeKind.ENTITY, EdmTypeKind.COMPLEX], false, previousSegment,
                    currentSegment.getName());
                return this._validateNavigationProperty(previousSegment, currentSegment);
            case ResourceKind.PRIMITIVE_PROPERTY:
            case ResourceKind.PRIMITIVE_COLLECTION_PROPERTY:
            case ResourceKind.COMPLEX_COLLECTION_PROPERTY:
            case ResourceKind.COMPLEX_PROPERTY:
                this._postvalidateFunction([EdmTypeKind.ENTITY, EdmTypeKind.COMPLEX], false, previousSegment,
                    currentSegment.getName());
                return this._validateProperty(previousSegment, currentSegment);
            case ResourceKind.BOUND_FUNCTION:
                return this._validateBoundFunction(previousSegment, currentSegment);
            case ResourceKind.BOUND_ACTION:
                this._postvalidateFunction([EdmTypeKind.ENTITY], null, previousSegment, currentSegment.getName());
                return this._validateBoundAction(previousSegment, currentSegment);
            case ResourceKind.COUNT:
                this._postvalidateFunction([EdmTypeKind.ENTITY, EdmTypeKind.COMPLEX, EdmTypeKind.PRIMITIVE],
                    true, previousSegment, currentSegment.getName());
                return null;
            default:
                return null;
        }
    }

    /**
     * @inheritDoc
     * @return {EdmType|null}
     */
    validateParameter(currentSegment, parameter) {
        if (parameter.getParameterKind() === ParameterKind.KEY_PREDICATE) {
            // Validate the previous segment only for the first time a key property is added to the segment
            if (currentSegment.getRemainingKeyParameters().size === 0) {
                this._postvalidateFunction([EdmTypeKind.ENTITY], true, currentSegment, '.key() and .compositeKey()');
            }
            return this._validateKeyParameter(currentSegment, parameter);
        } else if (parameter.getParameterKind() === ParameterKind.FUNCTION_PARAMETER) {
            return this._validateFunctionParameter(currentSegment, parameter);
        }
        return null;
    }

    /**
     * @param {SegmentInfo} currentSegment
     * @param {SegmentParameter} keyParameter
     * @return {EdmType|null}
     * @private
     */
    _validateKeyParameter(currentSegment, keyParameter) {
        const edmEntityType = currentSegment.getEdmType();
        if (currentSegment.getRemainingKeyParameters().size === 0) {
            currentSegment.setRemainingKeyParameters(edmEntityType.getKeyPropertyRefs());
        }

        const currentEntitySetName = currentSegment.getEdmBindingTarget().getName();
        const keyName = keyParameter.getName();
        const type = keyParameter.getType();

        // A key name was provided, so the api was called with .complexProperty(name, value, [type])
        if (keyName) {
            const edmKeyProperty = edmEntityType.getKeyPropertyRef(keyName);
            // No key-predicate found with the given name
            if (!edmKeyProperty) {
                throw new Error(`"${keyName}" is not a key predicate for "${currentEntitySetName}"`);
            }
            // The key-predicate with the given name is not in the list of key-predicates that must be provided
            // This is the case, if a key-predicate is declared more than once.
            if (!currentSegment.getRemainingKeyParameters().get(keyName)) {
                throw new Error(`Key predicate "${keyName}" was already set for "${currentEntitySetName}"`);
            }
            // Delete the key-predicate of the key-predicates that must be provided
            currentSegment.getRemainingKeyParameters().delete(keyName);

            // Check whether a provided type for the key matches with the one from the model
            const edmPropertyType = edmKeyProperty.getProperty().getType();
            if (type && edmPropertyType !== type) {
                throw new Error(`Provided type  "${type}" does not match with expected type "${edmPropertyType}"`);
            }
            return edmPropertyType;
        }

        // No name was provided, so the api was called with .key(value, [type])
        const edmKeyProperties = edmEntityType.getKeyPropertyRefs();
        // This is ok, if the entityType has exactly one key-predicate
        if (edmKeyProperties.size === 1) {
            // we then reset the remaining parameter list and return the type of the single key-predicate
            const edmProperty = edmKeyProperties.values().next().value.getProperty();
            const edmPropertyType = edmProperty.getType();
            if (type && edmPropertyType !== type) {
                throw new Error(`Provided type "${type}" does not match with expected type "${edmPropertyType}"`);
            }
            currentSegment.getRemainingKeyParameters().delete(edmProperty.getName());
            return edmPropertyType;
        } else if (edmKeyProperties.size > 1) {
            const keyPropertyNames = Array.from(edmKeyProperties).map(value => '"' + value[0] + '"').join(', ');
            throw new Error(`${currentEntitySetName} has a complex key with the key-predicates ${keyPropertyNames} thus`
                + ' providing the key-predicate names and values via .compositeKey(name, value, [type]) is required');
        }
        return null;
    }

    /**
     * @param {SegmentInfo} currentSegment
     * @param {SegmentParameter} functionParameter
     * @return {EdmType|null}
     * @private
     */
    _validateFunctionParameter(currentSegment, functionParameter) {

        const currentFunctionName = currentSegment.getName();
        const parameterName = functionParameter.getName();
        const parameterType = functionParameter.getType();

        if (!parameterName) {
            throw new Error('No parameter name provided');
        }

        const edmParameter = currentSegment.getEdmOperation().getParameter(parameterName);
        if (!edmParameter) {
            throw new Error(`"${parameterName}" is not a parameter for "${currentFunctionName}"`);
        }

        if (!currentSegment.getRemainingFunctionParameters().get(parameterName)) {
            throw new Error(`Parameter "${parameterName}" was already set for "${currentFunctionName}"`);
        }
        currentSegment.getRemainingFunctionParameters().delete(parameterName);

        // Check whether a provided type for the parameter matches with the one from the model
        const edmParameterType = edmParameter.getType();
        if (parameterType && edmParameterType !== parameterType) {
            throw new Error(`Provided type "${parameterType}" does not match with expected type "${edmParameterType}"`);
        }
        return edmParameterType;
    }

    /**
     * @param {SegmentInfo} segmentInformation
     * @return {EdmType|null}
     * @private
     */
    _validateEntitySet(segmentInformation) {
        const edmEntitySet = this._edmContainer.getEntitySet(segmentInformation.getName());
        if (!edmEntitySet) throw new Error(`"${segmentInformation.getName()}" is not an EntitySet`);

        segmentInformation.setEdmBindingTarget(edmEntitySet);
        segmentInformation.setIsCollection(true);
        return edmEntitySet.getEntityType();
    }

    /**
     * @param {SegmentInfo} segmentInformation
     * @return {EdmType|null}
     * @private
     */
    _validateSingleton(segmentInformation) {
        const edmSingleton = this._edmContainer.getSingleton(segmentInformation.getName());
        if (!edmSingleton) throw new Error(`"${segmentInformation.getName()}" is not a Singleton`);

        segmentInformation.setEdmBindingTarget(edmSingleton);
        segmentInformation.setEdmType(edmSingleton.getEntityType());
        segmentInformation.setIsCollection(false);
        return edmSingleton.getEntityType();
    }

    /**
     * @param {SegmentInfo} segmentInformation
     * @return {EdmType|null}
     * @private
     */
    _validateFunctionImport(segmentInformation) {
        const edmFunctionImport = this._edmContainer.getFunctionImport(segmentInformation.getName());
        if (!edmFunctionImport) throw new Error(`"${segmentInformation.getName()}" is not a FunctionImport`);

        const unboundFunctions = edmFunctionImport.getUnboundFunctions();
        if (unboundFunctions.length > 1) throw new Error('Overload functions are not supported');

        const unboundFunction = unboundFunctions[0];
        const returnedEntitySet = edmFunctionImport.getReturnedEntitySet();
        segmentInformation.setEdmBindingTarget(returnedEntitySet);
        segmentInformation.setEdmType(unboundFunction.getReturnType().getType());
        segmentInformation.setEdmOperation(unboundFunction);
        segmentInformation.setIsCollection(unboundFunction.getReturnType().isCollection());
        segmentInformation.setRemainingFunctionParameters(unboundFunction.getParameters());

        return segmentInformation.getEdmType();
    }

    /**
     * @param {SegmentInfo} currentSegment
     * @return {EdmType|null}
     * @private
     */
    _validateActionImport(currentSegment) {
        const edmActionImport = this._edmContainer.getActionImport(currentSegment.getName());
        if (!edmActionImport) throw new Error(`"${currentSegment.getName()}" is not an ActionImport`);

        const unboundAction = edmActionImport.getUnboundAction();
        const returnedEntitySet = edmActionImport.getReturnedEntitySet();
        currentSegment.setEdmBindingTarget(returnedEntitySet);
        currentSegment.setEdmType(unboundAction.getReturnType() ? unboundAction.getReturnType().getType() : null);
        currentSegment.setEdmOperation(unboundAction);
        currentSegment.setIsCollection(unboundAction.getReturnType()
            ? unboundAction.getReturnType().isCollection() : false);

        return currentSegment.getEdmType();
    }

    /**
     * @param {SegmentInfo} previousSegment
     * @param {SegmentInfo} currentSegment
     * @return {EdmType|null}
     * @private
     */
    _validateBoundFunction(previousSegment, currentSegment) {
        const functionNamespaceAndName = currentSegment.getName().split('.');
        const functionFQN = new FQN(functionNamespaceAndName[0], functionNamespaceAndName[1]);
        const edmFunctions = this._edm.getBoundFunctions(functionFQN);

        if (edmFunctions.length === 0) {
            throw new Error(`Bound function "${functionNamespaceAndName[1]}" not found in namespace `
               + `"${functionNamespaceAndName[0]}"`);
        } else if (edmFunctions.length > 1) {
            throw new Error('Function overloading is not supported. Use UriBuilder without passing the edm instead');
        }
        const boundFunction = edmFunctions[0];
        // The binding parameter is the first entry of the parameter list
        const bindingParameter = boundFunction.getParameters().values().next().value;

        // Validate that the type, the previous Segment returned matches with the one of the binding parameter
        const requiredType = bindingParameter.getType();
        const previousKind = previousSegment.getKind();
        // In case of the any Properties we have to use the underlying EdmType of the EdmProperty object
        const actualType = (previousKind === ResourceKind.COMPLEX_PROPERTY
            || previousKind === ResourceKind.COMPLEX_COLLECTION_PROPERTY
            || previousKind === ResourceKind.PRIMITIVE_PROPERTY
            || previousKind === ResourceKind.PRIMITIVE_COLLECTION_PROPERTY)
            ? previousSegment.getEdmType().getType() : previousSegment.getEdmType();
        const requiredIsCollection = bindingParameter.isCollection();
        const actualIsCollection = previousSegment.isCollection();
        if (requiredType !== actualType || requiredIsCollection !== actualIsCollection) {
            const requiredBindingParameterType = requiredIsCollection ?
                'Collection(' + requiredType.getFullQualifiedName().toString() + ')'
                : requiredType.getFullQualifiedName().toString();
            const actualBindingParameterType = actualIsCollection ?
                'Collection(' + actualType.getFullQualifiedName().toString() + ')'
                : actualType.getFullQualifiedName().toString();
            throw new Error(`BoundFunction "${functionFQN.toString()}" requires a binding parameter of type `
                + `"${requiredBindingParameterType}" instead of the provided "${actualBindingParameterType}"`);
        }

        const returnedEntitySet = boundFunction.getReturnedEntitySet(previousSegment.getEdmBindingTarget());
        currentSegment.setEdmBindingTarget(returnedEntitySet);
        currentSegment.setEdmType(boundFunction.getReturnType().getType());
        currentSegment.setEdmOperation(boundFunction);
        currentSegment.setIsCollection(boundFunction.getReturnType().isCollection());
        const remainingParameters = new Map(boundFunction.getParameters());
        remainingParameters.delete(boundFunction.getParameters().keys().next().value);
        currentSegment.setRemainingFunctionParameters(remainingParameters);
        return currentSegment.getEdmType();
    }

    /**
     * @param {SegmentInfo} previousSegment
     * @param {SegmentInfo} currentSegment
     * @return {EdmType|null}
     * @private
     */
    _validateBoundAction(previousSegment, currentSegment) {
        const previousSegmentFqn = previousSegment.getEdmType().getFullQualifiedName();
        const previousSegmentCollection = previousSegment.isCollection();
        const actionFqn = FQN.createFromNameSpaceAndName(currentSegment.getName());
        const boundAction = this._edm.getBoundAction(actionFqn, previousSegmentFqn, previousSegmentCollection);

        const bindingParameterType = previousSegmentCollection ?
            'Collection(' + previousSegmentFqn.toString() + ')' : previousSegmentFqn.toString();

        if (!boundAction) {
            throw new Error(`No boundAction found for "${currentSegment.getName()}" `
                + `with a binding parameter of type "${bindingParameterType}"`);
        }

        let returnType = null;
        let isCollection = null;
        if (boundAction.getReturnType()) {
            returnType = boundAction.getReturnType().getType();
            isCollection = boundAction.getReturnType().isCollection();
        }

        currentSegment.setEdmBindingTarget(boundAction.getReturnedEntitySet());
        currentSegment.setEdmType(returnType);
        currentSegment.setEdmOperation(boundAction);
        currentSegment.setIsCollection(isCollection);
        return returnType;
    }

    /**
     * @param {SegmentInfo} previousSegment
     * @param {SegmentInfo} currentSegment
     * @return {EdmType|null}
     * @private
     */
    _validateNavigationProperty(previousSegment, currentSegment) {
        const previousEntitySet = previousSegment.getEdmBindingTarget();
        const navigationPropertyName = currentSegment.getName();
        const isCollection = (currentSegment.getKind() === ResourceKind.NAVIGATION_TO_MANY);

        const edmNavigationProperty = previousSegment.getEdmType().getNavigationProperty(navigationPropertyName);
        if (!edmNavigationProperty) {
            throw new Error(`Navigation property "${navigationPropertyName}" not found for `
                + `entityset "${previousEntitySet.getName()}"`);
        }
        if (isCollection !== edmNavigationProperty.isCollection()) {
            throw new Error(`Navigation property "${navigationPropertyName}" `
            + (isCollection ? 'does not target a collection' : 'does target a collection'));
        }

        const edmEntitySet = previousEntitySet.getRelatedBindingTarget(navigationPropertyName);
        currentSegment.setEdmBindingTarget(edmEntitySet);
        currentSegment.setIsCollection(isCollection);
        return currentSegment.getEdmType();
    }

    /**
     * @param {SegmentInfo} previousSegment
     * @param {SegmentInfo} currentSegment
     * @return {EdmType|null}
     * @private
     */
    _validateProperty(previousSegment, currentSegment) {
        const propertyName = currentSegment.getName();
        const previousType = (previousSegment.getKind() === ResourceKind.COMPLEX_PROPERTY) ?
            previousSegment.getEdmType().getType() : previousSegment.getEdmType();
        const edmProperty = previousType.getStructuralProperty(propertyName);

        if (!edmProperty) {
            throw new Error(`Property "${propertyName}" not found for preceding type "${previousSegment.getName()}"`);
        }

        const requestedComplex = (currentSegment.getKind() === ResourceKind.COMPLEX_PROPERTY
            || currentSegment.getKind() === ResourceKind.COMPLEX_COLLECTION_PROPERTY);
        const actualComplex = (edmProperty.getType().getKind() === EdmTypeKind.COMPLEX);
        if (requestedComplex !== actualComplex) {
            throw new Error(`Property "${propertyName}" is not a "${requestedComplex ? 'Complex' : 'Primitive'}", `
                + `but "${actualComplex ? 'Complex' : 'Primitive'}" property`);
        }

        const requestedCollection = (currentSegment.getKind() === ResourceKind.PRIMITIVE_COLLECTION_PROPERTY
            || currentSegment.getKind() === ResourceKind.COMPLEX_COLLECTION_PROPERTY);

        if (requestedCollection !== edmProperty.isCollection()) {
            throw new Error(`Property "${propertyName}" is ${edmProperty.isCollection() ? '' : 'not'} a ` +
                'collection property');
        }

        currentSegment.setEdmType(edmProperty);
        currentSegment.setIsCollection(edmProperty.isCollection());
        return edmProperty;
    }

    /**
     * @private
     */
    _validateRemainingProperties(previousSegment) {
        const previousSegmentName = previousSegment.getName();

        // Validate missing function parameters
        const missedFunctionParameters = previousSegment.getRemainingFunctionParameters().size;
        if (missedFunctionParameters > 0) {
            const missingParameterString = Array.from(previousSegment.getRemainingFunctionParameters())
                .map(value => '"' + value[0] + '"')
                .join(', ');
            throw new Error(`Function parameter${missedFunctionParameters > 1 ? 's' : ''} ${missingParameterString}`
                + ` ${missedFunctionParameters > 1 ? 'were' : 'was'} not provided for ${previousSegmentName}`);
        }

        // Validate missing keyPredicates
        const missedKeyPredicates = previousSegment.getRemainingKeyParameters().size;
        if (missedKeyPredicates > 0) {
            const missingKeyPredicatesString = Array.from(previousSegment.getRemainingKeyParameters())
                .map(value => '"' + value[0] + '"')
                .join(', ');
            const precedingType = previousSegment.getEdmType().getName();
            throw new Error(`Missing KeyPredicate${missedKeyPredicates > 1 ? 's' : ''} ${missingKeyPredicatesString}`
                + ` for type "${precedingType}" returned from "${previousSegmentName}"`);
        }
    }

    /**
     * @param {EdmType.TypeKind[]} expectedEdmTypeKinds
     * @param {boolean} expectedCollection
     * @param {SegmentInfo} previousSegment
     * @param {string} segmentName
     * @private
     */
    _postvalidateFunction(expectedEdmTypeKinds, expectedCollection, previousSegment, segmentName) {
        const expectedEdmTypes = expectedEdmTypeKinds
            .map(value => '"' + Object.keys(EdmTypeKind).find(key => EdmTypeKind[key] === value) + "'")
            .join(', ');

        if (previousSegment.getKind() === ResourceKind.FUNCTION_IMPORT
            || previousSegment.getKind() === ResourceKind.BOUND_FUNCTION) {
            const actualEdmTypeKind = previousSegment.getEdmType().getKind();

            if (expectedEdmTypeKinds.indexOf(actualEdmTypeKind) < 0) {
                const actualEdmType = Object.keys(EdmTypeKind).find(key => EdmTypeKind[key] === actualEdmTypeKind);
                throw new Error(`"${segmentName}" requires the preceding FunctionImport to`
                    + ` return one of the following EdmTypes: ${expectedEdmTypes}. Got: "${actualEdmType}"`);
            }

            if (expectedCollection != null && expectedCollection !== previousSegment.isCollection()) {
                throw new Error(`${segmentName} can ${expectedCollection ? 'only' : 'not'} be used on a collection`);
            }
        }
    }
}

module.exports = EdmValidator;
