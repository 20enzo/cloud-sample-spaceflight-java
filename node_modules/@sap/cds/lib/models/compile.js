const cdsv = require('./cdsv')
const cds = require('../index')

const YAML = { stringify: (...args) => (YAML.stringify = require('./2yaml'))(...args) }
const SQL = { for: (...args) => (SQL.for = require('./2sql'))(...args) }


// Fluent API, i.e. compile(csn).to('yml') --> see also: https://bit.ly/capire/APIs#cds-compile)
const compile = (csn) => ({ to:(x,o) => {
  let fn = compile.to[x];  if (!fn)  throw new TypeError (`cds.compile.to.${x} is not defined`)
  if (typeof csn === 'string')  csn = cds.parse (csn)
  return fn (csn,o) 
}})

// Dedicated API, i.e. compile.to.yml('csn')
const compile_to = {
  json: x => JSON.stringify(x,null,'    '),
  yaml: YAML.stringify,
  yml: YAML.stringify,
  // sql: (csn,o={}) => _2structuredOut(cdsv.toSql(csn,_sql_naming(o)).sql,'.sql'),
  sql: (csn,o={}) => { let x = SQL.for(csn,o); return o.as=='str' ? x.reduce((p,n)=> p+n+'; \n\n','\n') : x },
  cdl: (csn,o={}) => _2structuredOut(cdsv.toCdl(csn,o),'.cds'),
  hana: (csn,o={}) => _many  (cdsv.toHana(csn,_sql_naming(o)).hdbcds, o, '.hdbcds'),
  edm: (csn,o={}) => _2odata (csn,o, 'metadata_json'),
  edmx: (csn,o={}) => _2odata (csn,o, {off: 'metadata', only: 'annotations'}[o.annos] || 'combined'),
  annos: (csn,o={}) => _2odata (csn,o, 'annotations'),
  swgr: (csn,o={}) => _many  (cdsv.toSwagger(csn,o).services, o, '.swgr.json'),
  // swgr: (csn,o={}) => { let x = cdsv.toSwagger(csn,o); return o.as ? compile.to[o.as=='str'?'yml':o.as](x) : x },
}

const suffixes = {
  cdl: '.cds',
  yaml: '.yml',
  annos: '.annotations.xml',
  edmx: '.edm.xml',
  edm: '.edm.json',
  swgr: '.swgr.yml',
  hana: '.hdbcds',
}

function _sql_naming (options) {
  return Object.assign({toHana:{
    names: { slugified: 'flat', plain: 'flat', quoted: 'deep', }[ cdsv.sqlMapping(options) ],
    associations: 'assocs'
  }}, options)
}

function _many (hdbcds, o={}, _ext='.hdbcds') {
  const resultSize = Object.keys(hdbcds).length
  const generator = (function* () { //NOSONAR
    for (let name in hdbcds) {
      const filename = name.replace(/[.:/\\]/g, '_')
      yield [hdbcds[name], { name: filename, suffix: _ext }]
    }
    // Add an .hdinamespace file that prevents the gen/ dir to be appended as a namespace segment.
    // This would happen if the src/ dir above adds an .hdinamespace with 'subfolder:append'.  See issue #64.
    if (o.extraArtifacts && resultSize > 0) {
      yield [{ name: '', subfolder: 'ignore' }, { name: '.hdinamespace', suffix: '' }]
    }
  })()
  return generator
}

function _2structuredOut(result, suffix) {
  const generator = (function* () { //NOSONAR
    for (let name in result) {
      const filename = name.replace(/[.:/\\]/g, '_')
      yield [result[name], { name: filename, suffix }]
    }
  })()
  return generator
}

/** Extracts requested outcomes from the all-in-one results obtained from cdsv.
 * E.g. for
 *
 * > _compile.to.edmx(csn,{service:'**A**','metadata'})_
 *
 * cdsv would return the like of
 * _{ **A**: { metadata:{...}, annotations:{...} }, **B**: {...}, ... }_
 *
 * Which we would return as
 * _{ **A**: {...} }_
 */
function _2odata (csn,o={}, requested) {
  o.json = (o.version !== 'v2');
  o.xml = o.combined = o.separate = true
  // REVISIT: Warum akzeptiert toOdataOutput kein zuvor erzeugtes Ergebnis von transform4OData?
  let allin1 = csn._odata; if (!allin1)  Object.defineProperty (csn, '_odata', {value:
    allin1 = cdsv.toOdata(csn, o),
    configurable:1, writable:1
  })
  if (!allin1 || !allin1.services)  throw new Error('No service definitions found')
  if (requested === 'csn')  return allin1.csn
  let services = allin1.services
  if (o.service === 'all')  return (function*(){ //NOSONAR
    for (let name in services)  yield [ _selectOutput (services[name][requested]), {name} ]
  })()
  if (!o.service) {
    let chosen = cds.reflect(csn).find (s => s['@cds.chosen.service'])
    if (chosen)  o.service = chosen.name
  }
  if (o.service) {
    for (let each in services) if (each.indexOf(o.service) >= 0)  return _selectOutput (services[each][requested])
    throw new Error (
      `[cds.compile.to.${requested}] - didn't find service definition matching ${o.service}`
    )
  }
  if (Object.keys(services).length > 1)  throw new Error (_choose_one())
  for (let each in services)   return _selectOutput(services[each][requested])

  function _selectOutput (out) {
    if (requested === 'metadata_json' && o.as === 'str')  return JSON.stringify(out)
    return out
  }

  function _choose_one(){
    return `[cds.compile.to.${requested}] - multiple service definitions in model:

    ${Object.keys(services).join('\n    ')}

  please choose one or all using --service all | <one of above> from the CLI
  or { service:'all' | <...> } from the API respectively.
  `
  }
}

module.exports = Object.assign (compile, { to: compile_to, suffixes })