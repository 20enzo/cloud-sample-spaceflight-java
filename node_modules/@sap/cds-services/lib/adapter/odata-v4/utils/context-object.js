const {statements} = require('@sap/cds-ql')

const {Components: {DATA_DELETE_HANDLER, DATA_READ_HANDLER}} = require('@sap/odata-v4')
const {isCustomOperation} = require('./request')
const odataToCQN = require('../odata-to-cqn/odataToCQN')

/**
 * The key predicates will contain the keys and values for this request.
 * Combine all key value pairs into one object.
 * @param keyPredicates
 * @returns {Object}
 * @private
 */
const _getKeyValues = (keyPredicates) => {
  const keyValues = {}

  for (const keyPredicate of keyPredicates) {
    const edmRef = keyPredicate.getEdmRef()
    const typeName = edmRef.getProperty().getType().getName()

    // Convert any integer type into numeric values.
    keyValues[edmRef.getName()] = (typeName.startsWith('Int')) ? Number(keyPredicate.getText()) : keyPredicate.getText()
  }

  return keyValues
}

/**
 * Get data from odata-v4.
 * READ and DELETE work are retrieved from URL; CREATE and UPDATE from body.
 * @param {string} component - odata-v4 component which processes this request.
 * @param req
 * @returns {Object}
 * @private
 */
const _getData = (component, req) => {
  const keyValues = _getKeyValues(req.getUriInfo().getPathSegments()[0].getKeyPredicates())

  if (component === DATA_DELETE_HANDLER || component === DATA_READ_HANDLER) {
    return keyValues
  }

  // Use identifier from URL instead of body
  const data = req.getBody() || {}

  for (const key of Object.keys(keyValues)) {
    data[key] = keyValues[key]
  }

  return data
}

/**
 * In case of batch request use the applicationData object as base,
 * else create a new object.
 * @param {Object} req - odata-v4 request object.
 * @return {Object}
 * @private
 */
const _getUnderscore = (req) => {
  let _ = req.getBatchApplicationData()

  // If batched, and first event of the batch, add indicator, to reuse the same db client.
  if (_ && _.doNotFinishTransaction === undefined) {
    _.doNotFinishTransaction = true
  }

  // Not batched, create object, that can be shared later on and will hold channel specifc details in any case.
  if (!_) {
    _ = {}
  }

  _.odataReq = req

  // Give the app developer access to the original (express) request object
  if (!_.req) {
    _.req = req.getIncomingRequest()
  }

  return _
}

/**
 * Try to find the name of the source entity at the services CSN.
 * @param {Object} service
 * @param {string} name
 * @returns {string}
 * @private
 */
const _findSourceEntityNameAtService = (service, name) => {
  const serviceEntity = service.reflected.find((element) => {
    return (element.source === name)
  })

  return (serviceEntity) ? serviceEntity.name : name
}

/**
 * Gets the name of the service entity targeted by the given navigation path.
 * Undefined in case of a function or action import.
 * @param {Service} service
 * @param {Array} pathSegments - The path segments of a uri.
 * @returns {string} - The name of the navigation target entity.
 * @private
 */
const _getTargetEntityName = (service, pathSegments) => {
  if (isCustomOperation(pathSegments, false)) {
    return undefined
  }

  /*
   * The cds.deploy does not create views in case of SQLite.
   * We need to go to the sources in case of projections.
   * TODO: Use the entity directly, once views are deployed.
   */
  let navSegmentName
  let entityName = `${service.service}.${pathSegments[0].getEntitySet().getName()}`

  for (const navSegment of pathSegments.filter(segment => segment.getNavigationProperty() !== null)) {
    navSegmentName = navSegment.getNavigationProperty().getName()
    entityName = service.reflected.definitions[entityName].elements[navSegmentName].target
  }

  return _findSourceEntityNameAtService(service, entityName)
}

const getContextObject = (component, service, req) => {
  const pathSegments = req.getUriInfo().getPathSegments()

  const context = {
    get data () {
      const data = _getData(component, req)
      Object.defineProperty(context, 'data', {value: data})
      return data
    },
    get query () {
      let query

      if (!isCustomOperation(pathSegments)) {
        query = odataToCQN(component, service.reflected, service.service, context, req)
      }

      Object.defineProperty(context, 'query', {value: query})

      return query
    },
    get target () {
      const pathSegments = req.getUriInfo().getPathSegments()
      const target = service.reflected.definitions[_getTargetEntityName(service, pathSegments)]

      Object.defineProperty(context, 'target', {value: target})

      return target
    },
    get statements () {
      const {SELECT, INSERT, UPDATE, DELETE} = statements
      const wrappedStatements = {
        SELECT: {
          from: (entity, columns) => {
            return SELECT.from(entity, columns, service.reflected)
          },
          one: (entity) => {
            return SELECT.one(entity)
          }
        },
        INSERT: INSERT,
        UPDATE: UPDATE,
        DELETE: DELETE
      }

      Object.defineProperty(context, 'statements', {value: wrappedStatements})

      return wrappedStatements
    },
    _: _getUnderscore(req)
  }

  return context
}

module.exports = getContextObject
