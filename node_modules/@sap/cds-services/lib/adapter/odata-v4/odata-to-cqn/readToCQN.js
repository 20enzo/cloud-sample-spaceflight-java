const QueryOptions = require('@sap/odata-v4').QueryOptions
const {getColumns} = require('@sap/cds-sql').utils

const {FeatureNotSupported} = require('../../../errors')
const cds = require('../../../cds')

const filterToCQN = require('./filterToCQN')
const orderByToCQN = require('./orderByToCQN')
const selectToCQN = require('./selectToCQN')
const searchToCQN = require('./searchToCQN')
const expandToCQN = require('./expandToCQN')
const applyToCQN = require('./applyToCQN')
const topSkipToCQN = require('./topSkipToCQN')
const topSkipWithPaginationToCQN = require('./topSkipWithPaginationToCQN')

const _supportedSegmentKinds = ['ENTITY', 'ENTITY.COLLECTION', 'NAVIGATION.TO.ONE', 'NAVIGATION.TO.MANY', 'PRIMITIVE.PROPERTY', 'COUNT']

const _filter = (req, cqn) => {
  if (req.getQueryOptions() && req.getQueryOptions().$filter) {
    cqn.where(filterToCQN(req.getUriInfo().getQueryOption(QueryOptions.FILTER)))
  }
}

const _includeBrackets = (string) => {
  let quotes = 0

  for (let i = 0, length = string.length; i < length; i++) {
    if (string.charAt(i) === '"' && string.charAt(i - 1) !== '\\') {
      quotes = quotes === 0 ? quotes + 1 : quotes - 1
    }
    if (string.charAt(i) === '(' && quotes === 0) {
      return true
    }
  }

  return false
}

const _search = (reflected, reflectedEntity, uriInfo, cqn, req) => {
  const search = uriInfo.getQueryOption(QueryOptions.SEARCH)
  if (search) {
    if (_includeBrackets(req.getQueryOptions().$search)) {
      throw new FeatureNotSupported('Parenthesis operator in query options is not supported')
    }

    const allowedTypes = ['cds.String', 'cds.UUID', 'cds.Date', 'cds.Time', 'cds.DateTime', 'cds.Timestamp']
    const columns = getColumns(reflected, reflectedEntity.def)
      .filter(column => allowedTypes.includes(column.type))
      .map(column => column.name)
    cqn.where(...searchToCQN(columns, search))
  }
}

const _orderby = (req, cqn) => {
  if (req.getQueryOptions() && req.getQueryOptions().$orderby) {
    orderByToCQN(cqn, req.getQueryOptions().$orderby)
  }
}

const _select = (req, keys) => {
  if (req.getQueryOptions() && req.getQueryOptions().$select) {
    const key = keys ? Object.keys(keys)[0] : undefined
    return selectToCQN(req.getQueryOptions().$select, key)
  }

  return []
}

const _apply = (req) => {
  if (req.getQueryOptions() && req.getQueryOptions().$apply) {
    return applyToCQN(req.getUriInfo().getQueryOption(QueryOptions.APPLY))
  }
  return {}
}

const _isNavigation = (pathSegments) => {
  return pathSegments.length > 1 && pathSegments[1].getKind().startsWith('NAVIGATION')
}

const _groupBy = (groupBy, cqn) => {
  if (groupBy && groupBy.length !== 0) {
    for (const col of groupBy) {
      cqn.groupBy(col)
    }
  }
}

const _expand = (req, uriInfo) => {
  const expand = uriInfo.getQueryOption(QueryOptions.EXPAND)

  if (!expand || expand.length === 0) {
    return []
  }

  return expandToCQN(expand, uriInfo.getFinalEdmType())
}

const _topSkip = (req, cqn) => {
  const queryOptions = req.getQueryOptions()
  if (queryOptions && (queryOptions.$top || queryOptions.$skip)) {
    topSkipToCQN(cqn, {
      top: req.getQueryOptions().$top ? parseInt(req.getQueryOptions().$top) : Number.MAX_SAFE_INTEGER,
      skip: req.getQueryOptions().$skip ? parseInt(req.getQueryOptions().$skip) : undefined
    })
  }
}

const _getPropertyParam = (pathSegments) => {
  const prop = pathSegments[pathSegments.length - 1].getProperty()
  return prop === null ? [] : [prop.getName()]
}

const _buildPath = (serviceName, pathSegments) => {
  return pathSegments
    .filter(s => s.getProperty() === null)
    .map(s => {
      let segmentElement
      if (s.getEntitySet()) {
        segmentElement = `${serviceName}.${s.getEntitySet().getName()}`
      } else {
        segmentElement = s.getNavigationProperty().getName()
      }

      const getKeysFromUriParam = (uriParam) => { return `${uriParam.getEdmRef().getName()}=${uriParam.getText()}` }
      const segmentKeys = s.getKeyPredicates().length > 0 ? `[${s.getKeyPredicates().map(getKeysFromUriParam).join(',')}]` : ''

      return `${segmentElement}${segmentKeys}`
    })
    .join(':')
}

const _addKeysToWhere = (segments, cqn) => {
  if (!_isNavigation(segments) && segments[0].getKeyPredicates().length > 0) {
    const keys = {}
    segments[0].getKeyPredicates().forEach(keyPredicate => {
      keys[keyPredicate.getEdmRef().getName()] = keyPredicate.getText()
    })
    cqn.where(keys)
  }
}

/**
 * Transform odata READ request into a CQN object.
 *
 * @param {object} reflected - the reflected CSN model.
 * @param {object} serviceName - the name of the service.
 * @param {object} context - Contains request information and utility methods like statements.
 * @param {object} req - An odata request.
 * @private
 */
const readToCQN = (reflected, serviceName, context, req) => {
  const {SELECT} = context.statements
  const segments = req.getUriInfo().getPathSegments()

  for (const segment of segments) {
    if (!_supportedSegmentKinds.includes(segment.getKind())) {
      throw new FeatureNotSupported(`Request parameter ${segment.getKind()} is not supported`)
    }
  }

  const uriInfo = req.getUriInfo()
  const reflectedEntity = cds.reflect(context.target)
  const entityName = reflectedEntity.def.name
  const entityParam = _isNavigation(segments) ? _buildPath(serviceName, segments) : entityName
  const propertyParam = _getPropertyParam(segments)
  const apply = _apply(req)
  const select = _select(req, reflectedEntity.keys)
  const expand = _expand(req, uriInfo)

  // TODO: Correct implementation of the combined apply, select and expand as described in
  // http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/odata-data-aggregation-ext-v4.0.html
  // part 3.16

  propertyParam.push(...select)

  if (apply.aggregations && apply.aggregations.length !== 0) {
    propertyParam.push(...apply.aggregations)
  }

  if (apply.groupBy && apply.groupBy.length !== 0) {
    propertyParam.push(...apply.groupBy)
  }

  if (expand.length !== 0) {
    if (select.length === 0) {
      propertyParam.push(...getColumns(reflected, reflected.definitions[entityName]).map(column => column.name))
    }
    propertyParam.push(...expand)
  }

  const cqn = SELECT.from(entityParam, (propertyParam.length > 0) ? propertyParam : undefined)

  _addKeysToWhere(segments, cqn)
  _filter(req, cqn)
  _search(reflected, reflectedEntity, uriInfo, cqn, req)
  _orderby(req, cqn)
  _groupBy(apply.groupBy, cqn)
  _topSkip(req, cqn)

  // currently OData does not support pagination for expand
  if (expand.length === 0) {
    topSkipWithPaginationToCQN(req, cqn)
  }
  return cqn
}

module.exports = readToCQN
