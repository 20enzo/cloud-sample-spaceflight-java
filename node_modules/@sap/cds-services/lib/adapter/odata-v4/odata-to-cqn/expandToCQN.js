const odata = require('@sap/odata-v4')
const QueryOption = odata.QueryOptions
const EdmTypeKind = odata.edm.EdmTypeKind
const {FeatureNotSupported} = require('../../../errors')

/**
 * Check if $expand=* has been used.
 *
 * @return {boolean}
 * @private
 */
const _isAll = (expandItems) => {
  return expandItems.some((item) => {
    return item.isAll()
  })
}

/**
 * Check which element(s) of the entity has been expanded.
 *
 * @return {*}
 * @private
 */
const _getExpandItem = (isAll, expandItems, name) => {
  if (isAll) {
    return null
  }

  return expandItems.find((item) => {
    return (item.getPathSegments()[0].getNavigationProperty().getName() === name)
  })
}

/**
 * Check if not supported function is used and if so, throw an error.
 *
 * @private
 */
const _notSupported = (expandItem) => {
  if (!expandItem) {
    return
  }

  if (expandItem.getOption(QueryOption.COUNT)) {
    throw new FeatureNotSupported(`QueryOption ${QueryOption.COUNT} is not supported`)
  }
  if (expandItem.getOption(QueryOption.SEARCH)) {
    throw new FeatureNotSupported(`QueryOption ${QueryOption.SEARCH} is not supported`)
  }
  if (expandItem.getOption(QueryOption.FILTER)) {
    throw new FeatureNotSupported(`QueryOption ${QueryOption.FILTER} is not supported`)
  }
  if (expandItem.getOption(QueryOption.ORDERBY)) {
    throw new FeatureNotSupported(`QueryOption ${QueryOption.ORDERBY} is not supported`)
  }
  if (expandItem.getOption(QueryOption.SKIP)) {
    throw new FeatureNotSupported(`QueryOption ${QueryOption.SKIP} is not supported`)
  }
  if (expandItem.getOption(QueryOption.TOP)) {
    throw new FeatureNotSupported(`QueryOption ${QueryOption.TOP} is not supported`)
  }
}

/**
 * No lookup at the CSN needed. Get columns from target.
 *
 * @return {Array}
 * @private
 */
const _getColumnsFromTargetType = (targetType, all = false) => {
  if (!targetType || targetType.getKind() !== EdmTypeKind.ENTITY) {
    return []
  }

  if (all) {
    return Array.from(targetType.getProperties()).map((element) => element[0])
  }

  return Array.from(targetType.getKeyPropertyRefs().keys())
}

const _getInnerSelect = (expandItem) => {
  if (!expandItem) {
    return []
  }

  return expandItem.getOption(QueryOption.SELECT) || []
}

/**
 * Get the selected columns and navigation paths.
 * @return {Array}
 * @private
 */
const _getSelectedElements = (expandItem, targetType) => {
  const innerSelectItems = _getInnerSelect(expandItem)

  if (innerSelectItems.length === 0 || innerSelectItems.some(item => item.isAll())) {
    return _getColumnsFromTargetType(targetType, true)
  }

  const selectedPaths = _getColumnsFromTargetType(targetType)

  for (const selectItem of innerSelectItems) {
    for (const segment of selectItem.getPathSegments()) {
      if (!selectedPaths.includes(segment.getPathSegmentIdentifier())) {
        selectedPaths.push(segment.getPathSegmentIdentifier())
      }
    }
  }

  return selectedPaths
}

/**
 * Nested expands are inner expand items.
 *
 * @return {Array}
 * @private
 */
const _getInnerExpandItems = (expandItem, targetType) => {
  if (!expandItem || !expandItem.getOption(QueryOption.EXPAND)) {
    return []
  }

  return expandToCQN(expandItem.getOption(QueryOption.EXPAND), targetType)
}

/**
 * Convert odata-v4 expand to into argument for query API.
 *
 * @param expandItems
 * @param type
 * @return {Array}
 */
const expandToCQN = (expandItems, type) => {
  const allElements = []
  const isAll = _isAll(expandItems)

  for (const [name, navigationProperty] of type.getNavigationProperties()) {
    const expandItem = _getExpandItem(isAll, expandItems, name)

    if (isAll || expandItem) {
      _notSupported(expandItem)

      const targetType = navigationProperty.getEntityType()
      const elements = _getSelectedElements(expandItem, targetType)
      elements.push(..._getInnerExpandItems(expandItem, targetType))

      allElements.push({
        [`expand(${name})`]: elements
      })
    }
  }

  return allElements
}

module.exports = expandToCQN
