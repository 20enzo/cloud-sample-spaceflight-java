const cds = require('../cds')

/**
 * If not provided directly, check by naming pattern, if there could be a file that containing the custom hooks.
 * @private
 */
const _getImplementation = (definition, options, init) => {
  let impl = (!init && (typeof options === 'function' || typeof options === 'string')) ? options : (init || definition['@impl'])

  if (typeof impl === 'function') {
    return (impl._source) ? impl : Object.defineProperty(impl, '_source', {value: impl.name || '<inline>'})
  }

  if (!impl && (!definition._location || !definition._location.filename)) {
    return
  }

  const path = require('path')
  const fs = require('fs')
  const filename = path.resolve(impl || definition._location.filename).replace(/\.(cds|json|yaml|js)$/, '')

  if (fs.existsSync(`${filename}.js`)) {
    return require(filename)
  }
}

const _addSlashToPath = (path) => {
  return (path.startsWith('/')) ? path : `/${path}`
}

const _getUrlPath = (length, atPath, csnPath) => {
  if (length === 1) {
    return _addSlashToPath(atPath || csnPath || '/').replace(/\/{2,}/g, '/')
  }

  return `/${_addSlashToPath(atPath || '/')}${_addSlashToPath(csnPath || '/')}`.replace(/\/{2,}/g, '/')
}

const _lowerFirstLetter = (string) => {
  return `${string.charAt(0).toLowerCase()}${string.slice(1)}`
}

/**
 * Removes namespace and Service suffix.
 * Changes first name of service to lowercase.
 * @param name
 * @return {string}
 * @private
 */
const _parsePathFromName = (name = '') => {
  let matches = name.match(/([^.]+)Service$/)

  if (!matches) {
    matches = name.match(/([^.]+)/)
  }

  if (matches) {
    return _lowerFirstLetter(matches[1])
  }

  return name
}

const _getServiceCount = (model) => {
  let count = 0

  model.foreach('service', () => {
    count++
  })

  return count
}

const _getServiceDefinition = (model, serviceName) => {
  if (serviceName) {
    return model.definitions[serviceName]
  }

  return model.find('service')
}

/**
 * Service factory will return the router of the service instance.
 * The this scope within the init function will be of an instance of the class Service.
 * @throws {ModelNotDefined}
 * @param {string} csn - the unreflected CSN.
 * @param {Object} [options] - optional object with options, service implementation file.
 * @param {Object} [options.logger] - optional logger object to be used in the odata library.
 * @param {string} [options.logLevel] - optional log level to be used according to winston/npm specification.
 * @param {number} [options.maxResourcePathLength] - Maximum allowed number of resource path segments.
 * @param {number} [options.maxPageSize] - The page limit value. By default server side paging is enabled and set to 100. To disable it set it to false.
 * @param {string} [options.path] - URL path, at which the service will be placed at.
 * @param {string} [options.service] - Service name as specified in CSN.
 * @param {boolean} [options.crashOnError] - Application should crash on error. Defaults to true.
 * @param {Object} [options.uaa] - xsenv filter options for UAA service, which is used for JWT validation.
 * @param {Object} [options.passport] - Passport configuration.
 * @param {function} [init] - an init function to register custom handlers.
 * @returns {Object} - instance of odata-v4
 * @alias module:server.service
 * @see {@link Service}
 */
function service (csn, options, init) {
  if (typeof csn !== 'object') {
    const {ModelNotDefined} = require('../errors')
    throw new ModelNotDefined()
  }

  const serviceOptions = options || {}
  serviceOptions.logger = serviceOptions.log || serviceOptions.logger

  const reflectedModel = cds.reflect(csn)

  const serviceDefinition = _getServiceDefinition(reflectedModel, serviceOptions.service)

  if (!serviceOptions.service) {
    serviceOptions.service = serviceDefinition.name
  }

  serviceOptions.path = _getUrlPath(_getServiceCount(reflectedModel), serviceOptions.path, serviceDefinition['@path'] || _parsePathFromName(serviceDefinition.name))

  const Service = require('./Service')
  const serviceInstance = new Service(reflectedModel, serviceOptions)
  serviceInstance.definition = csn
  serviceInstance.entities = reflectedModel.childrenOf(serviceDefinition)
  serviceInstance.createODataService(cds.compile.to.edm(csn, {service: serviceDefinition.name}), _getImplementation(serviceDefinition, options, init))

  service.providers.push(serviceInstance)

  return serviceInstance
}

Object.defineProperties(service, {
  providers: {
    value: []
  },
  impl: {
    value: fn => fn  // dummy function to assist vscode typings-based IntelliSense
  },
  kind: {
    value: 'service'  // Used for cds.reflect
  },
  prototype: {value: cds.cds.service.prototype}
})

module.exports = service
