const getDiff = require('./utils/diff')
const {getError} = require('../errors')
const CALLED = Symbol.for('continuationCalled')
const {getPassport} = require('./utils/getPassport')
const {postAuth} = require('./handlers/postAuth')

/**
 * Generic Service Event Handler.
 */
class Service {
  /**
   * Constructs an OData service for the given CDS model.
   * @param {Object} reflected - the reflected CSN.
   * @param {Object} options - configuration options
   * @throws {ModelNotDefined}
   */
  constructor (reflected, options) {
    const {After, Before, On, Reject} = require('./hooks')

    this._options = options
    this.service = options.service
    this.reflected = reflected

    this._handlers = {
      before: new Before(this.reflected, this.service),
      on: new On(this.reflected, this.service),
      after: new After(this.reflected, this.service),
      reject: new Reject(this.reflected, this.service)
    }

    this._addDefaultOnHandler()
    this._addDefaultMiddleware(options)
  }

  _addDefaultMiddleware (options) {
    if (options.passport) {
      this._registerPassportMiddleware(options)
    }
  }

  _registerPassportMiddleware (options) {
    const passport = getPassport(options)
    this.use(passport.initialize())
    this.use(passport.authenticate(options.passport.strategy, {session: false, failWithError: true}))
    this.use(postAuth)
  }

  /**
   * Register default on handlers for all entities of the service.
   * If the entity is marked with @readonly annotation only default handler for read is registered, others are rejected.
   * If the entity is marked with @insertonly annotation only default handler for insert is registered, others are rejected.
   * @private
   */
  _addDefaultOnHandler () {
    const {finalOn, onCreate, onRead, onUpdate, onDelete} = require('./handlers')

    const serviceEntities = [...this.reflected.each((definition) => {
      return definition.kind === 'entity' && definition.name.startsWith(this.service)
    })]

    for (let entity of serviceEntities) {
      if (entity['@readonly']) {
        this.on('READ', entity, onRead)
          .reject(['CREATE', 'UPDATE', 'DELETE'], entity.name)
      } else if (entity['@insertonly']) {
        this.on('CREATE', entity, onCreate)
          .reject(['READ', 'UPDATE', 'DELETE'], entity.name)
      } else {
        this.on('CREATE', entity, onCreate)
          .on('READ', entity, onRead)
          .on('UPDATE', entity, onUpdate)
          .on('DELETE', entity, onDelete)
      }
    }

    // Final handler, that will throw an error
    this.on(finalOn)
  }

  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  before (event, entity, handler) {
    this._handlers.before.use(event, entity, handler)

    return this
  }

  /**
   * Replace an handler for a specific event type and entity.
   * @param {string} [event] - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  on (event, entity, handler) {
    this._handlers.on.use(event, entity, handler)

    return this
  }

  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * In case an arrow function with '(each) =>' is used for the event handler an iterator for the result set will be added automatically.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  after (event, entity, handler) {
    this._handlers.after.use(event, entity, handler)

    return this
  }

  /**
   * Reject an event type, list of event types or an event type for a entity.
   * @param {string|Array} event - Specific event type or list of types.
   * @param {string|Object|Array} [entity] - Name of the entity or CSN entity or list of entities the event type should be rejected for.
   * The list can be specified either as Array or as multiple parameters.
   * @returns {Service}
   */
  reject (...args) {
    this._handlers.reject.use(...args)

    return this
  }

  /**
   * Express like middleware registration.
   * @returns {Service}
   */
  use (...args) {
    if (!this._handlers.router) {
      this._handlers.router = require('express').Router()
    }

    this._handlers.router.use(...args)

    return this
  }

  /**
   * Execute all registered middleware.
   * @param {Object} req
   * @param {Object} res
   * @param {Function} next
   * @returns
   */
  routerHandle (req, res, next) {
    if (!this._handlers.router) {
      next()
      return
    }

    const end = (err) => {
      if (err) {
        // err.status is http error code from passport
        res.status(err.statusCode || err.status || 500)
        res.send({
          error: {
            code: err.code,
            message: err.message
          }
        })

        return
      }

      next()
    }

    this._handlers.router.handle(req, res, end)
  }

  /**
   * Process an event from any adapter/channel.
   * @param {string} event
   * @param {Object} context
   * @returns {Promise<Array>}
   */
  processEvent (event, context) {
    return new Promise((resolve, reject) => {
      if (this._handlers.reject.has(event, context.target)) {
        reject(getError(501))
        return
      }

      this._addError(context)
      this._addReject(context)
      this._addReply(event, context, resolve, reject)
      this._addRunIfPrimarySessionExists(context)

      this._runHandlers(event, context, reject)
    })
  }

  /**
   * Require @sap/cds-ql on first usage.
   * @returns {Object}
   * @private
   */
  get _ql () {
    const ql = require('@sap/cds-ql')
    Object.defineProperty(this, '_ql', {value: ql})
    return ql
  }

  /**
   * Check for registered handlers.
   * Execute in sequence before, on, after, beforeCommit, commit, onCommit.
   * @param {string} event
   * @param {Object} context
   * @param {Function} reject
   * @private
   */
  _runHandlers (event, context, reject) {
    this._handlers.before.executeHandlerIfListed(event, context)
      .then(() => {
        this._handlers.on.executeHandlerIfListed(event, context, this._reject(context, reject))
      })
      .catch((err) => {
        return this._end(context, 'rollback', reject, (err.statusCode) ? err : getError(500, err), reject)
      })
  }

  /**
   * Embed promises reject function in a potential DB client rollback.
   * @param {Object} context
   * @param {Function} reject
   * @returns {Function}
   * @private
   */
  _reject (context, reject) {
    return (err) => {
      return this._end(context, 'rollback', reject, err, reject)
    }
  }

  /**
   * Success and error handling of commit and rollback.
   * @param {Object} context
   * @param {string} command - commit or rollback
   * @param {Function} end
   * @param {*} value
   * @param {Function} reject
   * @returns {Promise}
   * @private
   */
  _end (context, command, end, value, reject) {
    return this._endTransactionIfConnected(context, command)
      .then(() => {
        end(value)
      })
      .catch((err) => {
        reject(err)
      })
  }

  /**
   * Add .error function to context object.
   * @param {Object} context
   * @private
   */
  _addError (context) {
    /**
     * Error factory method.
     * Errors are not thrown. Instead they are colected in the array context._.errors.
     * @param {number|Error|string} code - HTTP status code. If unknown to @sap/odata-v4, will be overwritten with 500.
     * @param {Error|string} [err] - Error given by the app developer.
     */
    context.error = (code, err) => {
      if (!context._.errors) {
        context._.errors = []
      }

      const error = getError(code, err)
      context._.errors.push(error)

      return error
    }
  }

  /**
   * Add .reject function to context object.
   * @param {Object} context
   * @private
   */
  _addReject (context) {
    /**
     * Reject factory method
     * In case of reject the error is thrown directly instead of putting it to context._.errors.
     * @param {number|Error|string} code - HTTP status code. If unknown to @sap/odata-v4, will be overwritten with 500.
     * @param {Error|string} [err] - Error given by the app developer.
     */
    context.reject = (code, err) => {
      throw getError(code, err)
    }
  }

  /**
   * Add .reply function to context object.
   * @param {String} event
   * @param {Object} context
   * @param {Function} resolve
   * @param {Function} reject
   * @private
   */
  _addReply (event, context, resolve, reject) {
    context[CALLED] = false

    /**
     * Check if already called.
     * @returns {boolean}
     */
    const replyCalled = () => {
      const lastCalled = context[CALLED]
      context[CALLED] = true

      return lastCalled
    }

    /**
     * Hand over of 'on hook' result to following middleware.
     * @param {Array|Object|string} result - Result as given by persistence at the on handler.
     */
    context.reply = (result) => {
      // Not allowed to be called twice.
      if (replyCalled()) {
        return
      }

      // A reading process shall never have side effects.
      const command = (event === 'READ') ? 'rollback' : 'commit'
      const modifiedResult = this._modifyResult(result)

      // Unexpected errors will be handled in the after handler.
      this._handlers.after.executeHandlerIfListed(event, context, modifiedResult)
        .then(() => {
          // In case of commit remember the data and event
          this._storeChangedData(event, command, context)

          return this._end(context, command, resolve, modifiedResult, reject)
        })
        .catch((err) => {
          return this._end(context, 'rollback', reject, err, reject)
        })
    }
  }

  /**
   * In case of commit track the general event as commit event.
   * @param event
   * @param command
   * @param context
   * @private
   */
  _storeChangedData (event, command, context) {
    if (command === 'rollback') {
      return
    }

    if (!context._.changes) {
      context._.changes = []
    }

    context._.changes.push({
      target: context.target,
      query: context.query,
      data: context.data,
      // Might be undefined; TODO: an API to set it.
      oldData: context._oldData,
      // Event is not required by handler, but is useful for the app developer
      event: event,
      // Lazy constructing of the diff
      get diff () {
        const diff = getDiff(this.oldData, this.data)

        Object.defineProperty(this, 'diff', {value: diff})

        return diff
      },
      // Add the underscore, to give an app developer a cross event object
      _: context._
    })
  }

  /**
   * Check if result is array and if not return result as single entry in an array.
   * @param result
   * @return {Array}
   * @private
   */
  _modifyResult (result) {
    // Null, 0, false, '', ... should be wrapped
    if (result === undefined) {
      return []
    }

    return Array.isArray(result) ? result : [result]
  }

  /**
   * Check if a client exists in the event context.
   * If yes and not shared with other events, return client to pool and finish the request.
   * @private
   */
  _endTransactionIfConnected (context, command) {
    // In case there is no dbc, or doNotFinish (might be OData batch), read collection with count, ...
    if (!context._.dbc || context._.doNotFinishTransaction) {
      return Promise.resolve()
    }

    // An error has occured and there is no client
    if (context._.dbc.stack) {
      return Promise.reject(context._.dbc)
    }

    return this._beforeCommit(command, context._.changes)
      .catch((err) => {
        return this._commandAndRelease(this._removeNoLongerNeededFromQL(context), 'rollback')
          .then(() => {
            throw err
          })
          .catch(() => {
            throw err
          })
      })
      .then(() => {
        return this._commandAndRelease(this._removeNoLongerNeededFromQL(context), command)
          .catch((err) => {
            return this._afterCommit(command, false, context._.changes)
            // Propagate commit error in case both the commit and an after COMMIT handler fails
              .catch((afterCommitErr) => {
                throw err
              })
              // Success of after commit error still needs to end in an overall error
              .then(() => {
                throw err
              })
          })
          .then(() => {
            return this._afterCommit(command, true, context._.changes)
          })
      })
  }

  /**
   * Execute commit or rollback and release the client to the Pool.
   * @param {Client} dbc
   * @param {string} command
   * @return {Promise}
   * @private
   */
  _commandAndRelease (dbc, command) {
    // context._.changes
    return dbc[command]()
      .catch((err) => {
        /*
         * If a commit or rollback fails, there is something seriously wrong with the client.
         * Such a client needs to be destroyed rather than reused.
         */
        return this._ql.connect.destroy(dbc)
          .then(() => {
            // Success of destroy must trigger the error handling.
            throw err
          })
      })
      .then(() => {
        return this._ql.connect.release(dbc)
      })
  }

  /**
   * After the commit there shall be no access to .run or the client.
   * Reference might have been copied, but cannot be supported.
   * @param {Object} context
   * @return {Client}
   * @private
   */
  _removeNoLongerNeededFromQL (context) {
    // Copy reference, so context can be wiped of QL related properties
    const dbc = context._.dbc

    delete context.run
    delete context._.dbc

    return dbc
  }

  _beforeCommit (command, changes = []) {
    if (command === 'rollback' || changes.length === 0) {
      return Promise.resolve()
    }

    const handlers = []

    for (const change of changes) {
      handlers.push(this._handlers.before.executeHandlerIfListed('COMMIT', change))
    }

    return Promise.all(handlers)
  }

  _afterCommit (command, success, changes = []) {
    if (command === 'rollback' || changes.length === 0) {
      return Promise.resolve()
    }

    const handlers = []

    for (const change of changes) {
      change.success = success

      handlers.push(this._handlers.after.executeHandlerIfListed('COMMIT', change))
    }

    return Promise.all(handlers)
  }

  _getAcquireOptions (context) {
    if (context._.req) {
      return {
        JWT: context._.req.JWT,
        tenantId: context._.req.attr ? context._.req.attr.identityZone : undefined,
        user: context._.req.user ? context._.req.user.id : undefined,
        locale: context._.req.locale
      }
    }

    return undefined
  }

  _addRunIfPrimarySessionExists (context) {
    // Add the function so that the connection can be released in case of errors in complex scenarios like OData batch
    if (context._.doNotFinishTransaction && !context._.endTransactionIfConnected) {
      // Wrap to easily maintain the scope of this
      context._.endTransactionIfConnected = (...args) => {
        return this._endTransactionIfConnected(...args)
      }
    }

    // cds.connect() has not been used yet
    if (!this._ql.connect.hasSession()) {
      return
    }

    const _run = (...args) => {
      // Run has been used before, but acquire is not done yet
      if (context._.dbc instanceof Promise) {
        return context._.dbc
          .then(() => {
            if (context._.dbc.stack) {
              throw context._.dbc
            }

            return context._.dbc.execute(...args)
          })
      }

      // There has been an error on acquire
      if (context._.dbc && context._.dbc.stack) {
        return Promise.reject(context._.dbc)
      }

      // Run has been used before and acquire is done
      if (context._.dbc) {
        return context._.dbc.execute(...args)
      }

      // Acquire and execute
      context._.dbc = this._ql.connect.acquire(this._getAcquireOptions(context))
        .then((client) => {
          context._.dbc = client
          client.setCSN(this.reflected)

          return client.begin()
        })
        .catch((err) => {
          context._.dbc = err

          throw err
        })
        .then(() => {
          return context._.dbc.execute(...args)
        })

      return context._.dbc
    }

    context.run = (...args) => {
      return this._addThenableToRun(_run(...args), _run)
    }
  }

  _addThenableToRun (promise, run) {
    const then = (fn) => {
      return promise.then(fn)
    }

    then.run = (...args) => {
      return this._addThenableToRun(promise
        .then(() => {
          return run(...args)
        }), run)
    }

    return {
      then: then,
      catch: (fn) => {
        return promise.catch(fn)
      }
    }
  }

  /**
   * Creates an odata-v4 service using the provided edm and impl.
   * @param {Object} edm - the OData Entity Data Model.
   * @param {function} impl - init function to register custom handlers.
   * @returns {Service} - this service instance
   */
  createODataService (edm, impl) {
    const OData = require('../adapter/odata-v4/OData')

    this._oData = new OData(edm, this._options)
    this._oData.addCDSServiceToChannel(this)

    if (typeof impl === 'function') {
      impl.apply(this, [this.entities])
    }

    return this
  }

  /**
   * Return service middleware, which can be used by node server, express, connect, ...
   * @returns {function}
   */
  getMiddleWare () {
    return this._oData.getService()
  }
}

module.exports = Service
