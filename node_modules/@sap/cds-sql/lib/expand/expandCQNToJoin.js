const crypto = require('crypto')

const cds = require('../cds')
const {getOnCond} = require('../oncond/generateOnCond')

// Symbols are used to add extra information in response structure
const GET_KEY_VALUE = Symbol.for('getKeyValue')
const TO_MANY = Symbol.for('toMany')
const TO_MANY_KEYS = Symbol.for('toManyKeys')
const SKIP_MAPPING = Symbol.for('skipMapping')

class JoinCQNFromExpanded {
  constructor ({SELECT, _model}, csn) {
    this._SELECT = SELECT
    this._csn = _model || csn
    this.queries = []
    this.mappings = {}
  }

  /**
   * Build one to N queries and construct the post processing configs.
   * Each expand with a to many target will result in an extra query and config.
   * @returns {Array}
   */
  buildJoinQueries () {
    // Update elements at WHERE, so there are no issues with ambiguity
    this._adaptWhere(this._SELECT, this._getTableAlias(this._SELECT, []))

    // Get first level of expanding regarding to many and all to one if not part of a nested to many expand.
    this._createJoinCQNFromExpanded(this._SELECT, [])

    return this
  }

  /**
   * Build first level of expanding regarding to many and all to one if not part of a nested to many expand.
   * @param {Object} SELECT - SELECT part of a CQN.
   * @param {Array} toManyTree - Holds information how deeply nested the expand is and where the result is added in the tree.
   * @private
   */
  _createJoinCQNFromExpanded (SELECT, toManyTree) {
    const tableAlias = this._getTableAlias(SELECT, toManyTree)
    const readToOneCQN = this._getReadToOneCQN(SELECT, tableAlias)

    this._expandedToFlat({
      entity: cds.reflect(this._csn.definitions[this._getRef(SELECT).table]),
      givenColumns: SELECT.columns,
      readToOneCQN: readToOneCQN,
      tableAlias: tableAlias,
      toManyTree: toManyTree
    })

    // Add at start, so that the deepest level is post processed first
    this.queries.push({
      SELECT: readToOneCQN,
      _toManyTree: toManyTree
    })
  }

  /**
   * Self referencing associations, two expanded entities based on same table, ...
   * Requires an abstract name to prevent ambiguity issues.
   * Use hash to prevent names longer than support by DB.
   * @param SELECT
   * @param toManyTree
   * @returns {string}
   * @private
   */
  _getTableAlias (SELECT, toManyTree) {
    return this._createHash((toManyTree.length === 0) ? this._getRef(SELECT).table : toManyTree.join(':'))
  }

  _getRef (SELECT) {
    const table = (SELECT.from.hasOwnProperty('join')) ? this._getRefFromJoin(SELECT.from.args) : SELECT.from

    return {
      table: table.ref[0],
      as: table.as
    }
  }

  _getRefFromJoin (args) {
    if (args[0].ref) {
      return args[0]
    }

    // Order is reversed
    return args[args.length - 1]
  }

  /**
   * Create (md5) hash from value.
   * Used for abstraction and not for security.
   * @param value
   * @returns {string}
   * @private
   */
  _createHash (value) {
    // Prefixed as an alias cannot start with a number at SQL.
    return `t${crypto.createHash('md5').update(value).digest('hex')}`
  }

  /**
   * Get base CQN, with the same filters as origin.
   * @param {Object} SELECT
   * @param {string} tableAlias
   * @returns {Object}
   * @private
   */
  _getReadToOneCQN (SELECT, tableAlias) {
    // There should only be one entity in combination with expand
    const cqn = Object.assign({}, SELECT, {columns: []})

    if (cqn.from.hasOwnProperty('join')) {
      this._adaptJoin(tableAlias, cqn.from)
    } else {
      cqn.from.as = tableAlias
    }

    return cqn
  }

  _adaptJoin (tableAlias, from) {
    const target = (from.args[0].ref) ? from.args[0] : from.args[from.args.length - 1]
    const originalIdentifier = target.as || target.ref[0]
    target.as = tableAlias

    for (const column of from.on) {
      if (typeof column === 'object' && column.ref[0] === originalIdentifier) {
        column.ref[0] = tableAlias
      }
    }
  }

  /**
   * Ensure that columns are accesed in combination with table alias.
   * Prevents ambiquity issues.
   * @param {Object} cqn
   * @param {string} tableAlias
   * @returns {Object}
   * @private
   */
  _adaptWhere (cqn, tableAlias) {
    if (cqn.where) {
      for (const element of cqn.where) {
        this._checkWhereElementRecursive(cqn, element, tableAlias)
      }
    }

    return cqn
  }

  _checkWhereElementRecursive (cqn, element, tableAlias) {
    if (element.ref) {
      const aliasedTable = this._getRef(cqn)

      if (element.ref.length === 1) {
        element.ref.unshift(tableAlias)
      } else if (element.ref[0] === 'exists') {
        this._adaptExists(aliasedTable, element.ref[1].args, tableAlias)
      } else if (this._elementAliasNeedsReplacement(element, aliasedTable)) {
        element.ref[0] = tableAlias
      }
    } else if (element.xpr) {
      for (const nestedElement of element.xpr) {
        this._checkWhereElementRecursive(cqn, nestedElement, tableAlias)
      }
    }
  }

  /**
   * Change alias of most outer table query to md5 sum.
   * @param {Object} aliasedTable
   * @param {Array} args
   * @param {string} tableAlias
   * @private
   */
  _adaptExists (aliasedTable, args, tableAlias) {
    for (const arg of args) {
      if (!arg.SELECT || !arg.SELECT.where) {
        continue
      }

      for (const element of arg.SELECT.where) {
        if (this._elementAliasNeedsReplacement(element, aliasedTable)) {
          element.ref[0] = tableAlias
        }
      }
    }
  }

  _elementAliasNeedsReplacement (element, {table, as}) {
    if (!element.ref || element.ref.length !== 2) {
      return false
    }

    switch (element.ref[0]) {
      case table:
      case as:
        return true
      default:
        return false
    }
  }

  /**
   * Build CQN(s) with JOINs for expanding. In case of expanding with to many an additional CQN will be pushed to toManyCQN.
   * @param {Object} arg - Avoiding many arguments and issues that come with it by using an object.
   * @param {Object} arg.entity - Entity that is taken from CSN.
   * @param {Array} arg.givenColumns - List of read columns taken from CQN.
   * @param {Object} arg.readToOneCQN - Build CQN the JOIN(s) should be added to or it will be used to filter an expanded to many entity.
   * @param {string} arg.tableAlias - Table alias
   * @param {Array} arg.toManyCQN - List of build CQNs which are used to read expands with to many target.
   * @param {Array} arg.toManyTree - Information, where the expand array is located in the result array.
   * @returns {Object}
   * @private
   */
  _expandedToFlat ({entity, givenColumns, readToOneCQN, tableAlias, toManyTree}) {
    const toManyColumns = []
    const mappings = this._getMappingObject(toManyTree)

    for (const column of givenColumns) {
      // To many can only be build, once all other columns have been processed.
      if (this._isExpandToMany(column, entity)) {
        mappings[column.ref[0]] = {[TO_MANY]: true}
        toManyColumns.push(column)

        // Expands with to one target can be processed directly
      } else if (column.expand) {
        this._addJoinAndElements({
          column,
          entity,
          readToOneCQN,
          toManyTree,
          parentAlias: tableAlias
        })

        // No expand, directly add the column and its mapping.
      } else {
        readToOneCQN.columns.push(this._addAliasToColumn(column, entity, tableAlias, mappings))
      }
    }

    // only as second step handle expand to many, or else keys might still be unknown
    this._toMany({entity, readToOneCQN, tableAlias, toManyColumns, toManyTree, mappings})
  }

  /**
   * Follow the tree to get to the relevant config object.
   * @param {Array} toManyTree
   * @returns {Object}
   * @private
   */
  _getMappingObject (toManyTree) {
    let mappings = this.mappings

    for (const element of toManyTree) {
      if (!mappings[element]) {
        mappings[element] = {}
      }

      mappings = mappings[element]
    }

    return mappings
  }

  _isExpandToMany (column, entity) {
    return column.expand && cds.reflect(entity.def.elements[column.ref[0]]).is2many
  }

  /**
   * Adds JOIN instructions to CQN for expands with 1:1 target and returns config how to map it back.
   * @param column
   * @param entity
   * @param readToOneCQN
   * @param toManyCQN
   * @param toManyTree
   * @returns {Object}
   * @private
   */
  _addJoinAndElements ({column, entity, readToOneCQN, toManyTree, parentAlias}) {
    const extendedToManyTree = toManyTree.concat(column.ref)
    const tableAlias = this._createHash(extendedToManyTree.join(':'))

    readToOneCQN.from = {
      args: [
        readToOneCQN.from,
        {ref: [entity.def.elements[column.ref[0]].target], as: tableAlias}
      ],
      join: entity.def.elements[column.ref[0]].notNull ? 'inner' : 'left',
      on: getOnCond(entity.def.elements[column.ref[0]], column.ref[0], this._csn, tableAlias, parentAlias)
    }

    this._expandedToFlat({
      entity: cds.reflect(this._csn.definitions[entity.def.elements[column.ref[0]].target]),
      givenColumns: column.expand,
      readToOneCQN: readToOneCQN,
      tableAlias: tableAlias,
      toManyTree: extendedToManyTree
    })
  }

  /**
   * Add an unique alias to each column, to avoid ambiguity.
   * Add this information to the post process config.
   * @param column
   * @param entity
   * @param tableAlias
   * @returns {Object}
   * @private
   */
  _addAliasToColumn (column, entity, tableAlias, mappings) {
    // No identifier for this row entry or technical column
    if (this._isAliasNotNeeded(column)) {
      return column
    }

    return this._buildNewAliasColumn(column, entity, tableAlias, mappings)
  }

  /**
   * Technical or a value without a casted name, or some other not yet supported combinations should not be refactored.
   * @param {Object} column
   * @returns {boolean}
   * @private
   */
  _isAliasNotNeeded (column) {
    // functions, direct values, ...
    if (!column.ref && !column.as) {
      return true
    }

    // No column name specified means false
    return (column.ref && typeof column.ref[column.ref.length - 1] !== 'string')
  }

  _buildNewAliasColumn (column, entity, tableAlias, mappings) {
    // Casted name, vs column name
    const identifier = this._getIdentifier(column, tableAlias)
    const as = column.as || `${tableAlias}_${identifier}`
    const aliasedElement = Object.assign({}, column)
    aliasedElement.as = as

    // Add table alias or name to handle cases, where joined tables have same column names
    if (this._isElement(column.ref, entity.def)) {
      const alias = tableAlias || entity.def.name
      aliasedElement.ref = (alias) ? [alias, column.ref[0]] : [column.ref[0]]
    }

    if (!column[SKIP_MAPPING]) {
      mappings[identifier] = as
    }

    return aliasedElement
  }

  _getIdentifier (column, tableAlias) {
    if (column.as) {
      return (column.as.startsWith(`${tableAlias}_`)) ? column.ref[column.ref.length - 1] : column.as
    }

    return column.ref[column.ref.length - 1]
  }

  _isElement (ref, def) {
    if (!ref || ref.length !== 1) {
      return false
    }

    // Normal element
    if (def.elements[ref[0]]) {
      return true
    }

    // Auto gen column from managed association
    if (this._isAutoGenColumn(ref[0], def.elements)) {
      return true
    }

    return this._isComplexType(ref[0].split('_'), def)
  }

  _isAutoGenColumn (columnName, elements) {
    for (const key of Object.keys(elements)) {
      const element = elements[key]
      if (columnName.startsWith(key) && element.type === 'cds.Association' && element.foreignKeys) {
        // works only for single keys
        if (columnName === `${key}_${Object.getOwnPropertyNames(element.foreignKeys)[0]}`) {
          return true
        }
      }
    }

    return false
  }

  _isComplexType (parts, def) {
    const removed = []

    // Remove from the end until there is no more left
    while (parts.length !== 0) {
      const element = def.elements[parts.join('_')]

      if (element) {
        // If nothing has been removed, we are at the end of the nesting
        return (removed.length === 0) ? true : this._isComplexType(removed, element)
      }

      removed.unshift(parts.pop())
    }

    return false
  }

  _getKeyNames (entity) {
    const keys = entity.keys

    if (!keys) {
      return
    }

    const keyNames = []

    for (const key of Object.keys(keys)) {
      if (!keys[key].foreignKeys) {
        keyNames.push(key)
      }
    }

    return keyNames
  }

  _toMany ({entity, readToOneCQN, tableAlias, toManyColumns, toManyTree, mappings}) {
    if (toManyColumns.length === 0) {
      return
    }

    this._addKeysIfNeeded({entity, readToOneCQN, tableAlias})

    for (const column of toManyColumns) {
      this._createJoinCQNFromExpanded((this._buildExpandedCQN({column, entity, readToOneCQN, toManyTree, mappings})), toManyTree.concat([column.ref[0]]))
    }
  }

  /**
   * In case of to many relations, a key is needed for post processing.
   * @param {Object} args
   * @param {string} args.alias - Alias or table name.
   * @param {Object} args.entity - The entity in CSN format, which is accessed.
   * @param {Object} args.expandConfig - Configuration how to post process the raw result.
   * @param {Object} args.joinCQN - To be constructed CQN containing the joins instead of expands.
   * @param {boolean} args.keyNotInColumnList - If the identifier is already in the list of columns.
   * @param {Array} args.toManyTree - Holds information how deeply nested the expand is and where the result is added in the tree.
   * @private
   */
  _addKeysIfNeeded ({entity, readToOneCQN, tableAlias}) {
    for (const name of this._getMissingKeys({entity, readToOneCQN, tableAlias})) {
      readToOneCQN.columns.push({
        as: `${tableAlias}_${name}`,
        ref: [tableAlias, name]
      })
    }
  }

  /**
   * Compare the list of available keys with keys listed already listed at CQN and return missing.
   * @param entity
   * @param readToOneCQN
   * @param tableAlias
   * @returns {Array}
   * @private
   */
  _getMissingKeys ({entity, readToOneCQN, tableAlias}) {
    const keyNames = this._getKeyNames(entity)

    if (!keyNames) {
      return
    }

    return keyNames.filter((name) => {
      let missing = true

      for (const column of readToOneCQN.columns) {
        if (column.as === `${tableAlias}_${name}`) {
          missing = false
        }
      }

      return missing
    })
  }

  /**
   * Construct the base CQN for a to many expands.
   * @param {string} toManyTree - Table alias
   * @param {Object} column - Column with expand.
   * @param {Object} entity - Entity that is taken from CSN.
   * @param {Object} joinCQN - Build CQN the JOIN(s) should be added to or it will be used to filter an expanded to many entity.
   * @returns {Object}
   * @private
   */
  _buildExpandedCQN ({column, entity, readToOneCQN, toManyTree, mappings}) {
    const tableAlias = this._createHash(toManyTree.concat(column.ref).join(':'))
    const on = getOnCond(entity.def.elements[column.ref[0]], column.ref[0], this._csn, tableAlias, 'filterExpand')
    const filterExpand = this._getFilterExpandCQN(readToOneCQN, on)
    const joinColumns = this._getJoinColumnsFromOnAddToMapping(mappings[column.ref[0]], readToOneCQN, on)
    const expandedEntity = cds.reflect(this._csn.definitions[entity.def.elements[column.ref[0]].target])

    return {
      from: {
        join: 'inner',
        args: [
          {ref: [entity.def.elements[column.ref[0]].target], as: tableAlias},
          filterExpand
        ],
        on: on
      },
      columns: this._getColumnsForExpand({tableAlias, columnList: column, entity: expandedEntity, joinColumns})
    }
  }

  /**
   * Reduce column list to column(s) needed to merge the result into one.
   * @param {Object} readToOneCQN
   * @param {Object} on
   * @returns {Object}
   * @private
   */
  _getFilterExpandCQN (readToOneCQN, on) {
    const columns = []

    for (const entry of on) {
      if (typeof entry === 'object' && entry.ref[0] === 'filterExpand') {
        columns.push({
          ref: [this._getAlias(readToOneCQN), entry.ref[1]],
          as: entry.ref[1]
        })
      }
    }

    return {
      SELECT: Object.assign({}, readToOneCQN, {columns: columns}),
      as: 'filterExpand'
    }
  }

  _getAlias (SELECT) {
    const {as, table} = this._getRef(SELECT)
    return as || table
  }

  /**
   * In case a column is used at a JOIN, it needs to be added to the list of selected columns.
   * @param {Object} mapping
   * @param {Object} readToOneCQN
   * @param {Array} on
   * @returns {Array}
   * @private
   */
  _getJoinColumnsFromOnAddToMapping (mapping, readToOneCQN, on) {
    const columns = []
    const columnNames = []
    mapping[TO_MANY_KEYS] = []

    for (const entry of on) {
      if (typeof entry === 'object' && entry.ref[0] !== 'filterExpand') {
        const as = entry.ref.join('_')

        mapping[TO_MANY_KEYS].push(as)

        columns.push({
          ref: entry.ref,
          as: as,
          [SKIP_MAPPING]: true
        })
      } else if (typeof entry === 'object') {
        columnNames.push(`${this._getAlias(readToOneCQN)}_${entry.ref[1]}`)
      }
    }

    // Function will be used a post processing to create unique keys for cache and lookup the same
    mapping[GET_KEY_VALUE] = (atExpanded, entry) => {
      const keyValue = []
      const keyList = (atExpanded) ? mapping[TO_MANY_KEYS] : columnNames

      for (const key of keyList) {
        keyValue.push(entry[key])
      }

      return keyValue.join(':')
    }

    return columns
  }

  /**
   * Get the explicitly named columns for expand and add ID columns, so the result can be added to the correct part at merged result.
   * @param tableAlias
   * @param columnList
   * @param entity
   * @param joinCQN
   * @returns {Object}
   * @private
   */
  _getColumnsForExpand ({tableAlias, columnList, entity, joinColumns}) {
    const columns = []
    const keys = this._getKeyNames(entity)

    for (const column of columnList.expand) {
      if (column.expand || !column.ref) {
        columns.push(column)
      } else {
        this._addToColumnList(columns, keys, tableAlias, column)
      }
    }

    this._addMissingJoinColumns(columns, joinColumns, keys)
    this._addMissingKeyColumns(columns, tableAlias, keys)

    return columns
  }

  _addToColumnList (columns, keys, tableAlias, column) {
    const columnName = column.ref[column.ref.length - 1]

    this._removeExistingKeyFromList(keys, columnName)

    columns.push({
      ref: [tableAlias, columnName],
      as: column.as || `${tableAlias}_${columnName}`
    })

    return columnName
  }

  _removeExistingKeyFromList (keys, columnName) {
    const index = keys.indexOf(columnName)

    if (index === -1) {
      return false
    }

    keys.splice(index, 1)

    return true
  }

  _addMissingJoinColumns (columns, joinColumns, keys) {
    for (const joinColumn of joinColumns) {
      if (!this._columnIncluded(joinColumn, columns)) {
        this._removeExistingKeyFromList(keys, joinColumn[1])
        columns.push(joinColumn)
      }
    }
  }

  _columnIncluded (column, columns) {
    for (const entry of columns) {
      if (column.ref[1] === entry[1]) {
        return true
      }
    }

    return false
  }

  /**
   * Add key columns if they are not already existing in the list.
   * @param columns
   * @param tableAlias
   * @param keys
   * @private
   */
  _addMissingKeyColumns (columns, tableAlias, keys) {
    for (const key of keys) {
      columns.push({
        ref: [tableAlias, key],
        as: `${tableAlias}_${key}`
      })
    }
  }
}

/**
 * Creates CQN(s) by using JOIN for all expanded entries, as expanding is not supported by SQL.
 * @param {Object} cqn - CQN with expanded columns
 * @param {Object} csn - Services CSN
 * @returns {Object}
 * @private
 */
const createJoinCQNFromExpanded = (cqn, csn) => {
  return new JoinCQNFromExpanded(cqn, csn).buildJoinQueries()
}

/**
 * Check if the given CQN is of type select and contains expand.
 * @param {Object} cqn
 * @returns {boolean}
 * @private
 */
const hasExpand = (cqn) => {
  if (cqn && cqn.SELECT && Array.isArray(cqn.SELECT.columns)) {
    for (const column of cqn.SELECT.columns) {
      if (column.expand) {
        return true
      }
    }
  }

  return false
}

module.exports = {
  createJoinCQNFromExpanded,
  hasExpand
}
