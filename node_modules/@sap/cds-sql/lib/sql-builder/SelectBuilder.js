const BaseBuilder = require('./BaseBuilder')

/**
 * SelectBuilder is used to take a CQN object as an input and to build a SQL Select string from it.
 *
 * Currently not supported are:
 * - "cast" in "column_expr"
 * - "mixin"
 * - "excluding"
 *
 *  @example <caption>Definition of CQN </caption>
 * {
 *  SELECT = {SELECT:{
 *  distinct: true,
 *  from: source | join,
 *  columns: projection,
 *  where: _xpr,   groupBy: [ ...expr ],
 *  having: _xpr,  orderBy: [ ...ordering_term ],
 *  limit: { rows:expr, offset:expr }
 *  }}
 * }
 *
 * source         =  ( ref | SELECT ) + { as:string }
 * join           =  { join:string, sources:[...source], on:_xpr }
 * projection     =  [ ...column_expr ]
 * column_expr    =  expr + { as:string }
 * ordering_term  =  expr + { sort: 'asc'|'desc' }
 */
class SelectBuilder extends BaseBuilder {
  get ExpressionBuilder () {
    const ExpressionBuilder = require('./ExpressionBuilder')
    Object.defineProperty(this, 'ExpressionBuilder', {value: ExpressionBuilder})
    return ExpressionBuilder
  }

  get ReferenceBuilder () {
    const ReferenceBuilder = require('./ReferenceBuilder')
    Object.defineProperty(this, 'ReferenceBuilder', {value: ReferenceBuilder})
    return ReferenceBuilder
  }

  /**
   * Builds an Object based on the properties of the CQN object.
   * @example <caption>Example output</caption>
   * {
   *   sql: 'SELECT "a", "b", "c" FROM "T" HAVING "x" < ? ',
   *   values: [9]
   * }
   *
   * @returns {{sql: string, values: Array}} Object with two properties.
   * SQL string for prepared statement and array of values to replace the placeholders.
   */
  build () {
    this._outputObj = {
      sql: ['SELECT'],
      values: []
    }
    this._addEntityNames(this._obj.SELECT.from)
    if (this._obj.SELECT.distinct) {
      this._distinct()
    }
    this._columns()
    this._from()
    if (this._obj.SELECT.hasOwnProperty('where')) {
      this._where()
    }
    if (this._obj.SELECT.hasOwnProperty('groupBy')) {
      this._groupBy()
    }
    if (this._obj.SELECT.hasOwnProperty('having')) {
      this._having()
    }
    if (this._obj.SELECT.hasOwnProperty('orderBy')) {
      this._orderBy()
    }
    if (this._obj.SELECT.hasOwnProperty('limit')) {
      this._limit()
    }
    this._outputObj.sql = this._outputObj.sql.join(' ')
    return this._outputObj
  }

  _addEntityNames (fromObj) {
    if (fromObj.as) {
      this._options.entityNames.push(fromObj.as)
    } else if (fromObj.ref) {
      this._options.entityNames.push(...fromObj.ref)
    } else if (fromObj.args) {
      for (let arg of fromObj.args) {
        this._addEntityNames(arg)
      }
    }
  }

  _distinct () {
    this._outputObj.sql.push('DISTINCT')
  }

  _from () {
    this._outputObj.sql.push('FROM')

    if (this._obj.SELECT.from.hasOwnProperty('join')) {
      this._fromJoin(this._obj.SELECT.from)
    } else {
      this._fromElement(this._obj.SELECT.from)
    }
  }

  _fromJoin (from) {
    const len = from.args.length
    for (let i = 0; i < len; i++) {
      if (from.args[i].args) {
        // nested joins
        this._fromJoin(from.args[i])
      } else {
        this._fromElement(from.args[i], from, i)
      }
    }
  }

  _fromElement (element, parent, i = 0) {
    let res = {}
    if (element.ref) { // ref
      res = new this.ReferenceBuilder(element, this._options).build()
    } else { // select
      res = new SelectBuilder(element, this._options).build()
      res.sql = `(${res.sql})`
    }
    if (element.as) { // identifier
      res.sql += ` ${this._quoteElement(element.as)}`
    }
    this._outputObj.values = this._outputObj.values.concat(res.values)
    if (i === 0) { // first element
      this._outputObj.sql.push(res.sql)
    } else { // join
      this._outputObj.sql.push(parent.join.toUpperCase(), 'JOIN', res.sql)
      if (parent.on) {
        const expr = new this.ExpressionBuilder(parent.on, this._options).build()
        this._outputObj.sql.push('ON', expr.sql)
        this._outputObj.values = this._outputObj.values.concat(expr.values)
      }
    }
  }

  _buildElement (col) {
    let res = {}
    if (col.ref) { // ref
      res = new this.ReferenceBuilder(col, this._options).build()
    } else if (col.xpr) { // xpr
      res = new this.ExpressionBuilder(col, Object.assign({objectKey: 'xpr'}, this._options)).build()
    } else if (col.hasOwnProperty('SELECT')) { // SELECT
      res = new SelectBuilder(col, this._options).build()
      res.sql = `( ${res.sql} )`
    } else { // val
      res.sql = this._val(col)
      res.values = []
    }

    if (col.as) { // as
      res.sql += ` AS ${this._quoteElement(col.as)}`
    }

    this._outputObj.values = this._outputObj.values.concat(res.values)
    return res.sql
  }

  _columns () {
    if (Array.isArray(this._obj.SELECT.columns) && this._obj.SELECT.columns.length !== 0) {
      this._outputObj.sql.push(this._obj.SELECT.columns.map((col) => this._buildElement(col)).join(', '))
    } else {
      this._outputObj.sql.push('*')
    }
  }

  _where () {
    const where = new this.ExpressionBuilder(this._obj.SELECT.where, this._options).build()
    this._outputObj.sql.push('WHERE', where.sql)
    this._outputObj.values = this._outputObj.values.concat(where.values)
  }

  _groupBy () {
    const sqls = []
    this._outputObj.sql.push('GROUP BY')
    for (const element of this._obj.SELECT.groupBy) {
      const res = new this.ReferenceBuilder(element, this._options).build()
      sqls.push(res.sql)
      this._outputObj.values = this._outputObj.values.concat(res.values)
    }
    this._outputObj.sql.push(sqls.join(', '))
  }

  _having () {
    const having = new this.ExpressionBuilder(this._obj.SELECT.having, this._options).build()
    this._outputObj.sql.push('HAVING', having.sql)
    this._outputObj.values = this._outputObj.values.concat(having.values)
  }

  _orderBy () {
    const sqls = []
    this._outputObj.sql.push('ORDER BY')
    for (const element of this._obj.SELECT.orderBy) {
      const res = new this.ReferenceBuilder(element, this._options).build()
      if (element.sort === 'asc') {
        res.sql += ' ASC'
      } else if (element.sort === 'desc') {
        res.sql += ' DESC'
      }
      sqls.push(res.sql)
      this._outputObj.values = this._outputObj.values.concat(res.values)
    }
    this._outputObj.sql.push(sqls.join(', '))
  }

  _limit () {
    this._outputObj.sql.push('LIMIT', this._obj.SELECT.limit.rows.val)
    if (this._obj.SELECT.limit.offset) {
      this._outputObj.sql.push('OFFSET', this._obj.SELECT.limit.offset.val)
    }
  }

  _val (obj) {
    return obj.val
  }
}

module.exports = SelectBuilder
